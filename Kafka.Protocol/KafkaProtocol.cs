#pragma warning disable 1591
// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipelines;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Kafka.Protocol.Records;
// ReSharper disable MemberHidesStaticFromOuterClass FromReaderAsync will cause a lot of these warnings
namespace Kafka.Protocol
{
	public static class Messages 
	{
		public static async ValueTask<Message> CreateRequestMessageFromReaderAsync(
			Int16 apiKey, 
			Int16 version, 
			PipeReader reader, 
			CancellationToken cancellationToken = default)
		{
			if (AddOffsetsToTxnRequest.ApiKey == apiKey)
				return await AddOffsetsToTxnRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AddPartitionsToTxnRequest.ApiKey == apiKey)
				return await AddPartitionsToTxnRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AddRaftVoterRequest.ApiKey == apiKey)
				return await AddRaftVoterRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AllocateProducerIdsRequest.ApiKey == apiKey)
				return await AllocateProducerIdsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterClientQuotasRequest.ApiKey == apiKey)
				return await AlterClientQuotasRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterConfigsRequest.ApiKey == apiKey)
				return await AlterConfigsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterPartitionReassignmentsRequest.ApiKey == apiKey)
				return await AlterPartitionReassignmentsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterPartitionRequest.ApiKey == apiKey)
				return await AlterPartitionRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterReplicaLogDirsRequest.ApiKey == apiKey)
				return await AlterReplicaLogDirsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterUserScramCredentialsRequest.ApiKey == apiKey)
				return await AlterUserScramCredentialsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ApiVersionsRequest.ApiKey == apiKey)
				return await ApiVersionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AssignReplicasToDirsRequest.ApiKey == apiKey)
				return await AssignReplicasToDirsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (BeginQuorumEpochRequest.ApiKey == apiKey)
				return await BeginQuorumEpochRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (BrokerHeartbeatRequest.ApiKey == apiKey)
				return await BrokerHeartbeatRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (BrokerRegistrationRequest.ApiKey == apiKey)
				return await BrokerRegistrationRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ConsumerGroupDescribeRequest.ApiKey == apiKey)
				return await ConsumerGroupDescribeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ConsumerGroupHeartbeatRequest.ApiKey == apiKey)
				return await ConsumerGroupHeartbeatRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ControlledShutdownRequest.ApiKey == apiKey)
				return await ControlledShutdownRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ControllerRegistrationRequest.ApiKey == apiKey)
				return await ControllerRegistrationRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreateAclsRequest.ApiKey == apiKey)
				return await CreateAclsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreateDelegationTokenRequest.ApiKey == apiKey)
				return await CreateDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreatePartitionsRequest.ApiKey == apiKey)
				return await CreatePartitionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreateTopicsRequest.ApiKey == apiKey)
				return await CreateTopicsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteAclsRequest.ApiKey == apiKey)
				return await DeleteAclsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteGroupsRequest.ApiKey == apiKey)
				return await DeleteGroupsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteRecordsRequest.ApiKey == apiKey)
				return await DeleteRecordsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteShareGroupStateRequest.ApiKey == apiKey)
				return await DeleteShareGroupStateRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteTopicsRequest.ApiKey == apiKey)
				return await DeleteTopicsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeAclsRequest.ApiKey == apiKey)
				return await DescribeAclsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeClientQuotasRequest.ApiKey == apiKey)
				return await DescribeClientQuotasRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeClusterRequest.ApiKey == apiKey)
				return await DescribeClusterRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeConfigsRequest.ApiKey == apiKey)
				return await DescribeConfigsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeDelegationTokenRequest.ApiKey == apiKey)
				return await DescribeDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeGroupsRequest.ApiKey == apiKey)
				return await DescribeGroupsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeLogDirsRequest.ApiKey == apiKey)
				return await DescribeLogDirsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeProducersRequest.ApiKey == apiKey)
				return await DescribeProducersRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeQuorumRequest.ApiKey == apiKey)
				return await DescribeQuorumRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeTopicPartitionsRequest.ApiKey == apiKey)
				return await DescribeTopicPartitionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeTransactionsRequest.ApiKey == apiKey)
				return await DescribeTransactionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeUserScramCredentialsRequest.ApiKey == apiKey)
				return await DescribeUserScramCredentialsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ElectLeadersRequest.ApiKey == apiKey)
				return await ElectLeadersRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (EndQuorumEpochRequest.ApiKey == apiKey)
				return await EndQuorumEpochRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (EndTxnRequest.ApiKey == apiKey)
				return await EndTxnRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (EnvelopeRequest.ApiKey == apiKey)
				return await EnvelopeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ExpireDelegationTokenRequest.ApiKey == apiKey)
				return await ExpireDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (FetchRequest.ApiKey == apiKey)
				return await FetchRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (FetchSnapshotRequest.ApiKey == apiKey)
				return await FetchSnapshotRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (FindCoordinatorRequest.ApiKey == apiKey)
				return await FindCoordinatorRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (GetTelemetrySubscriptionsRequest.ApiKey == apiKey)
				return await GetTelemetrySubscriptionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (HeartbeatRequest.ApiKey == apiKey)
				return await HeartbeatRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (IncrementalAlterConfigsRequest.ApiKey == apiKey)
				return await IncrementalAlterConfigsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (InitializeShareGroupStateRequest.ApiKey == apiKey)
				return await InitializeShareGroupStateRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (InitProducerIdRequest.ApiKey == apiKey)
				return await InitProducerIdRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (JoinGroupRequest.ApiKey == apiKey)
				return await JoinGroupRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (LeaderAndIsrRequest.ApiKey == apiKey)
				return await LeaderAndIsrRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (LeaveGroupRequest.ApiKey == apiKey)
				return await LeaveGroupRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListClientMetricsResourcesRequest.ApiKey == apiKey)
				return await ListClientMetricsResourcesRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListGroupsRequest.ApiKey == apiKey)
				return await ListGroupsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListOffsetsRequest.ApiKey == apiKey)
				return await ListOffsetsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListPartitionReassignmentsRequest.ApiKey == apiKey)
				return await ListPartitionReassignmentsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListTransactionsRequest.ApiKey == apiKey)
				return await ListTransactionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (MetadataRequest.ApiKey == apiKey)
				return await MetadataRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetCommitRequest.ApiKey == apiKey)
				return await OffsetCommitRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetDeleteRequest.ApiKey == apiKey)
				return await OffsetDeleteRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetFetchRequest.ApiKey == apiKey)
				return await OffsetFetchRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetForLeaderEpochRequest.ApiKey == apiKey)
				return await OffsetForLeaderEpochRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ProduceRequest.ApiKey == apiKey)
				return await ProduceRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (PushTelemetryRequest.ApiKey == apiKey)
				return await PushTelemetryRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ReadShareGroupStateRequest.ApiKey == apiKey)
				return await ReadShareGroupStateRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ReadShareGroupStateSummaryRequest.ApiKey == apiKey)
				return await ReadShareGroupStateSummaryRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (RemoveRaftVoterRequest.ApiKey == apiKey)
				return await RemoveRaftVoterRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (RenewDelegationTokenRequest.ApiKey == apiKey)
				return await RenewDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (SaslAuthenticateRequest.ApiKey == apiKey)
				return await SaslAuthenticateRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (SaslHandshakeRequest.ApiKey == apiKey)
				return await SaslHandshakeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareAcknowledgeRequest.ApiKey == apiKey)
				return await ShareAcknowledgeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareFetchRequest.ApiKey == apiKey)
				return await ShareFetchRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareGroupDescribeRequest.ApiKey == apiKey)
				return await ShareGroupDescribeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareGroupHeartbeatRequest.ApiKey == apiKey)
				return await ShareGroupHeartbeatRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (StopReplicaRequest.ApiKey == apiKey)
				return await StopReplicaRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (SyncGroupRequest.ApiKey == apiKey)
				return await SyncGroupRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (TxnOffsetCommitRequest.ApiKey == apiKey)
				return await TxnOffsetCommitRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UnregisterBrokerRequest.ApiKey == apiKey)
				return await UnregisterBrokerRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UpdateFeaturesRequest.ApiKey == apiKey)
				return await UpdateFeaturesRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UpdateMetadataRequest.ApiKey == apiKey)
				return await UpdateMetadataRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UpdateRaftVoterRequest.ApiKey == apiKey)
				return await UpdateRaftVoterRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (VoteRequest.ApiKey == apiKey)
				return await VoteRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (WriteShareGroupStateRequest.ApiKey == apiKey)
				return await WriteShareGroupStateRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (WriteTxnMarkersRequest.ApiKey == apiKey)
				return await WriteTxnMarkersRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			throw new ArgumentException($"There is no request message with api key {apiKey}");
		}

		public static async ValueTask<Message> CreateResponseMessageFromReaderAsync(
			Int16 apiKey, 
			Int16 version, 
			PipeReader reader, 
			CancellationToken cancellationToken = default)
		{
			if (AddOffsetsToTxnResponse.ApiKey == apiKey)
				return await AddOffsetsToTxnResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AddPartitionsToTxnResponse.ApiKey == apiKey)
				return await AddPartitionsToTxnResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AddRaftVoterResponse.ApiKey == apiKey)
				return await AddRaftVoterResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AllocateProducerIdsResponse.ApiKey == apiKey)
				return await AllocateProducerIdsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterClientQuotasResponse.ApiKey == apiKey)
				return await AlterClientQuotasResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterConfigsResponse.ApiKey == apiKey)
				return await AlterConfigsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterPartitionReassignmentsResponse.ApiKey == apiKey)
				return await AlterPartitionReassignmentsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterPartitionResponse.ApiKey == apiKey)
				return await AlterPartitionResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterReplicaLogDirsResponse.ApiKey == apiKey)
				return await AlterReplicaLogDirsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AlterUserScramCredentialsResponse.ApiKey == apiKey)
				return await AlterUserScramCredentialsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ApiVersionsResponse.ApiKey == apiKey)
				return await ApiVersionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (AssignReplicasToDirsResponse.ApiKey == apiKey)
				return await AssignReplicasToDirsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (BeginQuorumEpochResponse.ApiKey == apiKey)
				return await BeginQuorumEpochResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (BrokerHeartbeatResponse.ApiKey == apiKey)
				return await BrokerHeartbeatResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (BrokerRegistrationResponse.ApiKey == apiKey)
				return await BrokerRegistrationResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ConsumerGroupDescribeResponse.ApiKey == apiKey)
				return await ConsumerGroupDescribeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ConsumerGroupHeartbeatResponse.ApiKey == apiKey)
				return await ConsumerGroupHeartbeatResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ControlledShutdownResponse.ApiKey == apiKey)
				return await ControlledShutdownResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ControllerRegistrationResponse.ApiKey == apiKey)
				return await ControllerRegistrationResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreateAclsResponse.ApiKey == apiKey)
				return await CreateAclsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreateDelegationTokenResponse.ApiKey == apiKey)
				return await CreateDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreatePartitionsResponse.ApiKey == apiKey)
				return await CreatePartitionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (CreateTopicsResponse.ApiKey == apiKey)
				return await CreateTopicsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteAclsResponse.ApiKey == apiKey)
				return await DeleteAclsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteGroupsResponse.ApiKey == apiKey)
				return await DeleteGroupsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteRecordsResponse.ApiKey == apiKey)
				return await DeleteRecordsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteShareGroupStateResponse.ApiKey == apiKey)
				return await DeleteShareGroupStateResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DeleteTopicsResponse.ApiKey == apiKey)
				return await DeleteTopicsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeAclsResponse.ApiKey == apiKey)
				return await DescribeAclsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeClientQuotasResponse.ApiKey == apiKey)
				return await DescribeClientQuotasResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeClusterResponse.ApiKey == apiKey)
				return await DescribeClusterResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeConfigsResponse.ApiKey == apiKey)
				return await DescribeConfigsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeDelegationTokenResponse.ApiKey == apiKey)
				return await DescribeDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeGroupsResponse.ApiKey == apiKey)
				return await DescribeGroupsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeLogDirsResponse.ApiKey == apiKey)
				return await DescribeLogDirsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeProducersResponse.ApiKey == apiKey)
				return await DescribeProducersResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeQuorumResponse.ApiKey == apiKey)
				return await DescribeQuorumResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeTopicPartitionsResponse.ApiKey == apiKey)
				return await DescribeTopicPartitionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeTransactionsResponse.ApiKey == apiKey)
				return await DescribeTransactionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (DescribeUserScramCredentialsResponse.ApiKey == apiKey)
				return await DescribeUserScramCredentialsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ElectLeadersResponse.ApiKey == apiKey)
				return await ElectLeadersResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (EndQuorumEpochResponse.ApiKey == apiKey)
				return await EndQuorumEpochResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (EndTxnResponse.ApiKey == apiKey)
				return await EndTxnResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (EnvelopeResponse.ApiKey == apiKey)
				return await EnvelopeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ExpireDelegationTokenResponse.ApiKey == apiKey)
				return await ExpireDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (FetchResponse.ApiKey == apiKey)
				return await FetchResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (FetchSnapshotResponse.ApiKey == apiKey)
				return await FetchSnapshotResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (FindCoordinatorResponse.ApiKey == apiKey)
				return await FindCoordinatorResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (GetTelemetrySubscriptionsResponse.ApiKey == apiKey)
				return await GetTelemetrySubscriptionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (HeartbeatResponse.ApiKey == apiKey)
				return await HeartbeatResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (IncrementalAlterConfigsResponse.ApiKey == apiKey)
				return await IncrementalAlterConfigsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (InitializeShareGroupStateResponse.ApiKey == apiKey)
				return await InitializeShareGroupStateResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (InitProducerIdResponse.ApiKey == apiKey)
				return await InitProducerIdResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (JoinGroupResponse.ApiKey == apiKey)
				return await JoinGroupResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (LeaderAndIsrResponse.ApiKey == apiKey)
				return await LeaderAndIsrResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (LeaveGroupResponse.ApiKey == apiKey)
				return await LeaveGroupResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListClientMetricsResourcesResponse.ApiKey == apiKey)
				return await ListClientMetricsResourcesResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListGroupsResponse.ApiKey == apiKey)
				return await ListGroupsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListOffsetsResponse.ApiKey == apiKey)
				return await ListOffsetsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListPartitionReassignmentsResponse.ApiKey == apiKey)
				return await ListPartitionReassignmentsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ListTransactionsResponse.ApiKey == apiKey)
				return await ListTransactionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (MetadataResponse.ApiKey == apiKey)
				return await MetadataResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetCommitResponse.ApiKey == apiKey)
				return await OffsetCommitResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetDeleteResponse.ApiKey == apiKey)
				return await OffsetDeleteResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetFetchResponse.ApiKey == apiKey)
				return await OffsetFetchResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (OffsetForLeaderEpochResponse.ApiKey == apiKey)
				return await OffsetForLeaderEpochResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ProduceResponse.ApiKey == apiKey)
				return await ProduceResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (PushTelemetryResponse.ApiKey == apiKey)
				return await PushTelemetryResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ReadShareGroupStateResponse.ApiKey == apiKey)
				return await ReadShareGroupStateResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ReadShareGroupStateSummaryResponse.ApiKey == apiKey)
				return await ReadShareGroupStateSummaryResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (RemoveRaftVoterResponse.ApiKey == apiKey)
				return await RemoveRaftVoterResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (RenewDelegationTokenResponse.ApiKey == apiKey)
				return await RenewDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (SaslAuthenticateResponse.ApiKey == apiKey)
				return await SaslAuthenticateResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (SaslHandshakeResponse.ApiKey == apiKey)
				return await SaslHandshakeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareAcknowledgeResponse.ApiKey == apiKey)
				return await ShareAcknowledgeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareFetchResponse.ApiKey == apiKey)
				return await ShareFetchResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareGroupDescribeResponse.ApiKey == apiKey)
				return await ShareGroupDescribeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (ShareGroupHeartbeatResponse.ApiKey == apiKey)
				return await ShareGroupHeartbeatResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (StopReplicaResponse.ApiKey == apiKey)
				return await StopReplicaResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (SyncGroupResponse.ApiKey == apiKey)
				return await SyncGroupResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (TxnOffsetCommitResponse.ApiKey == apiKey)
				return await TxnOffsetCommitResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UnregisterBrokerResponse.ApiKey == apiKey)
				return await UnregisterBrokerResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UpdateFeaturesResponse.ApiKey == apiKey)
				return await UpdateFeaturesResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UpdateMetadataResponse.ApiKey == apiKey)
				return await UpdateMetadataResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (UpdateRaftVoterResponse.ApiKey == apiKey)
				return await UpdateRaftVoterResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (VoteResponse.ApiKey == apiKey)
				return await VoteResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (WriteShareGroupStateResponse.ApiKey == apiKey)
				return await WriteShareGroupStateResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			if (WriteTxnMarkersResponse.ApiKey == apiKey)
				return await WriteTxnMarkersResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			throw new ArgumentException($"There is no response message with api key {apiKey}");
		}

		public static Int16 GetRequestHeaderVersionFor(Int16 apiKey, Int16 version)
		{
			if (AddOffsetsToTxnRequest.ApiKey == apiKey)
				return new AddOffsetsToTxnRequest(version).HeaderVersion;
			if (AddPartitionsToTxnRequest.ApiKey == apiKey)
				return new AddPartitionsToTxnRequest(version).HeaderVersion;
			if (AddRaftVoterRequest.ApiKey == apiKey)
				return new AddRaftVoterRequest(version).HeaderVersion;
			if (AllocateProducerIdsRequest.ApiKey == apiKey)
				return new AllocateProducerIdsRequest(version).HeaderVersion;
			if (AlterClientQuotasRequest.ApiKey == apiKey)
				return new AlterClientQuotasRequest(version).HeaderVersion;
			if (AlterConfigsRequest.ApiKey == apiKey)
				return new AlterConfigsRequest(version).HeaderVersion;
			if (AlterPartitionReassignmentsRequest.ApiKey == apiKey)
				return new AlterPartitionReassignmentsRequest(version).HeaderVersion;
			if (AlterPartitionRequest.ApiKey == apiKey)
				return new AlterPartitionRequest(version).HeaderVersion;
			if (AlterReplicaLogDirsRequest.ApiKey == apiKey)
				return new AlterReplicaLogDirsRequest(version).HeaderVersion;
			if (AlterUserScramCredentialsRequest.ApiKey == apiKey)
				return new AlterUserScramCredentialsRequest(version).HeaderVersion;
			if (ApiVersionsRequest.ApiKey == apiKey)
				return new ApiVersionsRequest(version).HeaderVersion;
			if (AssignReplicasToDirsRequest.ApiKey == apiKey)
				return new AssignReplicasToDirsRequest(version).HeaderVersion;
			if (BeginQuorumEpochRequest.ApiKey == apiKey)
				return new BeginQuorumEpochRequest(version).HeaderVersion;
			if (BrokerHeartbeatRequest.ApiKey == apiKey)
				return new BrokerHeartbeatRequest(version).HeaderVersion;
			if (BrokerRegistrationRequest.ApiKey == apiKey)
				return new BrokerRegistrationRequest(version).HeaderVersion;
			if (ConsumerGroupDescribeRequest.ApiKey == apiKey)
				return new ConsumerGroupDescribeRequest(version).HeaderVersion;
			if (ConsumerGroupHeartbeatRequest.ApiKey == apiKey)
				return new ConsumerGroupHeartbeatRequest(version).HeaderVersion;
			if (ControlledShutdownRequest.ApiKey == apiKey)
				return new ControlledShutdownRequest(version).HeaderVersion;
			if (ControllerRegistrationRequest.ApiKey == apiKey)
				return new ControllerRegistrationRequest(version).HeaderVersion;
			if (CreateAclsRequest.ApiKey == apiKey)
				return new CreateAclsRequest(version).HeaderVersion;
			if (CreateDelegationTokenRequest.ApiKey == apiKey)
				return new CreateDelegationTokenRequest(version).HeaderVersion;
			if (CreatePartitionsRequest.ApiKey == apiKey)
				return new CreatePartitionsRequest(version).HeaderVersion;
			if (CreateTopicsRequest.ApiKey == apiKey)
				return new CreateTopicsRequest(version).HeaderVersion;
			if (DeleteAclsRequest.ApiKey == apiKey)
				return new DeleteAclsRequest(version).HeaderVersion;
			if (DeleteGroupsRequest.ApiKey == apiKey)
				return new DeleteGroupsRequest(version).HeaderVersion;
			if (DeleteRecordsRequest.ApiKey == apiKey)
				return new DeleteRecordsRequest(version).HeaderVersion;
			if (DeleteShareGroupStateRequest.ApiKey == apiKey)
				return new DeleteShareGroupStateRequest(version).HeaderVersion;
			if (DeleteTopicsRequest.ApiKey == apiKey)
				return new DeleteTopicsRequest(version).HeaderVersion;
			if (DescribeAclsRequest.ApiKey == apiKey)
				return new DescribeAclsRequest(version).HeaderVersion;
			if (DescribeClientQuotasRequest.ApiKey == apiKey)
				return new DescribeClientQuotasRequest(version).HeaderVersion;
			if (DescribeClusterRequest.ApiKey == apiKey)
				return new DescribeClusterRequest(version).HeaderVersion;
			if (DescribeConfigsRequest.ApiKey == apiKey)
				return new DescribeConfigsRequest(version).HeaderVersion;
			if (DescribeDelegationTokenRequest.ApiKey == apiKey)
				return new DescribeDelegationTokenRequest(version).HeaderVersion;
			if (DescribeGroupsRequest.ApiKey == apiKey)
				return new DescribeGroupsRequest(version).HeaderVersion;
			if (DescribeLogDirsRequest.ApiKey == apiKey)
				return new DescribeLogDirsRequest(version).HeaderVersion;
			if (DescribeProducersRequest.ApiKey == apiKey)
				return new DescribeProducersRequest(version).HeaderVersion;
			if (DescribeQuorumRequest.ApiKey == apiKey)
				return new DescribeQuorumRequest(version).HeaderVersion;
			if (DescribeTopicPartitionsRequest.ApiKey == apiKey)
				return new DescribeTopicPartitionsRequest(version).HeaderVersion;
			if (DescribeTransactionsRequest.ApiKey == apiKey)
				return new DescribeTransactionsRequest(version).HeaderVersion;
			if (DescribeUserScramCredentialsRequest.ApiKey == apiKey)
				return new DescribeUserScramCredentialsRequest(version).HeaderVersion;
			if (ElectLeadersRequest.ApiKey == apiKey)
				return new ElectLeadersRequest(version).HeaderVersion;
			if (EndQuorumEpochRequest.ApiKey == apiKey)
				return new EndQuorumEpochRequest(version).HeaderVersion;
			if (EndTxnRequest.ApiKey == apiKey)
				return new EndTxnRequest(version).HeaderVersion;
			if (EnvelopeRequest.ApiKey == apiKey)
				return new EnvelopeRequest(version).HeaderVersion;
			if (ExpireDelegationTokenRequest.ApiKey == apiKey)
				return new ExpireDelegationTokenRequest(version).HeaderVersion;
			if (FetchRequest.ApiKey == apiKey)
				return new FetchRequest(version).HeaderVersion;
			if (FetchSnapshotRequest.ApiKey == apiKey)
				return new FetchSnapshotRequest(version).HeaderVersion;
			if (FindCoordinatorRequest.ApiKey == apiKey)
				return new FindCoordinatorRequest(version).HeaderVersion;
			if (GetTelemetrySubscriptionsRequest.ApiKey == apiKey)
				return new GetTelemetrySubscriptionsRequest(version).HeaderVersion;
			if (HeartbeatRequest.ApiKey == apiKey)
				return new HeartbeatRequest(version).HeaderVersion;
			if (IncrementalAlterConfigsRequest.ApiKey == apiKey)
				return new IncrementalAlterConfigsRequest(version).HeaderVersion;
			if (InitializeShareGroupStateRequest.ApiKey == apiKey)
				return new InitializeShareGroupStateRequest(version).HeaderVersion;
			if (InitProducerIdRequest.ApiKey == apiKey)
				return new InitProducerIdRequest(version).HeaderVersion;
			if (JoinGroupRequest.ApiKey == apiKey)
				return new JoinGroupRequest(version).HeaderVersion;
			if (LeaderAndIsrRequest.ApiKey == apiKey)
				return new LeaderAndIsrRequest(version).HeaderVersion;
			if (LeaveGroupRequest.ApiKey == apiKey)
				return new LeaveGroupRequest(version).HeaderVersion;
			if (ListClientMetricsResourcesRequest.ApiKey == apiKey)
				return new ListClientMetricsResourcesRequest(version).HeaderVersion;
			if (ListGroupsRequest.ApiKey == apiKey)
				return new ListGroupsRequest(version).HeaderVersion;
			if (ListOffsetsRequest.ApiKey == apiKey)
				return new ListOffsetsRequest(version).HeaderVersion;
			if (ListPartitionReassignmentsRequest.ApiKey == apiKey)
				return new ListPartitionReassignmentsRequest(version).HeaderVersion;
			if (ListTransactionsRequest.ApiKey == apiKey)
				return new ListTransactionsRequest(version).HeaderVersion;
			if (MetadataRequest.ApiKey == apiKey)
				return new MetadataRequest(version).HeaderVersion;
			if (OffsetCommitRequest.ApiKey == apiKey)
				return new OffsetCommitRequest(version).HeaderVersion;
			if (OffsetDeleteRequest.ApiKey == apiKey)
				return new OffsetDeleteRequest(version).HeaderVersion;
			if (OffsetFetchRequest.ApiKey == apiKey)
				return new OffsetFetchRequest(version).HeaderVersion;
			if (OffsetForLeaderEpochRequest.ApiKey == apiKey)
				return new OffsetForLeaderEpochRequest(version).HeaderVersion;
			if (ProduceRequest.ApiKey == apiKey)
				return new ProduceRequest(version).HeaderVersion;
			if (PushTelemetryRequest.ApiKey == apiKey)
				return new PushTelemetryRequest(version).HeaderVersion;
			if (ReadShareGroupStateRequest.ApiKey == apiKey)
				return new ReadShareGroupStateRequest(version).HeaderVersion;
			if (ReadShareGroupStateSummaryRequest.ApiKey == apiKey)
				return new ReadShareGroupStateSummaryRequest(version).HeaderVersion;
			if (RemoveRaftVoterRequest.ApiKey == apiKey)
				return new RemoveRaftVoterRequest(version).HeaderVersion;
			if (RenewDelegationTokenRequest.ApiKey == apiKey)
				return new RenewDelegationTokenRequest(version).HeaderVersion;
			if (SaslAuthenticateRequest.ApiKey == apiKey)
				return new SaslAuthenticateRequest(version).HeaderVersion;
			if (SaslHandshakeRequest.ApiKey == apiKey)
				return new SaslHandshakeRequest(version).HeaderVersion;
			if (ShareAcknowledgeRequest.ApiKey == apiKey)
				return new ShareAcknowledgeRequest(version).HeaderVersion;
			if (ShareFetchRequest.ApiKey == apiKey)
				return new ShareFetchRequest(version).HeaderVersion;
			if (ShareGroupDescribeRequest.ApiKey == apiKey)
				return new ShareGroupDescribeRequest(version).HeaderVersion;
			if (ShareGroupHeartbeatRequest.ApiKey == apiKey)
				return new ShareGroupHeartbeatRequest(version).HeaderVersion;
			if (StopReplicaRequest.ApiKey == apiKey)
				return new StopReplicaRequest(version).HeaderVersion;
			if (SyncGroupRequest.ApiKey == apiKey)
				return new SyncGroupRequest(version).HeaderVersion;
			if (TxnOffsetCommitRequest.ApiKey == apiKey)
				return new TxnOffsetCommitRequest(version).HeaderVersion;
			if (UnregisterBrokerRequest.ApiKey == apiKey)
				return new UnregisterBrokerRequest(version).HeaderVersion;
			if (UpdateFeaturesRequest.ApiKey == apiKey)
				return new UpdateFeaturesRequest(version).HeaderVersion;
			if (UpdateMetadataRequest.ApiKey == apiKey)
				return new UpdateMetadataRequest(version).HeaderVersion;
			if (UpdateRaftVoterRequest.ApiKey == apiKey)
				return new UpdateRaftVoterRequest(version).HeaderVersion;
			if (VoteRequest.ApiKey == apiKey)
				return new VoteRequest(version).HeaderVersion;
			if (WriteShareGroupStateRequest.ApiKey == apiKey)
				return new WriteShareGroupStateRequest(version).HeaderVersion;
			if (WriteTxnMarkersRequest.ApiKey == apiKey)
				return new WriteTxnMarkersRequest(version).HeaderVersion;
			throw new ArgumentException($"There is no request message with api key {apiKey}");
		}

		public static Int16 GetResponseHeaderVersionFor(RequestPayload payload)
		{
			var apiKey = payload.Message.ApiMessageKey;
			if (AddOffsetsToTxnResponse.ApiKey == apiKey)
				return new AddOffsetsToTxnResponse(payload.Message.Version).HeaderVersion;
			if (AddPartitionsToTxnResponse.ApiKey == apiKey)
				return new AddPartitionsToTxnResponse(payload.Message.Version).HeaderVersion;
			if (AddRaftVoterResponse.ApiKey == apiKey)
				return new AddRaftVoterResponse(payload.Message.Version).HeaderVersion;
			if (AllocateProducerIdsResponse.ApiKey == apiKey)
				return new AllocateProducerIdsResponse(payload.Message.Version).HeaderVersion;
			if (AlterClientQuotasResponse.ApiKey == apiKey)
				return new AlterClientQuotasResponse(payload.Message.Version).HeaderVersion;
			if (AlterConfigsResponse.ApiKey == apiKey)
				return new AlterConfigsResponse(payload.Message.Version).HeaderVersion;
			if (AlterPartitionReassignmentsResponse.ApiKey == apiKey)
				return new AlterPartitionReassignmentsResponse(payload.Message.Version).HeaderVersion;
			if (AlterPartitionResponse.ApiKey == apiKey)
				return new AlterPartitionResponse(payload.Message.Version).HeaderVersion;
			if (AlterReplicaLogDirsResponse.ApiKey == apiKey)
				return new AlterReplicaLogDirsResponse(payload.Message.Version).HeaderVersion;
			if (AlterUserScramCredentialsResponse.ApiKey == apiKey)
				return new AlterUserScramCredentialsResponse(payload.Message.Version).HeaderVersion;
			if (ApiVersionsResponse.ApiKey == apiKey)
				return new ApiVersionsResponse(payload.Message.Version).HeaderVersion;
			if (AssignReplicasToDirsResponse.ApiKey == apiKey)
				return new AssignReplicasToDirsResponse(payload.Message.Version).HeaderVersion;
			if (BeginQuorumEpochResponse.ApiKey == apiKey)
				return new BeginQuorumEpochResponse(payload.Message.Version).HeaderVersion;
			if (BrokerHeartbeatResponse.ApiKey == apiKey)
				return new BrokerHeartbeatResponse(payload.Message.Version).HeaderVersion;
			if (BrokerRegistrationResponse.ApiKey == apiKey)
				return new BrokerRegistrationResponse(payload.Message.Version).HeaderVersion;
			if (ConsumerGroupDescribeResponse.ApiKey == apiKey)
				return new ConsumerGroupDescribeResponse(payload.Message.Version).HeaderVersion;
			if (ConsumerGroupHeartbeatResponse.ApiKey == apiKey)
				return new ConsumerGroupHeartbeatResponse(payload.Message.Version).HeaderVersion;
			if (ControlledShutdownResponse.ApiKey == apiKey)
				return new ControlledShutdownResponse(payload.Message.Version).HeaderVersion;
			if (ControllerRegistrationResponse.ApiKey == apiKey)
				return new ControllerRegistrationResponse(payload.Message.Version).HeaderVersion;
			if (CreateAclsResponse.ApiKey == apiKey)
				return new CreateAclsResponse(payload.Message.Version).HeaderVersion;
			if (CreateDelegationTokenResponse.ApiKey == apiKey)
				return new CreateDelegationTokenResponse(payload.Message.Version).HeaderVersion;
			if (CreatePartitionsResponse.ApiKey == apiKey)
				return new CreatePartitionsResponse(payload.Message.Version).HeaderVersion;
			if (CreateTopicsResponse.ApiKey == apiKey)
				return new CreateTopicsResponse(payload.Message.Version).HeaderVersion;
			if (DeleteAclsResponse.ApiKey == apiKey)
				return new DeleteAclsResponse(payload.Message.Version).HeaderVersion;
			if (DeleteGroupsResponse.ApiKey == apiKey)
				return new DeleteGroupsResponse(payload.Message.Version).HeaderVersion;
			if (DeleteRecordsResponse.ApiKey == apiKey)
				return new DeleteRecordsResponse(payload.Message.Version).HeaderVersion;
			if (DeleteShareGroupStateResponse.ApiKey == apiKey)
				return new DeleteShareGroupStateResponse(payload.Message.Version).HeaderVersion;
			if (DeleteTopicsResponse.ApiKey == apiKey)
				return new DeleteTopicsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeAclsResponse.ApiKey == apiKey)
				return new DescribeAclsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeClientQuotasResponse.ApiKey == apiKey)
				return new DescribeClientQuotasResponse(payload.Message.Version).HeaderVersion;
			if (DescribeClusterResponse.ApiKey == apiKey)
				return new DescribeClusterResponse(payload.Message.Version).HeaderVersion;
			if (DescribeConfigsResponse.ApiKey == apiKey)
				return new DescribeConfigsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeDelegationTokenResponse.ApiKey == apiKey)
				return new DescribeDelegationTokenResponse(payload.Message.Version).HeaderVersion;
			if (DescribeGroupsResponse.ApiKey == apiKey)
				return new DescribeGroupsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeLogDirsResponse.ApiKey == apiKey)
				return new DescribeLogDirsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeProducersResponse.ApiKey == apiKey)
				return new DescribeProducersResponse(payload.Message.Version).HeaderVersion;
			if (DescribeQuorumResponse.ApiKey == apiKey)
				return new DescribeQuorumResponse(payload.Message.Version).HeaderVersion;
			if (DescribeTopicPartitionsResponse.ApiKey == apiKey)
				return new DescribeTopicPartitionsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeTransactionsResponse.ApiKey == apiKey)
				return new DescribeTransactionsResponse(payload.Message.Version).HeaderVersion;
			if (DescribeUserScramCredentialsResponse.ApiKey == apiKey)
				return new DescribeUserScramCredentialsResponse(payload.Message.Version).HeaderVersion;
			if (ElectLeadersResponse.ApiKey == apiKey)
				return new ElectLeadersResponse(payload.Message.Version).HeaderVersion;
			if (EndQuorumEpochResponse.ApiKey == apiKey)
				return new EndQuorumEpochResponse(payload.Message.Version).HeaderVersion;
			if (EndTxnResponse.ApiKey == apiKey)
				return new EndTxnResponse(payload.Message.Version).HeaderVersion;
			if (EnvelopeResponse.ApiKey == apiKey)
				return new EnvelopeResponse(payload.Message.Version).HeaderVersion;
			if (ExpireDelegationTokenResponse.ApiKey == apiKey)
				return new ExpireDelegationTokenResponse(payload.Message.Version).HeaderVersion;
			if (FetchResponse.ApiKey == apiKey)
				return new FetchResponse(payload.Message.Version).HeaderVersion;
			if (FetchSnapshotResponse.ApiKey == apiKey)
				return new FetchSnapshotResponse(payload.Message.Version).HeaderVersion;
			if (FindCoordinatorResponse.ApiKey == apiKey)
				return new FindCoordinatorResponse(payload.Message.Version).HeaderVersion;
			if (GetTelemetrySubscriptionsResponse.ApiKey == apiKey)
				return new GetTelemetrySubscriptionsResponse(payload.Message.Version).HeaderVersion;
			if (HeartbeatResponse.ApiKey == apiKey)
				return new HeartbeatResponse(payload.Message.Version).HeaderVersion;
			if (IncrementalAlterConfigsResponse.ApiKey == apiKey)
				return new IncrementalAlterConfigsResponse(payload.Message.Version).HeaderVersion;
			if (InitializeShareGroupStateResponse.ApiKey == apiKey)
				return new InitializeShareGroupStateResponse(payload.Message.Version).HeaderVersion;
			if (InitProducerIdResponse.ApiKey == apiKey)
				return new InitProducerIdResponse(payload.Message.Version).HeaderVersion;
			if (JoinGroupResponse.ApiKey == apiKey)
				return new JoinGroupResponse(payload.Message.Version).HeaderVersion;
			if (LeaderAndIsrResponse.ApiKey == apiKey)
				return new LeaderAndIsrResponse(payload.Message.Version).HeaderVersion;
			if (LeaveGroupResponse.ApiKey == apiKey)
				return new LeaveGroupResponse(payload.Message.Version).HeaderVersion;
			if (ListClientMetricsResourcesResponse.ApiKey == apiKey)
				return new ListClientMetricsResourcesResponse(payload.Message.Version).HeaderVersion;
			if (ListGroupsResponse.ApiKey == apiKey)
				return new ListGroupsResponse(payload.Message.Version).HeaderVersion;
			if (ListOffsetsResponse.ApiKey == apiKey)
				return new ListOffsetsResponse(payload.Message.Version).HeaderVersion;
			if (ListPartitionReassignmentsResponse.ApiKey == apiKey)
				return new ListPartitionReassignmentsResponse(payload.Message.Version).HeaderVersion;
			if (ListTransactionsResponse.ApiKey == apiKey)
				return new ListTransactionsResponse(payload.Message.Version).HeaderVersion;
			if (MetadataResponse.ApiKey == apiKey)
				return new MetadataResponse(payload.Message.Version).HeaderVersion;
			if (OffsetCommitResponse.ApiKey == apiKey)
				return new OffsetCommitResponse(payload.Message.Version).HeaderVersion;
			if (OffsetDeleteResponse.ApiKey == apiKey)
				return new OffsetDeleteResponse(payload.Message.Version).HeaderVersion;
			if (OffsetFetchResponse.ApiKey == apiKey)
				return new OffsetFetchResponse(payload.Message.Version).HeaderVersion;
			if (OffsetForLeaderEpochResponse.ApiKey == apiKey)
				return new OffsetForLeaderEpochResponse(payload.Message.Version).HeaderVersion;
			if (ProduceResponse.ApiKey == apiKey)
				return new ProduceResponse(payload.Message.Version).HeaderVersion;
			if (PushTelemetryResponse.ApiKey == apiKey)
				return new PushTelemetryResponse(payload.Message.Version).HeaderVersion;
			if (ReadShareGroupStateResponse.ApiKey == apiKey)
				return new ReadShareGroupStateResponse(payload.Message.Version).HeaderVersion;
			if (ReadShareGroupStateSummaryResponse.ApiKey == apiKey)
				return new ReadShareGroupStateSummaryResponse(payload.Message.Version).HeaderVersion;
			if (RemoveRaftVoterResponse.ApiKey == apiKey)
				return new RemoveRaftVoterResponse(payload.Message.Version).HeaderVersion;
			if (RenewDelegationTokenResponse.ApiKey == apiKey)
				return new RenewDelegationTokenResponse(payload.Message.Version).HeaderVersion;
			if (SaslAuthenticateResponse.ApiKey == apiKey)
				return new SaslAuthenticateResponse(payload.Message.Version).HeaderVersion;
			if (SaslHandshakeResponse.ApiKey == apiKey)
				return new SaslHandshakeResponse(payload.Message.Version).HeaderVersion;
			if (ShareAcknowledgeResponse.ApiKey == apiKey)
				return new ShareAcknowledgeResponse(payload.Message.Version).HeaderVersion;
			if (ShareFetchResponse.ApiKey == apiKey)
				return new ShareFetchResponse(payload.Message.Version).HeaderVersion;
			if (ShareGroupDescribeResponse.ApiKey == apiKey)
				return new ShareGroupDescribeResponse(payload.Message.Version).HeaderVersion;
			if (ShareGroupHeartbeatResponse.ApiKey == apiKey)
				return new ShareGroupHeartbeatResponse(payload.Message.Version).HeaderVersion;
			if (StopReplicaResponse.ApiKey == apiKey)
				return new StopReplicaResponse(payload.Message.Version).HeaderVersion;
			if (SyncGroupResponse.ApiKey == apiKey)
				return new SyncGroupResponse(payload.Message.Version).HeaderVersion;
			if (TxnOffsetCommitResponse.ApiKey == apiKey)
				return new TxnOffsetCommitResponse(payload.Message.Version).HeaderVersion;
			if (UnregisterBrokerResponse.ApiKey == apiKey)
				return new UnregisterBrokerResponse(payload.Message.Version).HeaderVersion;
			if (UpdateFeaturesResponse.ApiKey == apiKey)
				return new UpdateFeaturesResponse(payload.Message.Version).HeaderVersion;
			if (UpdateMetadataResponse.ApiKey == apiKey)
				return new UpdateMetadataResponse(payload.Message.Version).HeaderVersion;
			if (UpdateRaftVoterResponse.ApiKey == apiKey)
				return new UpdateRaftVoterResponse(payload.Message.Version).HeaderVersion;
			if (VoteResponse.ApiKey == apiKey)
				return new VoteResponse(payload.Message.Version).HeaderVersion;
			if (WriteShareGroupStateResponse.ApiKey == apiKey)
				return new WriteShareGroupStateResponse(payload.Message.Version).HeaderVersion;
			if (WriteTxnMarkersResponse.ApiKey == apiKey)
				return new WriteTxnMarkersResponse(payload.Message.Version).HeaderVersion;
			throw new ArgumentException($"There is no response message with api key {apiKey}");
		}
	}

	public class RequestHeader
	{
		public RequestHeader(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"RequestHeader does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_requestApiKey.GetSize(IsFlexibleVersion) +
			_requestApiVersion.GetSize(IsFlexibleVersion) +
			_correlationId.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_clientId.GetSize(false):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<RequestHeader> FromReaderAsync(PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RequestHeader(MinVersion);
			instance.RequestApiKey = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RequestApiVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			instance = new RequestHeader(Messages.GetRequestHeaderVersionFor(instance.RequestApiKey, instance.RequestApiVersion))
			{
				RequestApiKey = instance.RequestApiKey, 
				RequestApiVersion = instance.RequestApiVersion
			};

			instance.CorrelationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ClientId = await NullableString.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RequestHeader is unknown");
					}
				}
			}

			return instance;
		}

		internal async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _requestApiKey.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _requestApiVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _correlationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _clientId.WriteToAsync(writer, false, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _requestApiKey = Int16.Default;
		/// <summary>
		/// <para>The API key of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 RequestApiKey 
		{
			get => _requestApiKey;
			private set 
			{
				_requestApiKey = value;
			}
		}

		/// <summary>
		/// <para>The API key of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RequestHeader WithRequestApiKey(Int16 requestApiKey)
		{
			RequestApiKey = requestApiKey;
			return this;
		}

		private Int16 _requestApiVersion = Int16.Default;
		/// <summary>
		/// <para>The API version of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 RequestApiVersion 
		{
			get => _requestApiVersion;
			private set 
			{
				_requestApiVersion = value;
			}
		}

		/// <summary>
		/// <para>The API version of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RequestHeader WithRequestApiVersion(Int16 requestApiVersion)
		{
			RequestApiVersion = requestApiVersion;
			return this;
		}

		private Int32 _correlationId = Int32.Default;
		/// <summary>
		/// <para>The correlation ID of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 CorrelationId 
		{
			get => _correlationId;
			private set 
			{
				_correlationId = value;
			}
		}

		/// <summary>
		/// <para>The correlation ID of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RequestHeader WithCorrelationId(Int32 correlationId)
		{
			CorrelationId = correlationId;
			return this;
		}

		private NullableString _clientId = NullableString.Default;
		/// <summary>
		/// <para>The client ID string.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public String? ClientId 
		{
			get => _clientId;
			private set 
			{
				if (Version >= 1 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ClientId does not support null for version {Version}. Supported versions for null value: 1+");

				_clientId = value;
			}
		}

		/// <summary>
		/// <para>The client ID string.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public RequestHeader WithClientId(String? clientId)
		{
			ClientId = clientId;
			return this;
		}
	}

	public class ResponseHeader
	{
		public ResponseHeader(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ResponseHeader does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_correlationId.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ResponseHeader> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ResponseHeader(version);
			instance.CorrelationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ResponseHeader is unknown");
					}
				}
			}

			return instance;
		}

		internal async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _correlationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _correlationId = Int32.Default;
		/// <summary>
		/// <para>The correlation ID of this response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 CorrelationId 
		{
			get => _correlationId;
			private set 
			{
				_correlationId = value;
			}
		}

		/// <summary>
		/// <para>The correlation ID of this response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ResponseHeader WithCorrelationId(Int32 correlationId)
		{
			CorrelationId = correlationId;
			return this;
		}
	}

	public class AddOffsetsToTxnRequest : Message, IRespond<AddOffsetsToTxnResponse>
	{
		public AddOffsetsToTxnRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AddOffsetsToTxnRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(25);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_transactionalId.GetSize(IsFlexibleVersion) +
			_producerId.GetSize(IsFlexibleVersion) +
			_producerEpoch.GetSize(IsFlexibleVersion) +
			_groupId.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AddOffsetsToTxnRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddOffsetsToTxnRequest(version);
			instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddOffsetsToTxnRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			private set 
			{
				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			private set 
			{
				_producerId = value;
			}
		}

		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			private set 
			{
				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		public AddOffsetsToTxnResponse Respond()
			=> new AddOffsetsToTxnResponse(Version);
	}

	public class AddOffsetsToTxnResponse : Message
	{
		public AddOffsetsToTxnResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AddOffsetsToTxnResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(25);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AddOffsetsToTxnResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddOffsetsToTxnResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddOffsetsToTxnResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The response error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The response error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class AddPartitionsToTxnRequest : Message, IRespond<AddPartitionsToTxnResponse>
	{
		public AddPartitionsToTxnRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AddPartitionsToTxnRequest does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(24);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 4 ? 
				_transactionsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_v3AndBelowTransactionalId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_v3AndBelowProducerId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_v3AndBelowProducerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_v3AndBelowTopicsCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AddPartitionsToTxnRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddPartitionsToTxnRequest(version);
			if (instance.Version >= 4) 
				instance.TransactionsCollection = await Map<String, AddPartitionsToTxnTransaction>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTransaction.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.TransactionalId, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.V3AndBelowTransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.V3AndBelowProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.V3AndBelowProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.V3AndBelowTopicsCollection = await Array<AddPartitionsToTxnTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 4)
				await _transactionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _v3AndBelowTransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _v3AndBelowProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _v3AndBelowProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _v3AndBelowTopicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<String, AddPartitionsToTxnTransaction> _transactionsCollection = Map<String, AddPartitionsToTxnTransaction>.Default;
		/// <summary>
		/// <para>List of transactions to add partitions to.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Map<String, AddPartitionsToTxnTransaction> TransactionsCollection 
		{
			get => _transactionsCollection;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"TransactionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_transactionsCollection = value;
			}
		}

		/// <summary>
		/// <para>List of transactions to add partitions to.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithTransactionsCollection(params Func<AddPartitionsToTxnTransaction, AddPartitionsToTxnTransaction>[] createFields)
		{
			TransactionsCollection = createFields
				.Select(createField => createField(new AddPartitionsToTxnTransaction(Version)))
				.ToDictionary(field => field.TransactionalId);
			return this;
		}

		public delegate AddPartitionsToTxnTransaction CreateAddPartitionsToTxnTransaction(AddPartitionsToTxnTransaction field);

		/// <summary>
		/// <para>List of transactions to add partitions to.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithTransactionsCollection(IEnumerable<CreateAddPartitionsToTxnTransaction> createFields)
		{
			TransactionsCollection = createFields
				.Select(createField => createField(new AddPartitionsToTxnTransaction(Version)))
				.ToDictionary(field => field.TransactionalId);
			return this;
		}

		public class AddPartitionsToTxnTransaction : ISerialize
		{
			internal AddPartitionsToTxnTransaction(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 4 ? 
					_transactionalId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_producerId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_producerEpoch.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_verifyOnly.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_topicsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AddPartitionsToTxnTransaction> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnTransaction(version);
				if (instance.Version >= 4) 
					instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.VerifyOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.TopicsCollection = await Array<AddPartitionsToTxnTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnTransaction is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 4)
					await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _verifyOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _transactionalId = String.Default;
			/// <summary>
			/// <para>The transactional id corresponding to the transaction.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String TransactionalId 
			{
				get => _transactionalId;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_transactionalId = value;
				}
			}

			/// <summary>
			/// <para>The transactional id corresponding to the transaction.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public AddPartitionsToTxnTransaction WithTransactionalId(String transactionalId)
			{
				TransactionalId = transactionalId;
				return this;
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>Current producer id in use by the transactional id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_producerId = value;
				}
			}

			/// <summary>
			/// <para>Current producer id in use by the transactional id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public AddPartitionsToTxnTransaction WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private Int16 _producerEpoch = Int16.Default;
			/// <summary>
			/// <para>Current epoch associated with the producer id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int16 ProducerEpoch 
			{
				get => _producerEpoch;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_producerEpoch = value;
				}
			}

			/// <summary>
			/// <para>Current epoch associated with the producer id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public AddPartitionsToTxnTransaction WithProducerEpoch(Int16 producerEpoch)
			{
				ProducerEpoch = producerEpoch;
				return this;
			}

			private Boolean _verifyOnly = new Boolean(false);
			/// <summary>
			/// <para>Boolean to signify if we want to check if the partition is in the transaction rather than add it.</para>
			/// <para>Versions: 4+</para>
			/// <para>Default: false</para>
			/// </summary>
			public Boolean VerifyOnly 
			{
				get => _verifyOnly;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"VerifyOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_verifyOnly = value;
				}
			}

			/// <summary>
			/// <para>Boolean to signify if we want to check if the partition is in the transaction rather than add it.</para>
			/// <para>Versions: 4+</para>
			/// <para>Default: false</para>
			/// </summary>
			public AddPartitionsToTxnTransaction WithVerifyOnly(Boolean verifyOnly)
			{
				VerifyOnly = verifyOnly;
				return this;
			}

			private Array<AddPartitionsToTxnTopic> _topicsCollection = Array.Empty<AddPartitionsToTxnTopic>();
			/// <summary>
			/// <para>The partitions to add to the transaction.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Array<AddPartitionsToTxnTopic> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to add to the transaction.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public AddPartitionsToTxnTransaction WithTopicsCollection(Array<AddPartitionsToTxnTopic> topicsCollection)
			{
				TopicsCollection = topicsCollection;
				return this;
			}
		}

		private String _v3AndBelowTransactionalId = String.Default;
		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public String V3AndBelowTransactionalId 
		{
			get => _v3AndBelowTransactionalId;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"V3AndBelowTransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_v3AndBelowTransactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithV3AndBelowTransactionalId(String v3AndBelowTransactionalId)
		{
			V3AndBelowTransactionalId = v3AndBelowTransactionalId;
			return this;
		}

		private Int64 _v3AndBelowProducerId = Int64.Default;
		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int64 V3AndBelowProducerId 
		{
			get => _v3AndBelowProducerId;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"V3AndBelowProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_v3AndBelowProducerId = value;
			}
		}

		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithV3AndBelowProducerId(Int64 v3AndBelowProducerId)
		{
			V3AndBelowProducerId = v3AndBelowProducerId;
			return this;
		}

		private Int16 _v3AndBelowProducerEpoch = Int16.Default;
		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int16 V3AndBelowProducerEpoch 
		{
			get => _v3AndBelowProducerEpoch;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"V3AndBelowProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_v3AndBelowProducerEpoch = value;
			}
		}

		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithV3AndBelowProducerEpoch(Int16 v3AndBelowProducerEpoch)
		{
			V3AndBelowProducerEpoch = v3AndBelowProducerEpoch;
			return this;
		}

		private Array<AddPartitionsToTxnTopic> _v3AndBelowTopicsCollection = Array.Empty<AddPartitionsToTxnTopic>();
		/// <summary>
		/// <para>The partitions to add to the transaction.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Array<AddPartitionsToTxnTopic> V3AndBelowTopicsCollection 
		{
			get => _v3AndBelowTopicsCollection;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"V3AndBelowTopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_v3AndBelowTopicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions to add to the transaction.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithV3AndBelowTopicsCollection(Array<AddPartitionsToTxnTopic> v3AndBelowTopicsCollection)
		{
			V3AndBelowTopicsCollection = v3AndBelowTopicsCollection;
			return this;
		}

		public class AddPartitionsToTxnTopic : ISerialize
		{
			internal AddPartitionsToTxnTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AddPartitionsToTxnTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes to add to the transaction</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes to add to the transaction</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopic WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public AddPartitionsToTxnResponse Respond()
			=> new AddPartitionsToTxnResponse(Version);
	}

	public class AddPartitionsToTxnResponse : Message
	{
		public AddPartitionsToTxnResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AddPartitionsToTxnResponse does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(24);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(Version >= 4 ? 
				_errorCode.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 4 ? 
				_resultsByTransactionCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_resultsByTopicV3AndBelowCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AddPartitionsToTxnResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddPartitionsToTxnResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.ResultsByTransactionCollection = await Map<String, AddPartitionsToTxnResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.TransactionalId, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.ResultsByTopicV3AndBelowCollection = await Array<AddPartitionsToTxnTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _resultsByTransactionCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _resultsByTopicV3AndBelowCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The response top level error code.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The response top level error code.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Map<String, AddPartitionsToTxnResult> _resultsByTransactionCollection = Map<String, AddPartitionsToTxnResult>.Default;
		/// <summary>
		/// <para>Results categorized by transactional ID.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Map<String, AddPartitionsToTxnResult> ResultsByTransactionCollection 
		{
			get => _resultsByTransactionCollection;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"ResultsByTransactionCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_resultsByTransactionCollection = value;
			}
		}

		/// <summary>
		/// <para>Results categorized by transactional ID.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithResultsByTransactionCollection(params Func<AddPartitionsToTxnResult, AddPartitionsToTxnResult>[] createFields)
		{
			ResultsByTransactionCollection = createFields
				.Select(createField => createField(new AddPartitionsToTxnResult(Version)))
				.ToDictionary(field => field.TransactionalId);
			return this;
		}

		public delegate AddPartitionsToTxnResult CreateAddPartitionsToTxnResult(AddPartitionsToTxnResult field);

		/// <summary>
		/// <para>Results categorized by transactional ID.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithResultsByTransactionCollection(IEnumerable<CreateAddPartitionsToTxnResult> createFields)
		{
			ResultsByTransactionCollection = createFields
				.Select(createField => createField(new AddPartitionsToTxnResult(Version)))
				.ToDictionary(field => field.TransactionalId);
			return this;
		}

		public class AddPartitionsToTxnResult : ISerialize
		{
			internal AddPartitionsToTxnResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 4 ? 
					_transactionalId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_topicResultsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AddPartitionsToTxnResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnResult(version);
				if (instance.Version >= 4) 
					instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.TopicResultsCollection = await Array<AddPartitionsToTxnTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 4)
					await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _topicResultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _transactionalId = String.Default;
			/// <summary>
			/// <para>The transactional id corresponding to the transaction.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String TransactionalId 
			{
				get => _transactionalId;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_transactionalId = value;
				}
			}

			/// <summary>
			/// <para>The transactional id corresponding to the transaction.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public AddPartitionsToTxnResult WithTransactionalId(String transactionalId)
			{
				TransactionalId = transactionalId;
				return this;
			}

			private Array<AddPartitionsToTxnTopicResult> _topicResultsCollection = Array.Empty<AddPartitionsToTxnTopicResult>();
			/// <summary>
			/// <para>The results for each topic.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Array<AddPartitionsToTxnTopicResult> TopicResultsCollection 
			{
				get => _topicResultsCollection;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"TopicResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_topicResultsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each topic.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public AddPartitionsToTxnResult WithTopicResultsCollection(Array<AddPartitionsToTxnTopicResult> topicResultsCollection)
			{
				TopicResultsCollection = topicResultsCollection;
				return this;
			}
		}

		private Array<AddPartitionsToTxnTopicResult> _resultsByTopicV3AndBelowCollection = Array.Empty<AddPartitionsToTxnTopicResult>();
		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Array<AddPartitionsToTxnTopicResult> ResultsByTopicV3AndBelowCollection 
		{
			get => _resultsByTopicV3AndBelowCollection;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"ResultsByTopicV3AndBelowCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_resultsByTopicV3AndBelowCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithResultsByTopicV3AndBelowCollection(Array<AddPartitionsToTxnTopicResult> resultsByTopicV3AndBelowCollection)
		{
			ResultsByTopicV3AndBelowCollection = resultsByTopicV3AndBelowCollection;
			return this;
		}

		public class AddPartitionsToTxnTopicResult : ISerialize
		{
			internal AddPartitionsToTxnTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_resultsByPartitionCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AddPartitionsToTxnTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnTopicResult(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResultsByPartitionCollection = await Array<AddPartitionsToTxnPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resultsByPartitionCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<AddPartitionsToTxnPartitionResult> _resultsByPartitionCollection = Array.Empty<AddPartitionsToTxnPartitionResult>();
			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<AddPartitionsToTxnPartitionResult> ResultsByPartitionCollection 
			{
				get => _resultsByPartitionCollection;
				private set 
				{
					_resultsByPartitionCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopicResult WithResultsByPartitionCollection(Array<AddPartitionsToTxnPartitionResult> resultsByPartitionCollection)
			{
				ResultsByPartitionCollection = resultsByPartitionCollection;
				return this;
			}
		}

		public class AddPartitionsToTxnPartitionResult : ISerialize
		{
			internal AddPartitionsToTxnPartitionResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_partitionIndex.GetSize(IsFlexibleVersion) +
				_partitionErrorCode.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AddPartitionsToTxnPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnPartitionResult(version);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnPartitionResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnPartitionResult WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int16 _partitionErrorCode = Int16.Default;
			/// <summary>
			/// <para>The response error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 PartitionErrorCode 
			{
				get => _partitionErrorCode;
				private set 
				{
					_partitionErrorCode = value;
				}
			}

			/// <summary>
			/// <para>The response error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnPartitionResult WithPartitionErrorCode(Int16 partitionErrorCode)
			{
				PartitionErrorCode = partitionErrorCode;
				return this;
			}
		}
	}

	public class AddRaftVoterRequest : Message, IRespond<AddRaftVoterResponse>
	{
		public AddRaftVoterRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AddRaftVoterRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(80);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clusterId.GetSize(IsFlexibleVersion) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			_voterId.GetSize(IsFlexibleVersion) +
			_voterDirectoryId.GetSize(IsFlexibleVersion) +
			_listenersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AddRaftVoterRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddRaftVoterRequest(version);
			instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VoterId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VoterDirectoryId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ListenersCollection = await Map<String, Listener>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Listener.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddRaftVoterRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _voterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _voterDirectoryId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _listenersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterRequest WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Int32 _voterId = Int32.Default;
		/// <summary>
		/// <para>The replica id of the voter getting added to the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 VoterId 
		{
			get => _voterId;
			private set 
			{
				_voterId = value;
			}
		}

		/// <summary>
		/// <para>The replica id of the voter getting added to the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterRequest WithVoterId(Int32 voterId)
		{
			VoterId = voterId;
			return this;
		}

		private Uuid _voterDirectoryId = Uuid.Default;
		/// <summary>
		/// <para>The directory id of the voter getting added to the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid VoterDirectoryId 
		{
			get => _voterDirectoryId;
			private set 
			{
				_voterDirectoryId = value;
			}
		}

		/// <summary>
		/// <para>The directory id of the voter getting added to the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterRequest WithVoterDirectoryId(Uuid voterDirectoryId)
		{
			VoterDirectoryId = voterDirectoryId;
			return this;
		}

		private Map<String, Listener> _listenersCollection = Map<String, Listener>.Default;
		/// <summary>
		/// <para>The endpoints that can be used to communicate with the voter</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, Listener> ListenersCollection 
		{
			get => _listenersCollection;
			private set 
			{
				_listenersCollection = value;
			}
		}

		/// <summary>
		/// <para>The endpoints that can be used to communicate with the voter</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterRequest WithListenersCollection(params Func<Listener, Listener>[] createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate Listener CreateListener(Listener field);

		/// <summary>
		/// <para>The endpoints that can be used to communicate with the voter</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterRequest WithListenersCollection(IEnumerable<CreateListener> createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class Listener : ISerialize
		{
			internal Listener(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Listener> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Listener(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Listener is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the endpoint</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the endpoint</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithName(String name)
			{
				Name = name;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The hostname</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The hostname</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithHost(String host)
			{
				Host = host;
				return this;
			}

			private UInt16 _port = UInt16.Default;
			/// <summary>
			/// <para>The port</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UInt16 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The port</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithPort(UInt16 port)
			{
				Port = port;
				return this;
			}
		}

		public AddRaftVoterResponse Respond()
			=> new AddRaftVoterResponse(Version);
	}

	public class AddRaftVoterResponse : Message
	{
		public AddRaftVoterResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AddRaftVoterResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(80);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AddRaftVoterResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddRaftVoterResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddRaftVoterResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddRaftVoterResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}
	}

	public class AllocateProducerIdsRequest : Message, IRespond<AllocateProducerIdsResponse>
	{
		public AllocateProducerIdsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AllocateProducerIdsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(67);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			_brokerEpoch.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AllocateProducerIdsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AllocateProducerIdsRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AllocateProducerIdsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public AllocateProducerIdsRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		public AllocateProducerIdsResponse Respond()
			=> new AllocateProducerIdsResponse(Version);
	}

	public class AllocateProducerIdsResponse : Message
	{
		public AllocateProducerIdsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AllocateProducerIdsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(67);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_producerIdStart.GetSize(IsFlexibleVersion) +
			_producerIdLen.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AllocateProducerIdsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AllocateProducerIdsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerIdStart = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerIdLen = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AllocateProducerIdsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerIdStart.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerIdLen.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _producerIdStart = Int64.Default;
		/// <summary>
		/// <para>The first producer ID in this range, inclusive</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerIdStart 
		{
			get => _producerIdStart;
			private set 
			{
				_producerIdStart = value;
			}
		}

		/// <summary>
		/// <para>The first producer ID in this range, inclusive</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithProducerIdStart(Int64 producerIdStart)
		{
			ProducerIdStart = producerIdStart;
			return this;
		}

		private Int32 _producerIdLen = Int32.Default;
		/// <summary>
		/// <para>The number of producer IDs in this range</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ProducerIdLen 
		{
			get => _producerIdLen;
			private set 
			{
				_producerIdLen = value;
			}
		}

		/// <summary>
		/// <para>The number of producer IDs in this range</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithProducerIdLen(Int32 producerIdLen)
		{
			ProducerIdLen = producerIdLen;
			return this;
		}
	}

	public class AlterClientQuotasRequest : Message, IRespond<AlterClientQuotasResponse>
	{
		public AlterClientQuotasRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterClientQuotasRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(49);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_entriesCollection.GetSize(IsFlexibleVersion) +
			_validateOnly.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterClientQuotasRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterClientQuotasRequest(version);
			instance.EntriesCollection = await Array<EntryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterClientQuotasRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _entriesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _validateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<EntryData> _entriesCollection = Array.Empty<EntryData>();
		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<EntryData> EntriesCollection 
		{
			get => _entriesCollection;
			private set 
			{
				_entriesCollection = value;
			}
		}

		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasRequest WithEntriesCollection(params Func<EntryData, EntryData>[] createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(new EntryData(Version)))
				.ToArray();
			return this;
		}

		public delegate EntryData CreateEntryData(EntryData field);

		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasRequest WithEntriesCollection(IEnumerable<CreateEntryData> createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(new EntryData(Version)))
				.ToArray();
			return this;
		}

		public class EntryData : ISerialize
		{
			internal EntryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_entityCollection.GetSize(IsFlexibleVersion) +
				_opsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<EntryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new EntryData(version);
				instance.EntityCollection = await Array<EntityData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntityData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.OpsCollection = await Array<OpData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OpData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for EntryData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _entityCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _opsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Array<EntityData> _entityCollection = Array.Empty<EntityData>();
			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<EntityData> EntityCollection 
			{
				get => _entityCollection;
				private set 
				{
					_entityCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(params Func<EntityData, EntityData>[] createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(new EntityData(Version)))
					.ToArray();
				return this;
			}

			public delegate EntityData CreateEntityData(EntityData field);

			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(IEnumerable<CreateEntityData> createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(new EntityData(Version)))
					.ToArray();
				return this;
			}

			public class EntityData : ISerialize
			{
				internal EntityData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_entityType.GetSize(IsFlexibleVersion) +
					_entityName.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<EntityData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EntityData(version);
					instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.EntityName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EntityData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _entityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _entityName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _entityType = String.Default;
				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String EntityType 
				{
					get => _entityType;
					private set 
					{
						_entityType = value;
					}
				}

				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityType(String entityType)
				{
					EntityType = entityType;
					return this;
				}

				private NullableString _entityName = NullableString.Default;
				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? EntityName 
				{
					get => _entityName;
					private set 
					{
						_entityName = value;
					}
				}

				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityName(String? entityName)
				{
					EntityName = entityName;
					return this;
				}
			}

			private Array<OpData> _opsCollection = Array.Empty<OpData>();
			/// <summary>
			/// <para>An individual quota configuration entry to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<OpData> OpsCollection 
			{
				get => _opsCollection;
				private set 
				{
					_opsCollection = value;
				}
			}

			/// <summary>
			/// <para>An individual quota configuration entry to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithOpsCollection(params Func<OpData, OpData>[] createFields)
			{
				OpsCollection = createFields
					.Select(createField => createField(new OpData(Version)))
					.ToArray();
				return this;
			}

			public delegate OpData CreateOpData(OpData field);

			/// <summary>
			/// <para>An individual quota configuration entry to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithOpsCollection(IEnumerable<CreateOpData> createFields)
			{
				OpsCollection = createFields
					.Select(createField => createField(new OpData(Version)))
					.ToArray();
				return this;
			}

			public class OpData : ISerialize
			{
				internal OpData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_key.GetSize(IsFlexibleVersion) +
					_value.GetSize(IsFlexibleVersion) +
					_remove.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OpData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OpData(version);
					instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Value = await Float64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Remove = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OpData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _remove.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _key = String.Default;
				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Key 
				{
					get => _key;
					private set 
					{
						_key = value;
					}
				}

				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OpData WithKey(String key)
				{
					Key = key;
					return this;
				}

				private Float64 _value = Float64.Default;
				/// <summary>
				/// <para>The value to set, otherwise ignored if the value is to be removed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Float64 Value 
				{
					get => _value;
					private set 
					{
						_value = value;
					}
				}

				/// <summary>
				/// <para>The value to set, otherwise ignored if the value is to be removed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OpData WithValue(Float64 value)
				{
					Value = value;
					return this;
				}

				private Boolean _remove = Boolean.Default;
				/// <summary>
				/// <para>Whether the quota configuration value should be removed, otherwise set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean Remove 
				{
					get => _remove;
					private set 
					{
						_remove = value;
					}
				}

				/// <summary>
				/// <para>Whether the quota configuration value should be removed, otherwise set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OpData WithRemove(Boolean remove)
				{
					Remove = remove;
					return this;
				}
			}
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>Whether the alteration should be validated, but not performed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			private set 
			{
				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>Whether the alteration should be validated, but not performed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public AlterClientQuotasResponse Respond()
			=> new AlterClientQuotasResponse(Version);
	}

	public class AlterClientQuotasResponse : Message
	{
		public AlterClientQuotasResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterClientQuotasResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(49);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_entriesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterClientQuotasResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterClientQuotasResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.EntriesCollection = await Array<EntryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterClientQuotasResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _entriesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<EntryData> _entriesCollection = Array.Empty<EntryData>();
		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<EntryData> EntriesCollection 
		{
			get => _entriesCollection;
			private set 
			{
				_entriesCollection = value;
			}
		}

		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasResponse WithEntriesCollection(params Func<EntryData, EntryData>[] createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(new EntryData(Version)))
				.ToArray();
			return this;
		}

		public delegate EntryData CreateEntryData(EntryData field);

		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasResponse WithEntriesCollection(IEnumerable<CreateEntryData> createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(new EntryData(Version)))
				.ToArray();
			return this;
		}

		public class EntryData : ISerialize
		{
			internal EntryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_entityCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<EntryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new EntryData(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.EntityCollection = await Array<EntityData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntityData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for EntryData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _entityCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or `0` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or `0` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The error message, or `null` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or `null` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Array<EntityData> _entityCollection = Array.Empty<EntityData>();
			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<EntityData> EntityCollection 
			{
				get => _entityCollection;
				private set 
				{
					_entityCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(params Func<EntityData, EntityData>[] createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(new EntityData(Version)))
					.ToArray();
				return this;
			}

			public delegate EntityData CreateEntityData(EntityData field);

			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(IEnumerable<CreateEntityData> createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(new EntityData(Version)))
					.ToArray();
				return this;
			}

			public class EntityData : ISerialize
			{
				internal EntityData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_entityType.GetSize(IsFlexibleVersion) +
					_entityName.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<EntityData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EntityData(version);
					instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.EntityName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EntityData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _entityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _entityName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _entityType = String.Default;
				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String EntityType 
				{
					get => _entityType;
					private set 
					{
						_entityType = value;
					}
				}

				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityType(String entityType)
				{
					EntityType = entityType;
					return this;
				}

				private NullableString _entityName = NullableString.Default;
				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? EntityName 
				{
					get => _entityName;
					private set 
					{
						_entityName = value;
					}
				}

				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityName(String? entityName)
				{
					EntityName = entityName;
					return this;
				}
			}
		}
	}

	public class AlterConfigsRequest : Message, IRespond<AlterConfigsResponse>
	{
		public AlterConfigsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterConfigsRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(33);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resourcesCollection.GetSize(IsFlexibleVersion) +
			_validateOnly.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterConfigsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterConfigsRequest(version);
			instance.ResourcesCollection = await Map<Int8, AlterConfigsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResource.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.ResourceType, cancellationToken).ConfigureAwait(false);
			instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resourcesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _validateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<Int8, AlterConfigsResource> _resourcesCollection = Map<Int8, AlterConfigsResource>.Default;
		/// <summary>
		/// <para>The updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int8, AlterConfigsResource> ResourcesCollection 
		{
			get => _resourcesCollection;
			private set 
			{
				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>The updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsRequest WithResourcesCollection(params Func<AlterConfigsResource, AlterConfigsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new AlterConfigsResource(Version)))
				.ToDictionary(field => field.ResourceType);
			return this;
		}

		public delegate AlterConfigsResource CreateAlterConfigsResource(AlterConfigsResource field);

		/// <summary>
		/// <para>The updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsRequest WithResourcesCollection(IEnumerable<CreateAlterConfigsResource> createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new AlterConfigsResource(Version)))
				.ToDictionary(field => field.ResourceType);
			return this;
		}

		public class AlterConfigsResource : ISerialize
		{
			internal AlterConfigsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				_configsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterConfigsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResource(version);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ConfigsCollection = await Map<String, AlterableConfig>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterableConfig.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResource is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _configsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Map<String, AlterableConfig> _configsCollection = Map<String, AlterableConfig>.Default;
			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<String, AlterableConfig> ConfigsCollection 
			{
				get => _configsCollection;
				private set 
				{
					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithConfigsCollection(params Func<AlterableConfig, AlterableConfig>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new AlterableConfig(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public delegate AlterableConfig CreateAlterableConfig(AlterableConfig field);

			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithConfigsCollection(IEnumerable<CreateAlterableConfig> createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new AlterableConfig(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public class AlterableConfig : ISerialize
			{
				internal AlterableConfig(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_value.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<AlterableConfig> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterableConfig(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterableConfig is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithName(String name)
				{
					Name = name;
					return this;
				}

				private NullableString _value = NullableString.Default;
				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					private set 
					{
						_value = value;
					}
				}

				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithValue(String? value)
				{
					Value = value;
					return this;
				}
			}
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			private set 
			{
				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public AlterConfigsResponse Respond()
			=> new AlterConfigsResponse(Version);
	}

	public class AlterConfigsResponse : Message
	{
		public AlterConfigsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterConfigsResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(33);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterConfigsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterConfigsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Array<AlterConfigsResourceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResourceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<AlterConfigsResourceResponse> _responsesCollection = Array.Empty<AlterConfigsResourceResponse>();
		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AlterConfigsResourceResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResponse WithResponsesCollection(params Func<AlterConfigsResourceResponse, AlterConfigsResourceResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new AlterConfigsResourceResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate AlterConfigsResourceResponse CreateAlterConfigsResourceResponse(AlterConfigsResourceResponse field);

		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResponse WithResponsesCollection(IEnumerable<CreateAlterConfigsResourceResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new AlterConfigsResourceResponse(Version)))
				.ToArray();
			return this;
		}

		public class AlterConfigsResourceResponse : ISerialize
		{
			internal AlterConfigsResourceResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterConfigsResourceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResourceResponse(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResourceResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}
		}
	}

	public class AlterPartitionReassignmentsRequest : Message, IRespond<AlterPartitionReassignmentsResponse>
	{
		public AlterPartitionReassignmentsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterPartitionReassignmentsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(45);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_timeoutMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterPartitionReassignmentsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterPartitionReassignmentsRequest(version);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<ReassignableTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignableTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterPartitionReassignmentsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public AlterPartitionReassignmentsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Array<ReassignableTopic> _topicsCollection = Array.Empty<ReassignableTopic>();
		/// <summary>
		/// <para>The topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReassignableTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsRequest WithTopicsCollection(params Func<ReassignableTopic, ReassignableTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ReassignableTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate ReassignableTopic CreateReassignableTopic(ReassignableTopic field);

		/// <summary>
		/// <para>The topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsRequest WithTopicsCollection(IEnumerable<CreateReassignableTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ReassignableTopic(Version)))
				.ToArray();
			return this;
		}

		public class ReassignableTopic : ISerialize
		{
			internal ReassignableTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReassignableTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReassignableTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<ReassignablePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignablePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignableTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<ReassignablePartition> _partitionsCollection = Array.Empty<ReassignablePartition>();
			/// <summary>
			/// <para>The partitions to reassign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<ReassignablePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to reassign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopic WithPartitionsCollection(params Func<ReassignablePartition, ReassignablePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ReassignablePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate ReassignablePartition CreateReassignablePartition(ReassignablePartition field);

			/// <summary>
			/// <para>The partitions to reassign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopic WithPartitionsCollection(IEnumerable<CreateReassignablePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ReassignablePartition(Version)))
					.ToArray();
				return this;
			}

			public class ReassignablePartition : ISerialize
			{
				internal ReassignablePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_replicasCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<ReassignablePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ReassignablePartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ReplicasCollection = await NullableArray<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignablePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _replicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private NullableArray<Int32> _replicasCollection = new NullableArray<Int32>(null);
				/// <summary>
				/// <para>The replicas to place the partitions on, or null to cancel a pending reassignment for this partition.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Array<Int32>? ReplicasCollection 
				{
					get => _replicasCollection;
					private set 
					{
						_replicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The replicas to place the partitions on, or null to cancel a pending reassignment for this partition.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public ReassignablePartition WithReplicasCollection(Array<Int32>? replicasCollection)
				{
					ReplicasCollection = replicasCollection;
					return this;
				}
			}
		}

		public AlterPartitionReassignmentsResponse Respond()
			=> new AlterPartitionReassignmentsResponse(Version);
	}

	public class AlterPartitionReassignmentsResponse : Message
	{
		public AlterPartitionReassignmentsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterPartitionReassignmentsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(45);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterPartitionReassignmentsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterPartitionReassignmentsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Array<ReassignableTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignableTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterPartitionReassignmentsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<ReassignableTopicResponse> _responsesCollection = Array.Empty<ReassignableTopicResponse>();
		/// <summary>
		/// <para>The responses to topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReassignableTopicResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses to topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithResponsesCollection(params Func<ReassignableTopicResponse, ReassignableTopicResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new ReassignableTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate ReassignableTopicResponse CreateReassignableTopicResponse(ReassignableTopicResponse field);

		/// <summary>
		/// <para>The responses to topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithResponsesCollection(IEnumerable<CreateReassignableTopicResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new ReassignableTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public class ReassignableTopicResponse : ISerialize
		{
			internal ReassignableTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReassignableTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReassignableTopicResponse(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<ReassignablePartitionResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignablePartitionResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignableTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopicResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<ReassignablePartitionResponse> _partitionsCollection = Array.Empty<ReassignablePartitionResponse>();
			/// <summary>
			/// <para>The responses to partitions to reassign</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<ReassignablePartitionResponse> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses to partitions to reassign</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopicResponse WithPartitionsCollection(params Func<ReassignablePartitionResponse, ReassignablePartitionResponse>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ReassignablePartitionResponse(Version)))
					.ToArray();
				return this;
			}

			public delegate ReassignablePartitionResponse CreateReassignablePartitionResponse(ReassignablePartitionResponse field);

			/// <summary>
			/// <para>The responses to partitions to reassign</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopicResponse WithPartitionsCollection(IEnumerable<CreateReassignablePartitionResponse> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ReassignablePartitionResponse(Version)))
					.ToArray();
				return this;
			}

			public class ReassignablePartitionResponse : ISerialize
			{
				internal ReassignablePartitionResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<ReassignablePartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ReassignablePartitionResponse(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignablePartitionResponse is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartitionResponse WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code for this partition, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code for this partition, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartitionResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = NullableString.Default;
				/// <summary>
				/// <para>The error message for this partition, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message for this partition, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartitionResponse WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class AlterPartitionRequest : Message, IRespond<AlterPartitionResponse>
	{
		public AlterPartitionRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterPartitionRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(56);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			_brokerEpoch.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterPartitionRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterPartitionRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterPartitionRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public AlterPartitionRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionRequest WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 1 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 2 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version >= 0 && instance.Version <= 1) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 2) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 1)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name of the topic to alter ISRs for</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to alter ISRs for</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The ID of the topic to alter ISRs for</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the topic to alter ISRs for</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public TopicData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(Version >= 0 && Version <= 2 ? 
						_newIsrCollection.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 3 ? 
						_newIsrWithEpochsCollection.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 ? 
						_leaderRecoveryState.GetSize(IsFlexibleVersion):
						0) +
					_partitionEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 2) 
						instance.NewIsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 3) 
						instance.NewIsrWithEpochsCollection = await Array<BrokerState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => BrokerState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.LeaderRecoveryState = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 2)
						await _newIsrCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 3)
						await _newIsrWithEpochsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _leaderRecoveryState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch of this partition</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Array<Int32> _newIsrCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The ISR for this partition. Deprecated since version 3.</para>
				/// <para>Versions: 0-2</para>
				/// </summary>
				public Array<Int32> NewIsrCollection 
				{
					get => _newIsrCollection;
					private set 
					{
						if (Version >= 0 && Version <= 2 == false)
							throw new UnsupportedVersionException($"NewIsrCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-2");

						_newIsrCollection = value;
					}
				}

				/// <summary>
				/// <para>The ISR for this partition. Deprecated since version 3.</para>
				/// <para>Versions: 0-2</para>
				/// </summary>
				public PartitionData WithNewIsrCollection(Array<Int32> newIsrCollection)
				{
					NewIsrCollection = newIsrCollection;
					return this;
				}

				private Array<BrokerState> _newIsrWithEpochsCollection = Array.Empty<BrokerState>();
				/// <summary>
				/// <para>Versions: 3+</para>
				/// </summary>
				public Array<BrokerState> NewIsrWithEpochsCollection 
				{
					get => _newIsrWithEpochsCollection;
					private set 
					{
						if (Version >= 3 == false)
							throw new UnsupportedVersionException($"NewIsrWithEpochsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

						_newIsrWithEpochsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 3+</para>
				/// </summary>
				public PartitionData WithNewIsrWithEpochsCollection(params Func<BrokerState, BrokerState>[] createFields)
				{
					NewIsrWithEpochsCollection = createFields
						.Select(createField => createField(new BrokerState(Version)))
						.ToArray();
					return this;
				}

				public delegate BrokerState CreateBrokerState(BrokerState field);

				/// <summary>
				/// <para>Versions: 3+</para>
				/// </summary>
				public PartitionData WithNewIsrWithEpochsCollection(IEnumerable<CreateBrokerState> createFields)
				{
					NewIsrWithEpochsCollection = createFields
						.Select(createField => createField(new BrokerState(Version)))
						.ToArray();
					return this;
				}

				public class BrokerState : ISerialize
				{
					internal BrokerState(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 3 ? 
							_brokerId.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 3 ? 
							_brokerEpoch.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<BrokerState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new BrokerState(version);
						if (instance.Version >= 3) 
							instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 3) 
							instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerState is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 3)
							await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 3)
							await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _brokerId = Int32.Default;
					/// <summary>
					/// <para>The ID of the broker.</para>
					/// <para>Versions: 3+</para>
					/// </summary>
					public Int32 BrokerId 
					{
						get => _brokerId;
						private set 
						{
							if (Version >= 3 == false)
								throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

							_brokerId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the broker.</para>
					/// <para>Versions: 3+</para>
					/// </summary>
					public BrokerState WithBrokerId(Int32 brokerId)
					{
						BrokerId = brokerId;
						return this;
					}

					private Int64 _brokerEpoch = new Int64(-1);
					/// <summary>
					/// <para>The epoch of the broker. It will be -1 if the epoch check is not supported.</para>
					/// <para>Versions: 3+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 BrokerEpoch 
					{
						get => _brokerEpoch;
						private set 
						{
							if (Version >= 3 == false)
								throw new UnsupportedVersionException($"BrokerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

							_brokerEpoch = value;
						}
					}

					/// <summary>
					/// <para>The epoch of the broker. It will be -1 if the epoch check is not supported.</para>
					/// <para>Versions: 3+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public BrokerState WithBrokerEpoch(Int64 brokerEpoch)
					{
						BrokerEpoch = brokerEpoch;
						return this;
					}
				}

				private Int8 _leaderRecoveryState = new Int8(0);
				/// <summary>
				/// <para>1 if the partition is recovering from an unclean leader election; 0 otherwise.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public Int8 LeaderRecoveryState 
				{
					get => _leaderRecoveryState;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"LeaderRecoveryState does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_leaderRecoveryState = value;
					}
				}

				/// <summary>
				/// <para>1 if the partition is recovering from an unclean leader election; 0 otherwise.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public PartitionData WithLeaderRecoveryState(Int8 leaderRecoveryState)
				{
					LeaderRecoveryState = leaderRecoveryState;
					return this;
				}

				private Int32 _partitionEpoch = Int32.Default;
				/// <summary>
				/// <para>The expected epoch of the partition which is being updated. For legacy cluster this is the ZkVersion in the LeaderAndIsr request.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionEpoch 
				{
					get => _partitionEpoch;
					private set 
					{
						_partitionEpoch = value;
					}
				}

				/// <summary>
				/// <para>The expected epoch of the partition which is being updated. For legacy cluster this is the ZkVersion in the LeaderAndIsr request.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionEpoch(Int32 partitionEpoch)
				{
					PartitionEpoch = partitionEpoch;
					return this;
				}
			}
		}

		public AlterPartitionResponse Respond()
			=> new AlterPartitionResponse(Version);
	}

	public class AlterPartitionResponse : Message
	{
		public AlterPartitionResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterPartitionResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(56);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterPartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterPartitionResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterPartitionResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionResponse WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 1 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 2 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version >= 0 && instance.Version <= 1) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 2) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 1)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name of the topic</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The ID of the topic</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the topic</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public TopicData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					_isrCollection.GetSize(IsFlexibleVersion) +
					(Version >= 1 ? 
						_leaderRecoveryState.GetSize(IsFlexibleVersion):
						0) +
					_partitionEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.IsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.LeaderRecoveryState = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _isrCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _leaderRecoveryState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition level error code</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition level error code</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The broker ID of the leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The broker ID of the leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Array<Int32> _isrCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The in-sync replica IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> IsrCollection 
				{
					get => _isrCollection;
					private set 
					{
						_isrCollection = value;
					}
				}

				/// <summary>
				/// <para>The in-sync replica IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithIsrCollection(Array<Int32> isrCollection)
				{
					IsrCollection = isrCollection;
					return this;
				}

				private Int8 _leaderRecoveryState = new Int8(0);
				/// <summary>
				/// <para>1 if the partition is recovering from an unclean leader election; 0 otherwise.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public Int8 LeaderRecoveryState 
				{
					get => _leaderRecoveryState;
					private set 
					{
						_leaderRecoveryState = value;
					}
				}

				/// <summary>
				/// <para>1 if the partition is recovering from an unclean leader election; 0 otherwise.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public PartitionData WithLeaderRecoveryState(Int8 leaderRecoveryState)
				{
					LeaderRecoveryState = leaderRecoveryState;
					return this;
				}

				private Int32 _partitionEpoch = Int32.Default;
				/// <summary>
				/// <para>The current epoch for the partition for KRaft controllers. The current ZK version for the legacy controllers.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionEpoch 
				{
					get => _partitionEpoch;
					private set 
					{
						_partitionEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current epoch for the partition for KRaft controllers. The current ZK version for the legacy controllers.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionEpoch(Int32 partitionEpoch)
				{
					PartitionEpoch = partitionEpoch;
					return this;
				}
			}
		}
	}

	public class AlterReplicaLogDirsRequest : Message, IRespond<AlterReplicaLogDirsResponse>
	{
		public AlterReplicaLogDirsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterReplicaLogDirsRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(34);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_dirsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterReplicaLogDirsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterReplicaLogDirsRequest(version);
			instance.DirsCollection = await Map<String, AlterReplicaLogDir>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDir.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Path, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _dirsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<String, AlterReplicaLogDir> _dirsCollection = Map<String, AlterReplicaLogDir>.Default;
		/// <summary>
		/// <para>The alterations to make for each directory.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, AlterReplicaLogDir> DirsCollection 
		{
			get => _dirsCollection;
			private set 
			{
				_dirsCollection = value;
			}
		}

		/// <summary>
		/// <para>The alterations to make for each directory.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsRequest WithDirsCollection(params Func<AlterReplicaLogDir, AlterReplicaLogDir>[] createFields)
		{
			DirsCollection = createFields
				.Select(createField => createField(new AlterReplicaLogDir(Version)))
				.ToDictionary(field => field.Path);
			return this;
		}

		public delegate AlterReplicaLogDir CreateAlterReplicaLogDir(AlterReplicaLogDir field);

		/// <summary>
		/// <para>The alterations to make for each directory.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsRequest WithDirsCollection(IEnumerable<CreateAlterReplicaLogDir> createFields)
		{
			DirsCollection = createFields
				.Select(createField => createField(new AlterReplicaLogDir(Version)))
				.ToDictionary(field => field.Path);
			return this;
		}

		public class AlterReplicaLogDir : ISerialize
		{
			internal AlterReplicaLogDir(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_path.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterReplicaLogDir> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterReplicaLogDir(version);
				instance.Path = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Map<String, AlterReplicaLogDirTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDirTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDir is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _path.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _path = String.Default;
			/// <summary>
			/// <para>The absolute directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Path 
			{
				get => _path;
				private set 
				{
					_path = value;
				}
			}

			/// <summary>
			/// <para>The absolute directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDir WithPath(String path)
			{
				Path = path;
				return this;
			}

			private Map<String, AlterReplicaLogDirTopic> _topicsCollection = Map<String, AlterReplicaLogDirTopic>.Default;
			/// <summary>
			/// <para>The topics to add to the directory.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<String, AlterReplicaLogDirTopic> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The topics to add to the directory.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDir WithTopicsCollection(params Func<AlterReplicaLogDirTopic, AlterReplicaLogDirTopic>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new AlterReplicaLogDirTopic(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public delegate AlterReplicaLogDirTopic CreateAlterReplicaLogDirTopic(AlterReplicaLogDirTopic field);

			/// <summary>
			/// <para>The topics to add to the directory.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDir WithTopicsCollection(IEnumerable<CreateAlterReplicaLogDirTopic> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new AlterReplicaLogDirTopic(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public class AlterReplicaLogDirTopic : ISerialize
			{
				internal AlterReplicaLogDirTopic(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_partitionsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<AlterReplicaLogDirTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterReplicaLogDirTopic(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirTopic is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirTopic WithName(String name)
				{
					Name = name;
					return this;
				}

				private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The partition indexes.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The partition indexes.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirTopic WithPartitionsCollection(Array<Int32> partitionsCollection)
				{
					PartitionsCollection = partitionsCollection;
					return this;
				}
			}
		}

		public AlterReplicaLogDirsResponse Respond()
			=> new AlterReplicaLogDirsResponse(Version);
	}

	public class AlterReplicaLogDirsResponse : Message
	{
		public AlterReplicaLogDirsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterReplicaLogDirsResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(34);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterReplicaLogDirsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterReplicaLogDirsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<AlterReplicaLogDirTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDirTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<AlterReplicaLogDirTopicResult> _resultsCollection = Array.Empty<AlterReplicaLogDirTopicResult>();
		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AlterReplicaLogDirTopicResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsResponse WithResultsCollection(params Func<AlterReplicaLogDirTopicResult, AlterReplicaLogDirTopicResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new AlterReplicaLogDirTopicResult(Version)))
				.ToArray();
			return this;
		}

		public delegate AlterReplicaLogDirTopicResult CreateAlterReplicaLogDirTopicResult(AlterReplicaLogDirTopicResult field);

		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsResponse WithResultsCollection(IEnumerable<CreateAlterReplicaLogDirTopicResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new AlterReplicaLogDirTopicResult(Version)))
				.ToArray();
			return this;
		}

		public class AlterReplicaLogDirTopicResult : ISerialize
		{
			internal AlterReplicaLogDirTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterReplicaLogDirTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterReplicaLogDirTopicResult(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<AlterReplicaLogDirPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDirPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDirTopicResult WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<AlterReplicaLogDirPartitionResult> _partitionsCollection = Array.Empty<AlterReplicaLogDirPartitionResult>();
			/// <summary>
			/// <para>The results for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<AlterReplicaLogDirPartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDirTopicResult WithPartitionsCollection(params Func<AlterReplicaLogDirPartitionResult, AlterReplicaLogDirPartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new AlterReplicaLogDirPartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate AlterReplicaLogDirPartitionResult CreateAlterReplicaLogDirPartitionResult(AlterReplicaLogDirPartitionResult field);

			/// <summary>
			/// <para>The results for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDirTopicResult WithPartitionsCollection(IEnumerable<CreateAlterReplicaLogDirPartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new AlterReplicaLogDirPartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class AlterReplicaLogDirPartitionResult : ISerialize
			{
				internal AlterReplicaLogDirPartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<AlterReplicaLogDirPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterReplicaLogDirPartitionResult(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirPartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirPartitionResult WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirPartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class AlterUserScramCredentialsRequest : Message, IRespond<AlterUserScramCredentialsResponse>
	{
		public AlterUserScramCredentialsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterUserScramCredentialsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(51);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_deletionsCollection.GetSize(IsFlexibleVersion) +
			_upsertionsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterUserScramCredentialsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterUserScramCredentialsRequest(version);
			instance.DeletionsCollection = await Array<ScramCredentialDeletion>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ScramCredentialDeletion.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.UpsertionsCollection = await Array<ScramCredentialUpsertion>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ScramCredentialUpsertion.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterUserScramCredentialsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _deletionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _upsertionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<ScramCredentialDeletion> _deletionsCollection = Array.Empty<ScramCredentialDeletion>();
		/// <summary>
		/// <para>The SCRAM credentials to remove.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ScramCredentialDeletion> DeletionsCollection 
		{
			get => _deletionsCollection;
			private set 
			{
				_deletionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The SCRAM credentials to remove.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsRequest WithDeletionsCollection(params Func<ScramCredentialDeletion, ScramCredentialDeletion>[] createFields)
		{
			DeletionsCollection = createFields
				.Select(createField => createField(new ScramCredentialDeletion(Version)))
				.ToArray();
			return this;
		}

		public delegate ScramCredentialDeletion CreateScramCredentialDeletion(ScramCredentialDeletion field);

		/// <summary>
		/// <para>The SCRAM credentials to remove.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsRequest WithDeletionsCollection(IEnumerable<CreateScramCredentialDeletion> createFields)
		{
			DeletionsCollection = createFields
				.Select(createField => createField(new ScramCredentialDeletion(Version)))
				.ToArray();
			return this;
		}

		public class ScramCredentialDeletion : ISerialize
		{
			internal ScramCredentialDeletion(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_mechanism.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ScramCredentialDeletion> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ScramCredentialDeletion(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Mechanism = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ScramCredentialDeletion is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialDeletion WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int8 _mechanism = Int8.Default;
			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Mechanism 
			{
				get => _mechanism;
				private set 
				{
					_mechanism = value;
				}
			}

			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialDeletion WithMechanism(Int8 mechanism)
			{
				Mechanism = mechanism;
				return this;
			}
		}

		private Array<ScramCredentialUpsertion> _upsertionsCollection = Array.Empty<ScramCredentialUpsertion>();
		/// <summary>
		/// <para>The SCRAM credentials to update/insert.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ScramCredentialUpsertion> UpsertionsCollection 
		{
			get => _upsertionsCollection;
			private set 
			{
				_upsertionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The SCRAM credentials to update/insert.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsRequest WithUpsertionsCollection(params Func<ScramCredentialUpsertion, ScramCredentialUpsertion>[] createFields)
		{
			UpsertionsCollection = createFields
				.Select(createField => createField(new ScramCredentialUpsertion(Version)))
				.ToArray();
			return this;
		}

		public delegate ScramCredentialUpsertion CreateScramCredentialUpsertion(ScramCredentialUpsertion field);

		/// <summary>
		/// <para>The SCRAM credentials to update/insert.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsRequest WithUpsertionsCollection(IEnumerable<CreateScramCredentialUpsertion> createFields)
		{
			UpsertionsCollection = createFields
				.Select(createField => createField(new ScramCredentialUpsertion(Version)))
				.ToArray();
			return this;
		}

		public class ScramCredentialUpsertion : ISerialize
		{
			internal ScramCredentialUpsertion(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_mechanism.GetSize(IsFlexibleVersion) +
				_iterations.GetSize(IsFlexibleVersion) +
				_salt.GetSize(IsFlexibleVersion) +
				_saltedPassword.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ScramCredentialUpsertion> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ScramCredentialUpsertion(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Mechanism = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Iterations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Salt = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.SaltedPassword = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ScramCredentialUpsertion is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _iterations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _salt.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _saltedPassword.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int8 _mechanism = Int8.Default;
			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Mechanism 
			{
				get => _mechanism;
				private set 
				{
					_mechanism = value;
				}
			}

			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithMechanism(Int8 mechanism)
			{
				Mechanism = mechanism;
				return this;
			}

			private Int32 _iterations = Int32.Default;
			/// <summary>
			/// <para>The number of iterations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Iterations 
			{
				get => _iterations;
				private set 
				{
					_iterations = value;
				}
			}

			/// <summary>
			/// <para>The number of iterations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithIterations(Int32 iterations)
			{
				Iterations = iterations;
				return this;
			}

			private Bytes _salt = Bytes.Default;
			/// <summary>
			/// <para>A random salt generated by the client.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Salt 
			{
				get => _salt;
				private set 
				{
					_salt = value;
				}
			}

			/// <summary>
			/// <para>A random salt generated by the client.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithSalt(Bytes salt)
			{
				Salt = salt;
				return this;
			}

			private Bytes _saltedPassword = Bytes.Default;
			/// <summary>
			/// <para>The salted password.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes SaltedPassword 
			{
				get => _saltedPassword;
				private set 
				{
					_saltedPassword = value;
				}
			}

			/// <summary>
			/// <para>The salted password.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithSaltedPassword(Bytes saltedPassword)
			{
				SaltedPassword = saltedPassword;
				return this;
			}
		}

		public AlterUserScramCredentialsResponse Respond()
			=> new AlterUserScramCredentialsResponse(Version);
	}

	public class AlterUserScramCredentialsResponse : Message
	{
		public AlterUserScramCredentialsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AlterUserScramCredentialsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(51);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AlterUserScramCredentialsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterUserScramCredentialsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<AlterUserScramCredentialsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterUserScramCredentialsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterUserScramCredentialsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<AlterUserScramCredentialsResult> _resultsCollection = Array.Empty<AlterUserScramCredentialsResult>();
		/// <summary>
		/// <para>The results for deletions and alterations, one per affected user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AlterUserScramCredentialsResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for deletions and alterations, one per affected user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsResponse WithResultsCollection(params Func<AlterUserScramCredentialsResult, AlterUserScramCredentialsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new AlterUserScramCredentialsResult(Version)))
				.ToArray();
			return this;
		}

		public delegate AlterUserScramCredentialsResult CreateAlterUserScramCredentialsResult(AlterUserScramCredentialsResult field);

		/// <summary>
		/// <para>The results for deletions and alterations, one per affected user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsResponse WithResultsCollection(IEnumerable<CreateAlterUserScramCredentialsResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new AlterUserScramCredentialsResult(Version)))
				.ToArray();
			return this;
		}

		public class AlterUserScramCredentialsResult : ISerialize
		{
			internal AlterUserScramCredentialsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_user.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterUserScramCredentialsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterUserScramCredentialsResult(version);
				instance.User = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterUserScramCredentialsResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _user.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _user = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String User 
			{
				get => _user;
				private set 
				{
					_user = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterUserScramCredentialsResult WithUser(String user)
			{
				User = user;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterUserScramCredentialsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterUserScramCredentialsResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class ApiVersionsRequest : Message, IRespond<ApiVersionsResponse>
	{
		public ApiVersionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ApiVersionsRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(18);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_clientSoftwareName.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_clientSoftwareVersion.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ApiVersionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ApiVersionsRequest(version);
			if (instance.Version >= 3) 
				instance.ClientSoftwareName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.ClientSoftwareVersion = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ApiVersionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _clientSoftwareName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _clientSoftwareVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _clientSoftwareName = String.Default;
		/// <summary>
		/// <para>The name of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String ClientSoftwareName 
		{
			get => _clientSoftwareName;
			private set 
			{
				_clientSoftwareName = value;
			}
		}

		/// <summary>
		/// <para>The name of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsRequest WithClientSoftwareName(String clientSoftwareName)
		{
			ClientSoftwareName = clientSoftwareName;
			return this;
		}

		private String _clientSoftwareVersion = String.Default;
		/// <summary>
		/// <para>The version of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String ClientSoftwareVersion 
		{
			get => _clientSoftwareVersion;
			private set 
			{
				_clientSoftwareVersion = value;
			}
		}

		/// <summary>
		/// <para>The version of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsRequest WithClientSoftwareVersion(String clientSoftwareVersion)
		{
			ClientSoftwareVersion = clientSoftwareVersion;
			return this;
		}

		public ApiVersionsResponse Respond()
			=> new ApiVersionsResponse(Version);
	}

	public class ApiVersionsResponse : Message
	{
		public ApiVersionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ApiVersionsResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(18);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return 0;
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (Version >= 3 && _supportedFeaturesCollectionIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _supportedFeaturesCollection
				});
			if (Version >= 3 && _finalizedFeaturesEpochIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 1,
					Field = _finalizedFeaturesEpoch
				});
			if (Version >= 3 && _finalizedFeaturesCollectionIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 2,
					Field = _finalizedFeaturesCollection
				});
			if (Version >= 3 && _zkMigrationReadyIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 3,
					Field = _zkMigrationReady
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_apiKeysCollection.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ApiVersionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ApiVersionsResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ApiKeysCollection = await Map<Int16, ApiVersion>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ApiVersion.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.ApiKey, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version >= 3) 
								instance.SupportedFeaturesCollection = await Map<String, SupportedFeatureKey>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => SupportedFeatureKey.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field SupportedFeaturesCollection is not supported for version {instance.Version}");
							{
								var size = instance._supportedFeaturesCollection.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field SupportedFeaturesCollection read length {tag.Length} but had actual length of {size}");
							}
							break;

						case 1:
							if (instance.Version >= 3) 
								instance.FinalizedFeaturesEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field FinalizedFeaturesEpoch is not supported for version {instance.Version}");
							{
								var size = instance._finalizedFeaturesEpoch.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field FinalizedFeaturesEpoch read length {tag.Length} but had actual length of {size}");
							}
							break;

						case 2:
							if (instance.Version >= 3) 
								instance.FinalizedFeaturesCollection = await Map<String, FinalizedFeatureKey>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FinalizedFeatureKey.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field FinalizedFeaturesCollection is not supported for version {instance.Version}");
							{
								var size = instance._finalizedFeaturesCollection.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field FinalizedFeaturesCollection read length {tag.Length} but had actual length of {size}");
							}
							break;

						case 3:
							if (instance.Version >= 3) 
								instance.ZkMigrationReady = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field ZkMigrationReady is not supported for version {instance.Version}");
							{
								var size = instance._zkMigrationReady.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field ZkMigrationReady read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ApiVersionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _apiKeysCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ApiVersionsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Map<Int16, ApiVersion> _apiKeysCollection = Map<Int16, ApiVersion>.Default;
		/// <summary>
		/// <para>The APIs supported by the broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int16, ApiVersion> ApiKeysCollection 
		{
			get => _apiKeysCollection;
			private set 
			{
				_apiKeysCollection = value;
			}
		}

		/// <summary>
		/// <para>The APIs supported by the broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ApiVersionsResponse WithApiKeysCollection(params Func<ApiVersion, ApiVersion>[] createFields)
		{
			ApiKeysCollection = createFields
				.Select(createField => createField(new ApiVersion(Version)))
				.ToDictionary(field => field.ApiKey);
			return this;
		}

		public delegate ApiVersion CreateApiVersion(ApiVersion field);

		/// <summary>
		/// <para>The APIs supported by the broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ApiVersionsResponse WithApiKeysCollection(IEnumerable<CreateApiVersion> createFields)
		{
			ApiKeysCollection = createFields
				.Select(createField => createField(new ApiVersion(Version)))
				.ToDictionary(field => field.ApiKey);
			return this;
		}

		public class ApiVersion : ISerialize
		{
			internal ApiVersion(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_apiKey.GetSize(IsFlexibleVersion) +
				_minVersion.GetSize(IsFlexibleVersion) +
				_maxVersion.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ApiVersion> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ApiVersion(version);
				instance.ApiKey = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MinVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MaxVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ApiVersion is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _apiKey.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _minVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _maxVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _apiKey = Int16.Default;
			/// <summary>
			/// <para>The API index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ApiKey 
			{
				get => _apiKey;
				private set 
				{
					_apiKey = value;
				}
			}

			/// <summary>
			/// <para>The API index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ApiVersion WithApiKey(Int16 apiKey)
			{
				ApiKey = apiKey;
				return this;
			}

			private Int16 _minVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MinVersion 
			{
				get => _minVersion;
				private set 
				{
					_minVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ApiVersion WithMinVersion(Int16 minVersion)
			{
				MinVersion = minVersion;
				return this;
			}

			private Int16 _maxVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxVersion 
			{
				get => _maxVersion;
				private set 
				{
					_maxVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ApiVersion WithMaxVersion(Int16 maxVersion)
			{
				MaxVersion = maxVersion;
				return this;
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ApiVersionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private bool _supportedFeaturesCollectionIsSet;
		private Map<String, SupportedFeatureKey> _supportedFeaturesCollection = Map<String, SupportedFeatureKey>.Default;
		/// <summary>
		/// <para>Features supported by the broker.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Map<String, SupportedFeatureKey> SupportedFeaturesCollection 
		{
			get => _supportedFeaturesCollection;
			private set 
			{
				_supportedFeaturesCollection = value;
				_supportedFeaturesCollectionIsSet = true;
			}
		}

		/// <summary>
		/// <para>Features supported by the broker.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsResponse WithSupportedFeaturesCollection(params Func<SupportedFeatureKey, SupportedFeatureKey>[] createFields)
		{
			SupportedFeaturesCollection = createFields
				.Select(createField => createField(new SupportedFeatureKey(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate SupportedFeatureKey CreateSupportedFeatureKey(SupportedFeatureKey field);

		/// <summary>
		/// <para>Features supported by the broker.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsResponse WithSupportedFeaturesCollection(IEnumerable<CreateSupportedFeatureKey> createFields)
		{
			SupportedFeaturesCollection = createFields
				.Select(createField => createField(new SupportedFeatureKey(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class SupportedFeatureKey : ISerialize
		{
			internal SupportedFeatureKey(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 3 ? 
					_name.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_minVersion.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_maxVersion.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<SupportedFeatureKey> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new SupportedFeatureKey(version);
				if (instance.Version >= 3) 
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.MinVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.MaxVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for SupportedFeatureKey is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 3)
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _minVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _maxVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public SupportedFeatureKey WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _minVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MinVersion 
			{
				get => _minVersion;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"MinVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_minVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public SupportedFeatureKey WithMinVersion(Int16 minVersion)
			{
				MinVersion = minVersion;
				return this;
			}

			private Int16 _maxVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MaxVersion 
			{
				get => _maxVersion;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"MaxVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_maxVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public SupportedFeatureKey WithMaxVersion(Int16 maxVersion)
			{
				MaxVersion = maxVersion;
				return this;
			}
		}

		private bool _finalizedFeaturesEpochIsSet;
		private Int64 _finalizedFeaturesEpoch = new Int64(-1);
		/// <summary>
		/// <para>The monotonically increasing epoch for the finalized features information. Valid values are >= 0. A value of -1 is special and represents unknown epoch.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 FinalizedFeaturesEpoch 
		{
			get => _finalizedFeaturesEpoch;
			private set 
			{
				_finalizedFeaturesEpoch = value;
				_finalizedFeaturesEpochIsSet = true;
			}
		}

		/// <summary>
		/// <para>The monotonically increasing epoch for the finalized features information. Valid values are >= 0. A value of -1 is special and represents unknown epoch.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ApiVersionsResponse WithFinalizedFeaturesEpoch(Int64 finalizedFeaturesEpoch)
		{
			FinalizedFeaturesEpoch = finalizedFeaturesEpoch;
			return this;
		}

		private bool _finalizedFeaturesCollectionIsSet;
		private Map<String, FinalizedFeatureKey> _finalizedFeaturesCollection = Map<String, FinalizedFeatureKey>.Default;
		/// <summary>
		/// <para>List of cluster-wide finalized features. The information is valid only if FinalizedFeaturesEpoch >= 0.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Map<String, FinalizedFeatureKey> FinalizedFeaturesCollection 
		{
			get => _finalizedFeaturesCollection;
			private set 
			{
				_finalizedFeaturesCollection = value;
				_finalizedFeaturesCollectionIsSet = true;
			}
		}

		/// <summary>
		/// <para>List of cluster-wide finalized features. The information is valid only if FinalizedFeaturesEpoch >= 0.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsResponse WithFinalizedFeaturesCollection(params Func<FinalizedFeatureKey, FinalizedFeatureKey>[] createFields)
		{
			FinalizedFeaturesCollection = createFields
				.Select(createField => createField(new FinalizedFeatureKey(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate FinalizedFeatureKey CreateFinalizedFeatureKey(FinalizedFeatureKey field);

		/// <summary>
		/// <para>List of cluster-wide finalized features. The information is valid only if FinalizedFeaturesEpoch >= 0.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsResponse WithFinalizedFeaturesCollection(IEnumerable<CreateFinalizedFeatureKey> createFields)
		{
			FinalizedFeaturesCollection = createFields
				.Select(createField => createField(new FinalizedFeatureKey(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class FinalizedFeatureKey : ISerialize
		{
			internal FinalizedFeatureKey(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 3 ? 
					_name.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_maxVersionLevel.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_minVersionLevel.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<FinalizedFeatureKey> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FinalizedFeatureKey(version);
				if (instance.Version >= 3) 
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.MaxVersionLevel = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.MinVersionLevel = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FinalizedFeatureKey is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 3)
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _maxVersionLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _minVersionLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public FinalizedFeatureKey WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _maxVersionLevel = Int16.Default;
			/// <summary>
			/// <para>The cluster-wide finalized max version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MaxVersionLevel 
			{
				get => _maxVersionLevel;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"MaxVersionLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_maxVersionLevel = value;
				}
			}

			/// <summary>
			/// <para>The cluster-wide finalized max version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public FinalizedFeatureKey WithMaxVersionLevel(Int16 maxVersionLevel)
			{
				MaxVersionLevel = maxVersionLevel;
				return this;
			}

			private Int16 _minVersionLevel = Int16.Default;
			/// <summary>
			/// <para>The cluster-wide finalized min version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MinVersionLevel 
			{
				get => _minVersionLevel;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"MinVersionLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_minVersionLevel = value;
				}
			}

			/// <summary>
			/// <para>The cluster-wide finalized min version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public FinalizedFeatureKey WithMinVersionLevel(Int16 minVersionLevel)
			{
				MinVersionLevel = minVersionLevel;
				return this;
			}
		}

		private bool _zkMigrationReadyIsSet;
		private Boolean _zkMigrationReady = new Boolean(false);
		/// <summary>
		/// <para>Set by a KRaft controller if the required configurations for ZK migration are present</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean ZkMigrationReady 
		{
			get => _zkMigrationReady;
			private set 
			{
				_zkMigrationReady = value;
				_zkMigrationReadyIsSet = true;
			}
		}

		/// <summary>
		/// <para>Set by a KRaft controller if the required configurations for ZK migration are present</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: false</para>
		/// </summary>
		public ApiVersionsResponse WithZkMigrationReady(Boolean zkMigrationReady)
		{
			ZkMigrationReady = zkMigrationReady;
			return this;
		}
	}

	public class AssignReplicasToDirsRequest : Message, IRespond<AssignReplicasToDirsResponse>
	{
		public AssignReplicasToDirsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AssignReplicasToDirsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(73);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			_brokerEpoch.GetSize(IsFlexibleVersion) +
			_directoriesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AssignReplicasToDirsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AssignReplicasToDirsRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.DirectoriesCollection = await Array<DirectoryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DirectoryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AssignReplicasToDirsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _directoriesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public AssignReplicasToDirsRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Array<DirectoryData> _directoriesCollection = Array.Empty<DirectoryData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DirectoryData> DirectoriesCollection 
		{
			get => _directoriesCollection;
			private set 
			{
				_directoriesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsRequest WithDirectoriesCollection(params Func<DirectoryData, DirectoryData>[] createFields)
		{
			DirectoriesCollection = createFields
				.Select(createField => createField(new DirectoryData(Version)))
				.ToArray();
			return this;
		}

		public delegate DirectoryData CreateDirectoryData(DirectoryData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsRequest WithDirectoriesCollection(IEnumerable<CreateDirectoryData> createFields)
		{
			DirectoriesCollection = createFields
				.Select(createField => createField(new DirectoryData(Version)))
				.ToArray();
			return this;
		}

		public class DirectoryData : ISerialize
		{
			internal DirectoryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_id.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DirectoryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DirectoryData(version);
				instance.Id = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DirectoryData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _id.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _id = Uuid.Default;
			/// <summary>
			/// <para>The ID of the directory</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid Id 
			{
				get => _id;
				private set 
				{
					_id = value;
				}
			}

			/// <summary>
			/// <para>The ID of the directory</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DirectoryData WithId(Uuid id)
			{
				Id = id;
				return this;
			}

			private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TopicData> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DirectoryData WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new TopicData(Version)))
					.ToArray();
				return this;
			}

			public delegate TopicData CreateTopicData(TopicData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DirectoryData WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new TopicData(Version)))
					.ToArray();
				return this;
			}

			public class TopicData : ISerialize
			{
				internal TopicData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_topicId.GetSize(IsFlexibleVersion) +
					_partitionsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TopicData(version);
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Uuid _topicId = Uuid.Default;
				/// <summary>
				/// <para>The ID of the assigned topic</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Uuid TopicId 
				{
					get => _topicId;
					private set 
					{
						_topicId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the assigned topic</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithTopicId(Uuid topicId)
				{
					TopicId = topicId;
					return this;
				}

				private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<PartitionData> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new PartitionData(Version)))
						.ToArray();
					return this;
				}

				public delegate PartitionData CreatePartitionData(PartitionData field);

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new PartitionData(Version)))
						.ToArray();
					return this;
				}

				public class PartitionData : ISerialize
				{
					internal PartitionData(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_partitionIndex.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new PartitionData(version);
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						private set 
						{
							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public PartitionData WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}
				}
			}
		}

		public AssignReplicasToDirsResponse Respond()
			=> new AssignReplicasToDirsResponse(Version);
	}

	public class AssignReplicasToDirsResponse : Message
	{
		public AssignReplicasToDirsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"AssignReplicasToDirsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(73);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_directoriesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<AssignReplicasToDirsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AssignReplicasToDirsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.DirectoriesCollection = await Array<DirectoryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DirectoryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AssignReplicasToDirsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _directoriesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<DirectoryData> _directoriesCollection = Array.Empty<DirectoryData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DirectoryData> DirectoriesCollection 
		{
			get => _directoriesCollection;
			private set 
			{
				_directoriesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsResponse WithDirectoriesCollection(params Func<DirectoryData, DirectoryData>[] createFields)
		{
			DirectoriesCollection = createFields
				.Select(createField => createField(new DirectoryData(Version)))
				.ToArray();
			return this;
		}

		public delegate DirectoryData CreateDirectoryData(DirectoryData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AssignReplicasToDirsResponse WithDirectoriesCollection(IEnumerable<CreateDirectoryData> createFields)
		{
			DirectoriesCollection = createFields
				.Select(createField => createField(new DirectoryData(Version)))
				.ToArray();
			return this;
		}

		public class DirectoryData : ISerialize
		{
			internal DirectoryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_id.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DirectoryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DirectoryData(version);
				instance.Id = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DirectoryData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _id.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _id = Uuid.Default;
			/// <summary>
			/// <para>The ID of the directory</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid Id 
			{
				get => _id;
				private set 
				{
					_id = value;
				}
			}

			/// <summary>
			/// <para>The ID of the directory</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DirectoryData WithId(Uuid id)
			{
				Id = id;
				return this;
			}

			private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TopicData> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DirectoryData WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new TopicData(Version)))
					.ToArray();
				return this;
			}

			public delegate TopicData CreateTopicData(TopicData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DirectoryData WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new TopicData(Version)))
					.ToArray();
				return this;
			}

			public class TopicData : ISerialize
			{
				internal TopicData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_topicId.GetSize(IsFlexibleVersion) +
					_partitionsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TopicData(version);
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Uuid _topicId = Uuid.Default;
				/// <summary>
				/// <para>The ID of the assigned topic</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Uuid TopicId 
				{
					get => _topicId;
					private set 
					{
						_topicId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the assigned topic</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithTopicId(Uuid topicId)
				{
					TopicId = topicId;
					return this;
				}

				private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<PartitionData> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new PartitionData(Version)))
						.ToArray();
					return this;
				}

				public delegate PartitionData CreatePartitionData(PartitionData field);

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new PartitionData(Version)))
						.ToArray();
					return this;
				}

				public class PartitionData : ISerialize
				{
					internal PartitionData(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_partitionIndex.GetSize(IsFlexibleVersion) +
						_errorCode.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new PartitionData(version);
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						private set 
						{
							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public PartitionData WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int16 _errorCode = Int16.Default;
					/// <summary>
					/// <para>The partition level error code</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int16 ErrorCode 
					{
						get => _errorCode;
						private set 
						{
							_errorCode = value;
						}
					}

					/// <summary>
					/// <para>The partition level error code</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public PartitionData WithErrorCode(Int16 errorCode)
					{
						ErrorCode = errorCode;
						return this;
					}
				}
			}
		}
	}

	public class BeginQuorumEpochRequest : Message, IRespond<BeginQuorumEpochResponse>
	{
		public BeginQuorumEpochRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"BeginQuorumEpochRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(53);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clusterId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<BeginQuorumEpochRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BeginQuorumEpochRequest(version);
			instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BeginQuorumEpochRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _clusterId = new NullableString(null);
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public BeginQuorumEpochRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochRequest WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = false;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The epoch of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}

		public BeginQuorumEpochResponse Respond()
			=> new BeginQuorumEpochResponse(Version);
	}

	public class BeginQuorumEpochResponse : Message
	{
		public BeginQuorumEpochResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"BeginQuorumEpochResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(53);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<BeginQuorumEpochResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BeginQuorumEpochResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BeginQuorumEpochResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochResponse WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = false;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}
	}

	public class BrokerHeartbeatRequest : Message, IRespond<BrokerHeartbeatResponse>
	{
		public BrokerHeartbeatRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"BrokerHeartbeatRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(63);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (Version >= 1 && _offlineLogDirsCollectionIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _offlineLogDirsCollection
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			_brokerEpoch.GetSize(IsFlexibleVersion) +
			_currentMetadataOffset.GetSize(IsFlexibleVersion) +
			_wantFence.GetSize(IsFlexibleVersion) +
			_wantShutDown.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<BrokerHeartbeatRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerHeartbeatRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.CurrentMetadataOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.WantFence = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.WantShutDown = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version >= 1) 
								instance.OfflineLogDirsCollection = await Array<Uuid>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field OfflineLogDirsCollection is not supported for version {instance.Version}");
							{
								var size = instance._offlineLogDirsCollection.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field OfflineLogDirsCollection read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerHeartbeatRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _currentMetadataOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _wantFence.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _wantShutDown.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public BrokerHeartbeatRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Int64 _currentMetadataOffset = Int64.Default;
		/// <summary>
		/// <para>The highest metadata offset which the broker has reached.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 CurrentMetadataOffset 
		{
			get => _currentMetadataOffset;
			private set 
			{
				_currentMetadataOffset = value;
			}
		}

		/// <summary>
		/// <para>The highest metadata offset which the broker has reached.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithCurrentMetadataOffset(Int64 currentMetadataOffset)
		{
			CurrentMetadataOffset = currentMetadataOffset;
			return this;
		}

		private Boolean _wantFence = Boolean.Default;
		/// <summary>
		/// <para>True if the broker wants to be fenced, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean WantFence 
		{
			get => _wantFence;
			private set 
			{
				_wantFence = value;
			}
		}

		/// <summary>
		/// <para>True if the broker wants to be fenced, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithWantFence(Boolean wantFence)
		{
			WantFence = wantFence;
			return this;
		}

		private Boolean _wantShutDown = Boolean.Default;
		/// <summary>
		/// <para>True if the broker wants to be shut down, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean WantShutDown 
		{
			get => _wantShutDown;
			private set 
			{
				_wantShutDown = value;
			}
		}

		/// <summary>
		/// <para>True if the broker wants to be shut down, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithWantShutDown(Boolean wantShutDown)
		{
			WantShutDown = wantShutDown;
			return this;
		}

		private bool _offlineLogDirsCollectionIsSet;
		private Array<Uuid> _offlineLogDirsCollection = Array.Empty<Uuid>();
		/// <summary>
		/// <para>Log directories that failed and went offline.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Array<Uuid> OfflineLogDirsCollection 
		{
			get => _offlineLogDirsCollection;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"OfflineLogDirsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_offlineLogDirsCollection = value;
				_offlineLogDirsCollectionIsSet = true;
			}
		}

		/// <summary>
		/// <para>Log directories that failed and went offline.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithOfflineLogDirsCollection(Array<Uuid> offlineLogDirsCollection)
		{
			OfflineLogDirsCollection = offlineLogDirsCollection;
			return this;
		}

		public BrokerHeartbeatResponse Respond()
			=> new BrokerHeartbeatResponse(Version);
	}

	public class BrokerHeartbeatResponse : Message
	{
		public BrokerHeartbeatResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"BrokerHeartbeatResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(63);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_isCaughtUp.GetSize(IsFlexibleVersion) +
			_isFenced.GetSize(IsFlexibleVersion) +
			_shouldShutDown.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<BrokerHeartbeatResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerHeartbeatResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.IsCaughtUp = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.IsFenced = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ShouldShutDown = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerHeartbeatResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _isCaughtUp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _isFenced.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _shouldShutDown.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Boolean _isCaughtUp = new Boolean(false);
		/// <summary>
		/// <para>True if the broker has approximately caught up with the latest metadata.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IsCaughtUp 
		{
			get => _isCaughtUp;
			private set 
			{
				_isCaughtUp = value;
			}
		}

		/// <summary>
		/// <para>True if the broker has approximately caught up with the latest metadata.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: false</para>
		/// </summary>
		public BrokerHeartbeatResponse WithIsCaughtUp(Boolean isCaughtUp)
		{
			IsCaughtUp = isCaughtUp;
			return this;
		}

		private Boolean _isFenced = new Boolean(true);
		/// <summary>
		/// <para>True if the broker is fenced.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: true</para>
		/// </summary>
		public Boolean IsFenced 
		{
			get => _isFenced;
			private set 
			{
				_isFenced = value;
			}
		}

		/// <summary>
		/// <para>True if the broker is fenced.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: true</para>
		/// </summary>
		public BrokerHeartbeatResponse WithIsFenced(Boolean isFenced)
		{
			IsFenced = isFenced;
			return this;
		}

		private Boolean _shouldShutDown = Boolean.Default;
		/// <summary>
		/// <para>True if the broker should proceed with its shutdown.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ShouldShutDown 
		{
			get => _shouldShutDown;
			private set 
			{
				_shouldShutDown = value;
			}
		}

		/// <summary>
		/// <para>True if the broker should proceed with its shutdown.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatResponse WithShouldShutDown(Boolean shouldShutDown)
		{
			ShouldShutDown = shouldShutDown;
			return this;
		}
	}

	public class BrokerRegistrationRequest : Message, IRespond<BrokerRegistrationResponse>
	{
		public BrokerRegistrationRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"BrokerRegistrationRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(62);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			_clusterId.GetSize(IsFlexibleVersion) +
			_incarnationId.GetSize(IsFlexibleVersion) +
			_listenersCollection.GetSize(IsFlexibleVersion) +
			_featuresCollection.GetSize(IsFlexibleVersion) +
			_rack.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_isMigratingZkBroker.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 2 ? 
				_logDirsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_previousBrokerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<BrokerRegistrationRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerRegistrationRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.IncarnationId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ListenersCollection = await Map<String, Listener>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Listener.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.FeaturesCollection = await Map<String, Feature>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Feature.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.IsMigratingZkBroker = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.LogDirsCollection = await Array<Uuid>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.PreviousBrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerRegistrationRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _incarnationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _listenersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _featuresCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _isMigratingZkBroker.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _logDirsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _previousBrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>The cluster id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The cluster id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Uuid _incarnationId = Uuid.Default;
		/// <summary>
		/// <para>The incarnation id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid IncarnationId 
		{
			get => _incarnationId;
			private set 
			{
				_incarnationId = value;
			}
		}

		/// <summary>
		/// <para>The incarnation id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithIncarnationId(Uuid incarnationId)
		{
			IncarnationId = incarnationId;
			return this;
		}

		private Map<String, Listener> _listenersCollection = Map<String, Listener>.Default;
		/// <summary>
		/// <para>The listeners of this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, Listener> ListenersCollection 
		{
			get => _listenersCollection;
			private set 
			{
				_listenersCollection = value;
			}
		}

		/// <summary>
		/// <para>The listeners of this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithListenersCollection(params Func<Listener, Listener>[] createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate Listener CreateListener(Listener field);

		/// <summary>
		/// <para>The listeners of this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithListenersCollection(IEnumerable<CreateListener> createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class Listener : ISerialize
		{
			internal Listener(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				_securityProtocol.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Listener> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Listener(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.SecurityProtocol = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Listener is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _securityProtocol.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the endpoint.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the endpoint.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithName(String name)
			{
				Name = name;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithHost(String host)
			{
				Host = host;
				return this;
			}

			private UInt16 _port = UInt16.Default;
			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UInt16 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithPort(UInt16 port)
			{
				Port = port;
				return this;
			}

			private Int16 _securityProtocol = Int16.Default;
			/// <summary>
			/// <para>The security protocol.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 SecurityProtocol 
			{
				get => _securityProtocol;
				private set 
				{
					_securityProtocol = value;
				}
			}

			/// <summary>
			/// <para>The security protocol.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithSecurityProtocol(Int16 securityProtocol)
			{
				SecurityProtocol = securityProtocol;
				return this;
			}
		}

		private Map<String, Feature> _featuresCollection = Map<String, Feature>.Default;
		/// <summary>
		/// <para>The features on this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, Feature> FeaturesCollection 
		{
			get => _featuresCollection;
			private set 
			{
				_featuresCollection = value;
			}
		}

		/// <summary>
		/// <para>The features on this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithFeaturesCollection(params Func<Feature, Feature>[] createFields)
		{
			FeaturesCollection = createFields
				.Select(createField => createField(new Feature(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate Feature CreateFeature(Feature field);

		/// <summary>
		/// <para>The features on this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithFeaturesCollection(IEnumerable<CreateFeature> createFields)
		{
			FeaturesCollection = createFields
				.Select(createField => createField(new Feature(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class Feature : ISerialize
		{
			internal Feature(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_minSupportedVersion.GetSize(IsFlexibleVersion) +
				_maxSupportedVersion.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Feature> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Feature(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MinSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MaxSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Feature is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _minSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _maxSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The feature name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The feature name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _minSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MinSupportedVersion 
			{
				get => _minSupportedVersion;
				private set 
				{
					_minSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithMinSupportedVersion(Int16 minSupportedVersion)
			{
				MinSupportedVersion = minSupportedVersion;
				return this;
			}

			private Int16 _maxSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxSupportedVersion 
			{
				get => _maxSupportedVersion;
				private set 
				{
					_maxSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithMaxSupportedVersion(Int16 maxSupportedVersion)
			{
				MaxSupportedVersion = maxSupportedVersion;
				return this;
			}
		}

		private NullableString _rack = NullableString.Default;
		/// <summary>
		/// <para>The rack which this broker is in.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? Rack 
		{
			get => _rack;
			private set 
			{
				_rack = value;
			}
		}

		/// <summary>
		/// <para>The rack which this broker is in.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithRack(String? rack)
		{
			Rack = rack;
			return this;
		}

		private Boolean _isMigratingZkBroker = new Boolean(false);
		/// <summary>
		/// <para>If the required configurations for ZK migration are present, this value is set to true</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IsMigratingZkBroker 
		{
			get => _isMigratingZkBroker;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"IsMigratingZkBroker does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_isMigratingZkBroker = value;
			}
		}

		/// <summary>
		/// <para>If the required configurations for ZK migration are present, this value is set to true</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public BrokerRegistrationRequest WithIsMigratingZkBroker(Boolean isMigratingZkBroker)
		{
			IsMigratingZkBroker = isMigratingZkBroker;
			return this;
		}

		private Array<Uuid> _logDirsCollection = Array.Empty<Uuid>();
		/// <summary>
		/// <para>Log directories configured in this broker which are available.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Array<Uuid> LogDirsCollection 
		{
			get => _logDirsCollection;
			private set 
			{
				_logDirsCollection = value;
			}
		}

		/// <summary>
		/// <para>Log directories configured in this broker which are available.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public BrokerRegistrationRequest WithLogDirsCollection(Array<Uuid> logDirsCollection)
		{
			LogDirsCollection = logDirsCollection;
			return this;
		}

		private Int64 _previousBrokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The epoch before a clean shutdown.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 PreviousBrokerEpoch 
		{
			get => _previousBrokerEpoch;
			private set 
			{
				_previousBrokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The epoch before a clean shutdown.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public BrokerRegistrationRequest WithPreviousBrokerEpoch(Int64 previousBrokerEpoch)
		{
			PreviousBrokerEpoch = previousBrokerEpoch;
			return this;
		}

		public BrokerRegistrationResponse Respond()
			=> new BrokerRegistrationResponse(Version);
	}

	public class BrokerRegistrationResponse : Message
	{
		public BrokerRegistrationResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"BrokerRegistrationResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(62);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_brokerEpoch.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<BrokerRegistrationResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerRegistrationResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerRegistrationResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker's assigned epoch, or -1 if none was assigned.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker's assigned epoch, or -1 if none was assigned.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public BrokerRegistrationResponse WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}
	}

	public class ConsumerGroupDescribeRequest : Message, IRespond<ConsumerGroupDescribeResponse>
	{
		public ConsumerGroupDescribeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ConsumerGroupDescribeRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(69);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupIdsCollection.GetSize(IsFlexibleVersion) +
			_includeAuthorizedOperations.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ConsumerGroupDescribeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ConsumerGroupDescribeRequest(version);
			instance.GroupIdsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.IncludeAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerGroupDescribeRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupIdsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _includeAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _groupIdsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The ids of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> GroupIdsCollection 
		{
			get => _groupIdsCollection;
			private set 
			{
				_groupIdsCollection = value;
			}
		}

		/// <summary>
		/// <para>The ids of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupDescribeRequest WithGroupIdsCollection(Array<String> groupIdsCollection)
		{
			GroupIdsCollection = groupIdsCollection;
			return this;
		}

		private Boolean _includeAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean IncludeAuthorizedOperations 
		{
			get => _includeAuthorizedOperations;
			private set 
			{
				_includeAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupDescribeRequest WithIncludeAuthorizedOperations(Boolean includeAuthorizedOperations)
		{
			IncludeAuthorizedOperations = includeAuthorizedOperations;
			return this;
		}

		public ConsumerGroupDescribeResponse Respond()
			=> new ConsumerGroupDescribeResponse(Version);
	}

	public class ConsumerGroupDescribeResponse : Message
	{
		public ConsumerGroupDescribeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ConsumerGroupDescribeResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(69);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_groupsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ConsumerGroupDescribeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ConsumerGroupDescribeResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GroupsCollection = await Array<DescribedGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerGroupDescribeResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupDescribeResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<DescribedGroup> _groupsCollection = Array.Empty<DescribedGroup>();
		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribedGroup> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupDescribeResponse WithGroupsCollection(params Func<DescribedGroup, DescribedGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new DescribedGroup(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribedGroup CreateDescribedGroup(DescribedGroup field);

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupDescribeResponse WithGroupsCollection(IEnumerable<CreateDescribedGroup> createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new DescribedGroup(Version)))
				.ToArray();
			return this;
		}

		public class DescribedGroup : ISerialize
		{
			internal DescribedGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_groupId.GetSize(IsFlexibleVersion) +
				_groupState.GetSize(IsFlexibleVersion) +
				_groupEpoch.GetSize(IsFlexibleVersion) +
				_assignmentEpoch.GetSize(IsFlexibleVersion) +
				_assignorName.GetSize(IsFlexibleVersion) +
				_membersCollection.GetSize(IsFlexibleVersion) +
				_authorizedOperations.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribedGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribedGroup(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupState = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AssignmentEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AssignorName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MembersCollection = await Array<Member>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Member.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.AuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedGroup is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignmentEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignorName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _membersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _authorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = new NullableString(null);
			/// <summary>
			/// <para>The top-level error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The top-level error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DescribedGroup WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private String _groupState = String.Default;
			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupState 
			{
				get => _groupState;
				private set 
				{
					_groupState = value;
				}
			}

			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupState(String groupState)
			{
				GroupState = groupState;
				return this;
			}

			private Int32 _groupEpoch = Int32.Default;
			/// <summary>
			/// <para>The group epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 GroupEpoch 
			{
				get => _groupEpoch;
				private set 
				{
					_groupEpoch = value;
				}
			}

			/// <summary>
			/// <para>The group epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupEpoch(Int32 groupEpoch)
			{
				GroupEpoch = groupEpoch;
				return this;
			}

			private Int32 _assignmentEpoch = Int32.Default;
			/// <summary>
			/// <para>The assignment epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 AssignmentEpoch 
			{
				get => _assignmentEpoch;
				private set 
				{
					_assignmentEpoch = value;
				}
			}

			/// <summary>
			/// <para>The assignment epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithAssignmentEpoch(Int32 assignmentEpoch)
			{
				AssignmentEpoch = assignmentEpoch;
				return this;
			}

			private String _assignorName = String.Default;
			/// <summary>
			/// <para>The selected assignor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String AssignorName 
			{
				get => _assignorName;
				private set 
				{
					_assignorName = value;
				}
			}

			/// <summary>
			/// <para>The selected assignor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithAssignorName(String assignorName)
			{
				AssignorName = assignorName;
				return this;
			}

			private Array<Member> _membersCollection = Array.Empty<Member>();
			/// <summary>
			/// <para>The members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Member> MembersCollection 
			{
				get => _membersCollection;
				private set 
				{
					_membersCollection = value;
				}
			}

			/// <summary>
			/// <para>The members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(params Func<Member, Member>[] createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(new Member(Version)))
					.ToArray();
				return this;
			}

			public delegate Member CreateMember(Member field);

			/// <summary>
			/// <para>The members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(IEnumerable<CreateMember> createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(new Member(Version)))
					.ToArray();
				return this;
			}

			public class Member : ISerialize
			{
				internal Member(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_memberId.GetSize(IsFlexibleVersion) +
					_instanceId.GetSize(IsFlexibleVersion) +
					_rackId.GetSize(IsFlexibleVersion) +
					_memberEpoch.GetSize(IsFlexibleVersion) +
					_clientId.GetSize(IsFlexibleVersion) +
					_clientHost.GetSize(IsFlexibleVersion) +
					_subscribedTopicNamesCollection.GetSize(IsFlexibleVersion) +
					_subscribedTopicRegex.GetSize(IsFlexibleVersion) +
					_assignment.GetSize(IsFlexibleVersion) +
					_targetAssignment.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<Member> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new Member(version);
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.InstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.RackId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ClientId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ClientHost = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.SubscribedTopicNamesCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.SubscribedTopicRegex = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Assignment_ = await Assignment.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
					instance.TargetAssignment = await Assignment.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for Member is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _instanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _rackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _clientId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _clientHost.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _subscribedTopicNamesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _subscribedTopicRegex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _targetAssignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _memberId = String.Default;
				/// <summary>
				/// <para>The member ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String MemberId 
				{
					get => _memberId;
					private set 
					{
						_memberId = value;
					}
				}

				/// <summary>
				/// <para>The member ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithMemberId(String memberId)
				{
					MemberId = memberId;
					return this;
				}

				private NullableString _instanceId = new NullableString(null);
				/// <summary>
				/// <para>The member instance ID.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? InstanceId 
				{
					get => _instanceId;
					private set 
					{
						_instanceId = value;
					}
				}

				/// <summary>
				/// <para>The member instance ID.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Member WithInstanceId(String? instanceId)
				{
					InstanceId = instanceId;
					return this;
				}

				private NullableString _rackId = new NullableString(null);
				/// <summary>
				/// <para>The member rack ID.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? RackId 
				{
					get => _rackId;
					private set 
					{
						_rackId = value;
					}
				}

				/// <summary>
				/// <para>The member rack ID.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Member WithRackId(String? rackId)
				{
					RackId = rackId;
					return this;
				}

				private Int32 _memberEpoch = Int32.Default;
				/// <summary>
				/// <para>The current member epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 MemberEpoch 
				{
					get => _memberEpoch;
					private set 
					{
						_memberEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current member epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithMemberEpoch(Int32 memberEpoch)
				{
					MemberEpoch = memberEpoch;
					return this;
				}

				private String _clientId = String.Default;
				/// <summary>
				/// <para>The client ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientId 
				{
					get => _clientId;
					private set 
					{
						_clientId = value;
					}
				}

				/// <summary>
				/// <para>The client ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithClientId(String clientId)
				{
					ClientId = clientId;
					return this;
				}

				private String _clientHost = String.Default;
				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientHost 
				{
					get => _clientHost;
					private set 
					{
						_clientHost = value;
					}
				}

				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithClientHost(String clientHost)
				{
					ClientHost = clientHost;
					return this;
				}

				private Array<String> _subscribedTopicNamesCollection = Array.Empty<String>();
				/// <summary>
				/// <para>The subscribed topic names.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<String> SubscribedTopicNamesCollection 
				{
					get => _subscribedTopicNamesCollection;
					private set 
					{
						_subscribedTopicNamesCollection = value;
					}
				}

				/// <summary>
				/// <para>The subscribed topic names.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithSubscribedTopicNamesCollection(Array<String> subscribedTopicNamesCollection)
				{
					SubscribedTopicNamesCollection = subscribedTopicNamesCollection;
					return this;
				}

				private NullableString _subscribedTopicRegex = new NullableString(null);
				/// <summary>
				/// <para>the subscribed topic regex otherwise or null of not provided.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? SubscribedTopicRegex 
				{
					get => _subscribedTopicRegex;
					private set 
					{
						_subscribedTopicRegex = value;
					}
				}

				/// <summary>
				/// <para>the subscribed topic regex otherwise or null of not provided.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Member WithSubscribedTopicRegex(String? subscribedTopicRegex)
				{
					SubscribedTopicRegex = subscribedTopicRegex;
					return this;
				}

				private Assignment _assignment = default!;
				/// <summary>
				/// <para>The current assignment.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Assignment Assignment_ 
				{
					get => _assignment;
					private set 
					{
						_assignment = value;
					}
				}

				/// <summary>
				/// <para>The current assignment.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithAssignment_(Assignment assignment)
				{
					Assignment_ = assignment;
					return this;
				}

				private Assignment _targetAssignment = default!;
				/// <summary>
				/// <para>The target assignment.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Assignment TargetAssignment 
				{
					get => _targetAssignment;
					private set 
					{
						_targetAssignment = value;
					}
				}

				/// <summary>
				/// <para>The target assignment.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithTargetAssignment(Assignment targetAssignment)
				{
					TargetAssignment = targetAssignment;
					return this;
				}
			}

			private Int32 _authorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 AuthorizedOperations 
			{
				get => _authorizedOperations;
				private set 
				{
					_authorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public DescribedGroup WithAuthorizedOperations(Int32 authorizedOperations)
			{
				AuthorizedOperations = authorizedOperations;
				return this;
			}
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public class Assignment : ISerialize
		{
			internal Assignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicPartitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Assignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Assignment(version);
				instance.TopicPartitionsCollection = await Array<TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Assignment is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Array<TopicPartitions> _topicPartitionsCollection = Array.Empty<TopicPartitions>();
			/// <summary>
			/// <para>The assigned topic-partitions to the member.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TopicPartitions> TopicPartitionsCollection 
			{
				get => _topicPartitionsCollection;
				private set 
				{
					_topicPartitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The assigned topic-partitions to the member.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Assignment WithTopicPartitionsCollection(Array<TopicPartitions> topicPartitionsCollection)
			{
				TopicPartitionsCollection = topicPartitionsCollection;
				return this;
			}
		}
	}

	public class ConsumerGroupHeartbeatRequest : Message, IRespond<ConsumerGroupHeartbeatResponse>
	{
		public ConsumerGroupHeartbeatRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ConsumerGroupHeartbeatRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(68);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			_memberEpoch.GetSize(IsFlexibleVersion) +
			_instanceId.GetSize(IsFlexibleVersion) +
			_rackId.GetSize(IsFlexibleVersion) +
			_rebalanceTimeoutMs.GetSize(IsFlexibleVersion) +
			_subscribedTopicNamesCollection.GetSize(IsFlexibleVersion) +
			_serverAssignor.GetSize(IsFlexibleVersion) +
			_topicPartitionsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ConsumerGroupHeartbeatRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ConsumerGroupHeartbeatRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.InstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RackId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RebalanceTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.SubscribedTopicNamesCollection = await NullableArray<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.ServerAssignor = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicPartitionsCollection = await NullableArray<TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerGroupHeartbeatRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _instanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _rackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _rebalanceTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _subscribedTopicNamesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _serverAssignor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member id generated by the coordinator. The member id must be kept during the entire lifetime of the member.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member id generated by the coordinator. The member id must be kept during the entire lifetime of the member.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Int32 _memberEpoch = Int32.Default;
		/// <summary>
		/// <para>The current member epoch; 0 to join the group; -1 to leave the group; -2 to indicate that the static member will rejoin.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MemberEpoch 
		{
			get => _memberEpoch;
			private set 
			{
				_memberEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current member epoch; 0 to join the group; -1 to leave the group; -2 to indicate that the static member will rejoin.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithMemberEpoch(Int32 memberEpoch)
		{
			MemberEpoch = memberEpoch;
			return this;
		}

		private NullableString _instanceId = new NullableString(null);
		/// <summary>
		/// <para>null if not provided or if it didn't change since the last heartbeat; the instance Id otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? InstanceId 
		{
			get => _instanceId;
			private set 
			{
				_instanceId = value;
			}
		}

		/// <summary>
		/// <para>null if not provided or if it didn't change since the last heartbeat; the instance Id otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithInstanceId(String? instanceId)
		{
			InstanceId = instanceId;
			return this;
		}

		private NullableString _rackId = new NullableString(null);
		/// <summary>
		/// <para>null if not provided or if it didn't change since the last heartbeat; the rack ID of consumer otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? RackId 
		{
			get => _rackId;
			private set 
			{
				_rackId = value;
			}
		}

		/// <summary>
		/// <para>null if not provided or if it didn't change since the last heartbeat; the rack ID of consumer otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithRackId(String? rackId)
		{
			RackId = rackId;
			return this;
		}

		private Int32 _rebalanceTimeoutMs = new Int32(-1);
		/// <summary>
		/// <para>-1 if it didn't change since the last heartbeat; the maximum time in milliseconds that the coordinator will wait on the member to revoke its partitions otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 RebalanceTimeoutMs 
		{
			get => _rebalanceTimeoutMs;
			private set 
			{
				_rebalanceTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>-1 if it didn't change since the last heartbeat; the maximum time in milliseconds that the coordinator will wait on the member to revoke its partitions otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithRebalanceTimeoutMs(Int32 rebalanceTimeoutMs)
		{
			RebalanceTimeoutMs = rebalanceTimeoutMs;
			return this;
		}

		private NullableArray<String> _subscribedTopicNamesCollection = new NullableArray<String>(null);
		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the subscribed topic names otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Array<String>? SubscribedTopicNamesCollection 
		{
			get => _subscribedTopicNamesCollection;
			private set 
			{
				_subscribedTopicNamesCollection = value;
			}
		}

		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the subscribed topic names otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithSubscribedTopicNamesCollection(Array<String>? subscribedTopicNamesCollection)
		{
			SubscribedTopicNamesCollection = subscribedTopicNamesCollection;
			return this;
		}

		private NullableString _serverAssignor = new NullableString(null);
		/// <summary>
		/// <para>null if not used or if it didn't change since the last heartbeat; the server side assignor to use otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ServerAssignor 
		{
			get => _serverAssignor;
			private set 
			{
				_serverAssignor = value;
			}
		}

		/// <summary>
		/// <para>null if not used or if it didn't change since the last heartbeat; the server side assignor to use otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithServerAssignor(String? serverAssignor)
		{
			ServerAssignor = serverAssignor;
			return this;
		}

		private NullableArray<TopicPartitions> _topicPartitionsCollection = new NullableArray<TopicPartitions>(null);
		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the partitions owned by the member.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Array<TopicPartitions>? TopicPartitionsCollection 
		{
			get => _topicPartitionsCollection;
			private set 
			{
				_topicPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the partitions owned by the member.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithTopicPartitionsCollection(params Func<TopicPartitions, TopicPartitions>[] createFields)
		{
			TopicPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartitions(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicPartitions CreateTopicPartitions(TopicPartitions field);

		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the partitions owned by the member.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatRequest WithTopicPartitionsCollection(IEnumerable<CreateTopicPartitions> createFields)
		{
			TopicPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartitions(Version)))
				.ToArray();
			return this;
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public ConsumerGroupHeartbeatResponse Respond()
			=> new ConsumerGroupHeartbeatResponse(Version);
	}

	public class ConsumerGroupHeartbeatResponse : Message
	{
		public ConsumerGroupHeartbeatResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ConsumerGroupHeartbeatResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(68);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			_memberEpoch.GetSize(IsFlexibleVersion) +
			_heartbeatIntervalMs.GetSize(IsFlexibleVersion) +
			_assignment.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ConsumerGroupHeartbeatResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ConsumerGroupHeartbeatResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.HeartbeatIntervalMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Assignment_ = await Nullable<Assignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Assignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerGroupHeartbeatResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _heartbeatIntervalMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = new NullableString(null);
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private NullableString _memberId = new NullableString(null);
		/// <summary>
		/// <para>The member id generated by the coordinator. Only provided when the member joins with MemberEpoch == 0.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member id generated by the coordinator. Only provided when the member joins with MemberEpoch == 0.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithMemberId(String? memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Int32 _memberEpoch = Int32.Default;
		/// <summary>
		/// <para>The member epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MemberEpoch 
		{
			get => _memberEpoch;
			private set 
			{
				_memberEpoch = value;
			}
		}

		/// <summary>
		/// <para>The member epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithMemberEpoch(Int32 memberEpoch)
		{
			MemberEpoch = memberEpoch;
			return this;
		}

		private Int32 _heartbeatIntervalMs = Int32.Default;
		/// <summary>
		/// <para>The heartbeat interval in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 HeartbeatIntervalMs 
		{
			get => _heartbeatIntervalMs;
			private set 
			{
				_heartbeatIntervalMs = value;
			}
		}

		/// <summary>
		/// <para>The heartbeat interval in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithHeartbeatIntervalMs(Int32 heartbeatIntervalMs)
		{
			HeartbeatIntervalMs = heartbeatIntervalMs;
			return this;
		}

		private Nullable<Assignment> _assignment = new Nullable<Assignment>(null);
		/// <summary>
		/// <para>null if not provided; the assignment otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Assignment? Assignment_ 
		{
			get => _assignment;
			private set 
			{
				_assignment = value;
			}
		}

		/// <summary>
		/// <para>null if not provided; the assignment otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerGroupHeartbeatResponse WithAssignment_(Func<Assignment?, Assignment?> createField)
		{
			Assignment_ = createField(new Assignment(Version));
			return this;
		}

		public class Assignment : ISerialize
		{
			internal Assignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicPartitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Assignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Assignment(version);
				instance.TopicPartitionsCollection = await Array<TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Assignment is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Array<TopicPartitions> _topicPartitionsCollection = Array.Empty<TopicPartitions>();
			/// <summary>
			/// <para>The partitions assigned to the member that can be used immediately.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TopicPartitions> TopicPartitionsCollection 
			{
				get => _topicPartitionsCollection;
				private set 
				{
					_topicPartitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions assigned to the member that can be used immediately.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Assignment WithTopicPartitionsCollection(Array<TopicPartitions> topicPartitionsCollection)
			{
				TopicPartitionsCollection = topicPartitionsCollection;
				return this;
			}
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}
	}

	public class ControlledShutdownRequest : Message, IRespond<ControlledShutdownResponse>
	{
		public ControlledShutdownRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ControlledShutdownRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(7);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				if (Version == 0)
					return 0;
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			(Version >= 2 ? 
				_brokerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ControlledShutdownRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ControlledShutdownRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ControlledShutdownRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The id of the broker for which controlled shutdown has been requested.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The id of the broker for which controlled shutdown has been requested.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ControlledShutdownRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		public ControlledShutdownResponse Respond()
			=> new ControlledShutdownResponse(Version);
	}

	public class ControlledShutdownResponse : Message
	{
		public ControlledShutdownResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ControlledShutdownResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(7);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_remainingPartitionsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ControlledShutdownResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ControlledShutdownResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RemainingPartitionsCollection = await Map<String, RemainingPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => RemainingPartition.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.TopicName, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ControlledShutdownResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _remainingPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Map<String, RemainingPartition> _remainingPartitionsCollection = Map<String, RemainingPartition>.Default;
		/// <summary>
		/// <para>The partitions that the broker still leads.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, RemainingPartition> RemainingPartitionsCollection 
		{
			get => _remainingPartitionsCollection;
			private set 
			{
				_remainingPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions that the broker still leads.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownResponse WithRemainingPartitionsCollection(params Func<RemainingPartition, RemainingPartition>[] createFields)
		{
			RemainingPartitionsCollection = createFields
				.Select(createField => createField(new RemainingPartition(Version)))
				.ToDictionary(field => field.TopicName);
			return this;
		}

		public delegate RemainingPartition CreateRemainingPartition(RemainingPartition field);

		/// <summary>
		/// <para>The partitions that the broker still leads.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownResponse WithRemainingPartitionsCollection(IEnumerable<CreateRemainingPartition> createFields)
		{
			RemainingPartitionsCollection = createFields
				.Select(createField => createField(new RemainingPartition(Version)))
				.ToDictionary(field => field.TopicName);
			return this;
		}

		public class RemainingPartition : ISerialize
		{
			internal RemainingPartition(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<RemainingPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new RemainingPartition(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for RemainingPartition is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public RemainingPartition WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The index of the partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The index of the partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public RemainingPartition WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}
		}
	}

	public class ControllerRegistrationRequest : Message, IRespond<ControllerRegistrationResponse>
	{
		public ControllerRegistrationRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ControllerRegistrationRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(70);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_controllerId.GetSize(IsFlexibleVersion) +
			_incarnationId.GetSize(IsFlexibleVersion) +
			_zkMigrationReady.GetSize(IsFlexibleVersion) +
			_listenersCollection.GetSize(IsFlexibleVersion) +
			_featuresCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ControllerRegistrationRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ControllerRegistrationRequest(version);
			instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.IncarnationId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ZkMigrationReady = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ListenersCollection = await Map<String, Listener>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Listener.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.FeaturesCollection = await Map<String, Feature>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Feature.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ControllerRegistrationRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _controllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _incarnationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _zkMigrationReady.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _listenersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _featuresCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The ID of the controller to register.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			private set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the controller to register.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Uuid _incarnationId = Uuid.Default;
		/// <summary>
		/// <para>The controller incarnation ID, which is unique to each process run.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid IncarnationId 
		{
			get => _incarnationId;
			private set 
			{
				_incarnationId = value;
			}
		}

		/// <summary>
		/// <para>The controller incarnation ID, which is unique to each process run.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithIncarnationId(Uuid incarnationId)
		{
			IncarnationId = incarnationId;
			return this;
		}

		private Boolean _zkMigrationReady = Boolean.Default;
		/// <summary>
		/// <para>Set if the required configurations for ZK migration are present.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ZkMigrationReady 
		{
			get => _zkMigrationReady;
			private set 
			{
				_zkMigrationReady = value;
			}
		}

		/// <summary>
		/// <para>Set if the required configurations for ZK migration are present.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithZkMigrationReady(Boolean zkMigrationReady)
		{
			ZkMigrationReady = zkMigrationReady;
			return this;
		}

		private Map<String, Listener> _listenersCollection = Map<String, Listener>.Default;
		/// <summary>
		/// <para>The listeners of this controller</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, Listener> ListenersCollection 
		{
			get => _listenersCollection;
			private set 
			{
				_listenersCollection = value;
			}
		}

		/// <summary>
		/// <para>The listeners of this controller</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithListenersCollection(params Func<Listener, Listener>[] createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate Listener CreateListener(Listener field);

		/// <summary>
		/// <para>The listeners of this controller</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithListenersCollection(IEnumerable<CreateListener> createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class Listener : ISerialize
		{
			internal Listener(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				_securityProtocol.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Listener> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Listener(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.SecurityProtocol = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Listener is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _securityProtocol.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the endpoint.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the endpoint.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithName(String name)
			{
				Name = name;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithHost(String host)
			{
				Host = host;
				return this;
			}

			private UInt16 _port = UInt16.Default;
			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UInt16 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithPort(UInt16 port)
			{
				Port = port;
				return this;
			}

			private Int16 _securityProtocol = Int16.Default;
			/// <summary>
			/// <para>The security protocol.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 SecurityProtocol 
			{
				get => _securityProtocol;
				private set 
				{
					_securityProtocol = value;
				}
			}

			/// <summary>
			/// <para>The security protocol.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithSecurityProtocol(Int16 securityProtocol)
			{
				SecurityProtocol = securityProtocol;
				return this;
			}
		}

		private Map<String, Feature> _featuresCollection = Map<String, Feature>.Default;
		/// <summary>
		/// <para>The features on this controller</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, Feature> FeaturesCollection 
		{
			get => _featuresCollection;
			private set 
			{
				_featuresCollection = value;
			}
		}

		/// <summary>
		/// <para>The features on this controller</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithFeaturesCollection(params Func<Feature, Feature>[] createFields)
		{
			FeaturesCollection = createFields
				.Select(createField => createField(new Feature(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate Feature CreateFeature(Feature field);

		/// <summary>
		/// <para>The features on this controller</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationRequest WithFeaturesCollection(IEnumerable<CreateFeature> createFields)
		{
			FeaturesCollection = createFields
				.Select(createField => createField(new Feature(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class Feature : ISerialize
		{
			internal Feature(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_minSupportedVersion.GetSize(IsFlexibleVersion) +
				_maxSupportedVersion.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Feature> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Feature(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MinSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MaxSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Feature is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _minSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _maxSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The feature name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The feature name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _minSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MinSupportedVersion 
			{
				get => _minSupportedVersion;
				private set 
				{
					_minSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithMinSupportedVersion(Int16 minSupportedVersion)
			{
				MinSupportedVersion = minSupportedVersion;
				return this;
			}

			private Int16 _maxSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxSupportedVersion 
			{
				get => _maxSupportedVersion;
				private set 
				{
					_maxSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithMaxSupportedVersion(Int16 maxSupportedVersion)
			{
				MaxSupportedVersion = maxSupportedVersion;
				return this;
			}
		}

		public ControllerRegistrationResponse Respond()
			=> new ControllerRegistrationResponse(Version);
	}

	public class ControllerRegistrationResponse : Message
	{
		public ControllerRegistrationResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ControllerRegistrationResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(70);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ControllerRegistrationResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ControllerRegistrationResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ControllerRegistrationResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The response error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The response error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControllerRegistrationResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}
	}

	public class CreateAclsRequest : Message, IRespond<CreateAclsResponse>
	{
		public CreateAclsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreateAclsRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(30);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_creationsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreateAclsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateAclsRequest(version);
			instance.CreationsCollection = await Array<AclCreation>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AclCreation.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateAclsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _creationsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<AclCreation> _creationsCollection = Array.Empty<AclCreation>();
		/// <summary>
		/// <para>The ACLs that we want to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AclCreation> CreationsCollection 
		{
			get => _creationsCollection;
			private set 
			{
				_creationsCollection = value;
			}
		}

		/// <summary>
		/// <para>The ACLs that we want to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsRequest WithCreationsCollection(params Func<AclCreation, AclCreation>[] createFields)
		{
			CreationsCollection = createFields
				.Select(createField => createField(new AclCreation(Version)))
				.ToArray();
			return this;
		}

		public delegate AclCreation CreateAclCreation(AclCreation field);

		/// <summary>
		/// <para>The ACLs that we want to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsRequest WithCreationsCollection(IEnumerable<CreateAclCreation> createFields)
		{
			CreationsCollection = createFields
				.Select(createField => createField(new AclCreation(Version)))
				.ToArray();
			return this;
		}

		public class AclCreation : ISerialize
		{
			internal AclCreation(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				(Version >= 1 ? 
					_resourcePatternType.GetSize(IsFlexibleVersion):
					0) +
				_principal.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_operation.GetSize(IsFlexibleVersion) +
				_permissionType.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AclCreation> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AclCreation(version);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.ResourcePatternType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Principal = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AclCreation is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _resourcePatternType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _principal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _permissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The type of the resource.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The type of the resource.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Int8 _resourcePatternType = new Int8(3);
			/// <summary>
			/// <para>The pattern type for the ACL.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public Int8 ResourcePatternType 
			{
				get => _resourcePatternType;
				private set 
				{
					if (Version >= 1 == false)
						throw new UnsupportedVersionException($"ResourcePatternType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

					_resourcePatternType = value;
				}
			}

			/// <summary>
			/// <para>The pattern type for the ACL.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public AclCreation WithResourcePatternType(Int8 resourcePatternType)
			{
				ResourcePatternType = resourcePatternType;
				return this;
			}

			private String _principal = String.Default;
			/// <summary>
			/// <para>The principal for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Principal 
			{
				get => _principal;
				private set 
				{
					_principal = value;
				}
			}

			/// <summary>
			/// <para>The principal for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithPrincipal(String principal)
			{
				Principal = principal;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The host for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The host for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int8 _operation = Int8.Default;
			/// <summary>
			/// <para>The operation type for the ACL (read, write, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Operation 
			{
				get => _operation;
				private set 
				{
					_operation = value;
				}
			}

			/// <summary>
			/// <para>The operation type for the ACL (read, write, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithOperation(Int8 operation)
			{
				Operation = operation;
				return this;
			}

			private Int8 _permissionType = Int8.Default;
			/// <summary>
			/// <para>The permission type for the ACL (allow, deny, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 PermissionType 
			{
				get => _permissionType;
				private set 
				{
					_permissionType = value;
				}
			}

			/// <summary>
			/// <para>The permission type for the ACL (allow, deny, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithPermissionType(Int8 permissionType)
			{
				PermissionType = permissionType;
				return this;
			}
		}

		public CreateAclsResponse Respond()
			=> new CreateAclsResponse(Version);
	}

	public class CreateAclsResponse : Message
	{
		public CreateAclsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreateAclsResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(30);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreateAclsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateAclsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<AclCreationResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AclCreationResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateAclsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<AclCreationResult> _resultsCollection = Array.Empty<AclCreationResult>();
		/// <summary>
		/// <para>The results for each ACL creation.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AclCreationResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each ACL creation.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsResponse WithResultsCollection(params Func<AclCreationResult, AclCreationResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new AclCreationResult(Version)))
				.ToArray();
			return this;
		}

		public delegate AclCreationResult CreateAclCreationResult(AclCreationResult field);

		/// <summary>
		/// <para>The results for each ACL creation.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsResponse WithResultsCollection(IEnumerable<CreateAclCreationResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new AclCreationResult(Version)))
				.ToArray();
			return this;
		}

		public class AclCreationResult : ISerialize
		{
			internal AclCreationResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AclCreationResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AclCreationResult(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AclCreationResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreationResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreationResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class CreateDelegationTokenRequest : Message, IRespond<CreateDelegationTokenResponse>
	{
		public CreateDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreateDelegationTokenRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(38);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_ownerPrincipalType.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_ownerPrincipalName.GetSize(IsFlexibleVersion):
				0) +
			_renewersCollection.GetSize(IsFlexibleVersion) +
			_maxLifetimeMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreateDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateDelegationTokenRequest(version);
			if (instance.Version >= 3) 
				instance.OwnerPrincipalType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.OwnerPrincipalName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RenewersCollection = await Array<CreatableRenewers>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableRenewers.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.MaxLifetimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _ownerPrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _ownerPrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _renewersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _maxLifetimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _ownerPrincipalType = NullableString.Default;
		/// <summary>
		/// <para>The principal type of the owner of the token. If it's null it defaults to the token request principal.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String? OwnerPrincipalType 
		{
			get => _ownerPrincipalType;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"OwnerPrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"OwnerPrincipalType does not support null for version {Version}. Supported versions for null value: 3+");

				_ownerPrincipalType = value;
			}
		}

		/// <summary>
		/// <para>The principal type of the owner of the token. If it's null it defaults to the token request principal.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithOwnerPrincipalType(String? ownerPrincipalType)
		{
			OwnerPrincipalType = ownerPrincipalType;
			return this;
		}

		private NullableString _ownerPrincipalName = NullableString.Default;
		/// <summary>
		/// <para>The principal name of the owner of the token. If it's null it defaults to the token request principal.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String? OwnerPrincipalName 
		{
			get => _ownerPrincipalName;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"OwnerPrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"OwnerPrincipalName does not support null for version {Version}. Supported versions for null value: 3+");

				_ownerPrincipalName = value;
			}
		}

		/// <summary>
		/// <para>The principal name of the owner of the token. If it's null it defaults to the token request principal.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithOwnerPrincipalName(String? ownerPrincipalName)
		{
			OwnerPrincipalName = ownerPrincipalName;
			return this;
		}

		private Array<CreatableRenewers> _renewersCollection = Array.Empty<CreatableRenewers>();
		/// <summary>
		/// <para>A list of those who are allowed to renew this token before it expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<CreatableRenewers> RenewersCollection 
		{
			get => _renewersCollection;
			private set 
			{
				_renewersCollection = value;
			}
		}

		/// <summary>
		/// <para>A list of those who are allowed to renew this token before it expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithRenewersCollection(params Func<CreatableRenewers, CreatableRenewers>[] createFields)
		{
			RenewersCollection = createFields
				.Select(createField => createField(new CreatableRenewers(Version)))
				.ToArray();
			return this;
		}

		public delegate CreatableRenewers CreateCreatableRenewers(CreatableRenewers field);

		/// <summary>
		/// <para>A list of those who are allowed to renew this token before it expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithRenewersCollection(IEnumerable<CreateCreatableRenewers> createFields)
		{
			RenewersCollection = createFields
				.Select(createField => createField(new CreatableRenewers(Version)))
				.ToArray();
			return this;
		}

		public class CreatableRenewers : ISerialize
		{
			internal CreatableRenewers(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_principalType.GetSize(IsFlexibleVersion) +
				_principalName.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<CreatableRenewers> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatableRenewers(version);
				instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableRenewers is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _principalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _principalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _principalType = String.Default;
			/// <summary>
			/// <para>The type of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalType 
			{
				get => _principalType;
				private set 
				{
					_principalType = value;
				}
			}

			/// <summary>
			/// <para>The type of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableRenewers WithPrincipalType(String principalType)
			{
				PrincipalType = principalType;
				return this;
			}

			private String _principalName = String.Default;
			/// <summary>
			/// <para>The name of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalName 
			{
				get => _principalName;
				private set 
				{
					_principalName = value;
				}
			}

			/// <summary>
			/// <para>The name of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableRenewers WithPrincipalName(String principalName)
			{
				PrincipalName = principalName;
				return this;
			}
		}

		private Int64 _maxLifetimeMs = Int64.Default;
		/// <summary>
		/// <para>The maximum lifetime of the token in milliseconds, or -1 to use the server side default.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 MaxLifetimeMs 
		{
			get => _maxLifetimeMs;
			private set 
			{
				_maxLifetimeMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum lifetime of the token in milliseconds, or -1 to use the server side default.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithMaxLifetimeMs(Int64 maxLifetimeMs)
		{
			MaxLifetimeMs = maxLifetimeMs;
			return this;
		}

		public CreateDelegationTokenResponse Respond()
			=> new CreateDelegationTokenResponse(Version);
	}

	public class CreateDelegationTokenResponse : Message
	{
		public CreateDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreateDelegationTokenResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(38);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_principalType.GetSize(IsFlexibleVersion) +
			_principalName.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_tokenRequesterPrincipalType.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_tokenRequesterPrincipalName.GetSize(IsFlexibleVersion):
				0) +
			_issueTimestampMs.GetSize(IsFlexibleVersion) +
			_expiryTimestampMs.GetSize(IsFlexibleVersion) +
			_maxTimestampMs.GetSize(IsFlexibleVersion) +
			_tokenId.GetSize(IsFlexibleVersion) +
			_hmac.GetSize(IsFlexibleVersion) +
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreateDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateDelegationTokenResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.TokenRequesterPrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.TokenRequesterPrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.IssueTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ExpiryTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MaxTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TokenId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _principalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _principalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _tokenRequesterPrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _tokenRequesterPrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _issueTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _expiryTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _maxTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _tokenId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error, or zero if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error, or zero if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String _principalType = String.Default;
		/// <summary>
		/// <para>The principal type of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String PrincipalType 
		{
			get => _principalType;
			private set 
			{
				_principalType = value;
			}
		}

		/// <summary>
		/// <para>The principal type of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithPrincipalType(String principalType)
		{
			PrincipalType = principalType;
			return this;
		}

		private String _principalName = String.Default;
		/// <summary>
		/// <para>The name of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String PrincipalName 
		{
			get => _principalName;
			private set 
			{
				_principalName = value;
			}
		}

		/// <summary>
		/// <para>The name of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithPrincipalName(String principalName)
		{
			PrincipalName = principalName;
			return this;
		}

		private String _tokenRequesterPrincipalType = String.Default;
		/// <summary>
		/// <para>The principal type of the requester of the token.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String TokenRequesterPrincipalType 
		{
			get => _tokenRequesterPrincipalType;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"TokenRequesterPrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_tokenRequesterPrincipalType = value;
			}
		}

		/// <summary>
		/// <para>The principal type of the requester of the token.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithTokenRequesterPrincipalType(String tokenRequesterPrincipalType)
		{
			TokenRequesterPrincipalType = tokenRequesterPrincipalType;
			return this;
		}

		private String _tokenRequesterPrincipalName = String.Default;
		/// <summary>
		/// <para>The principal type of the requester of the token.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String TokenRequesterPrincipalName 
		{
			get => _tokenRequesterPrincipalName;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"TokenRequesterPrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_tokenRequesterPrincipalName = value;
			}
		}

		/// <summary>
		/// <para>The principal type of the requester of the token.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithTokenRequesterPrincipalName(String tokenRequesterPrincipalName)
		{
			TokenRequesterPrincipalName = tokenRequesterPrincipalName;
			return this;
		}

		private Int64 _issueTimestampMs = Int64.Default;
		/// <summary>
		/// <para>When this token was generated.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 IssueTimestampMs 
		{
			get => _issueTimestampMs;
			private set 
			{
				_issueTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>When this token was generated.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithIssueTimestampMs(Int64 issueTimestampMs)
		{
			IssueTimestampMs = issueTimestampMs;
			return this;
		}

		private Int64 _expiryTimestampMs = Int64.Default;
		/// <summary>
		/// <para>When this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimestampMs 
		{
			get => _expiryTimestampMs;
			private set 
			{
				_expiryTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>When this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithExpiryTimestampMs(Int64 expiryTimestampMs)
		{
			ExpiryTimestampMs = expiryTimestampMs;
			return this;
		}

		private Int64 _maxTimestampMs = Int64.Default;
		/// <summary>
		/// <para>The maximum lifetime of this token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 MaxTimestampMs 
		{
			get => _maxTimestampMs;
			private set 
			{
				_maxTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum lifetime of this token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithMaxTimestampMs(Int64 maxTimestampMs)
		{
			MaxTimestampMs = maxTimestampMs;
			return this;
		}

		private String _tokenId = String.Default;
		/// <summary>
		/// <para>The token UUID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TokenId 
		{
			get => _tokenId;
			private set 
			{
				_tokenId = value;
			}
		}

		/// <summary>
		/// <para>The token UUID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithTokenId(String tokenId)
		{
			TokenId = tokenId;
			return this;
		}

		private Bytes _hmac = Bytes.Default;
		/// <summary>
		/// <para>HMAC of the delegation token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Hmac 
		{
			get => _hmac;
			private set 
			{
				_hmac = value;
			}
		}

		/// <summary>
		/// <para>HMAC of the delegation token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithHmac(Bytes hmac)
		{
			Hmac = hmac;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class CreatePartitionsRequest : Message, IRespond<CreatePartitionsResponse>
	{
		public CreatePartitionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreatePartitionsRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(37);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			_validateOnly.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreatePartitionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreatePartitionsRequest(version);
			instance.TopicsCollection = await Map<String, CreatePartitionsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatePartitionsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _validateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<String, CreatePartitionsTopic> _topicsCollection = Map<String, CreatePartitionsTopic>.Default;
		/// <summary>
		/// <para>Each topic that we want to create new partitions inside.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, CreatePartitionsTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to create new partitions inside.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithTopicsCollection(params Func<CreatePartitionsTopic, CreatePartitionsTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new CreatePartitionsTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate CreatePartitionsTopic CreateCreatePartitionsTopic(CreatePartitionsTopic field);

		/// <summary>
		/// <para>Each topic that we want to create new partitions inside.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithTopicsCollection(IEnumerable<CreateCreatePartitionsTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new CreatePartitionsTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class CreatePartitionsTopic : ISerialize
		{
			internal CreatePartitionsTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_count.GetSize(IsFlexibleVersion) +
				_assignmentsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<CreatePartitionsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatePartitionsTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Count = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AssignmentsCollection = await NullableArray<CreatePartitionsAssignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatePartitionsAssignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _count.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignmentsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32 _count = Int32.Default;
			/// <summary>
			/// <para>The new partition count.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Count 
			{
				get => _count;
				private set 
				{
					_count = value;
				}
			}

			/// <summary>
			/// <para>The new partition count.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithCount(Int32 count)
			{
				Count = count;
				return this;
			}

			private NullableArray<CreatePartitionsAssignment> _assignmentsCollection = Array.Empty<CreatePartitionsAssignment>();
			/// <summary>
			/// <para>The new partition assignments.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<CreatePartitionsAssignment>? AssignmentsCollection 
			{
				get => _assignmentsCollection;
				private set 
				{
					_assignmentsCollection = value;
				}
			}

			/// <summary>
			/// <para>The new partition assignments.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithAssignmentsCollection(params Func<CreatePartitionsAssignment, CreatePartitionsAssignment>[] createFields)
			{
				AssignmentsCollection = createFields
					.Select(createField => createField(new CreatePartitionsAssignment(Version)))
					.ToArray();
				return this;
			}

			public delegate CreatePartitionsAssignment CreateCreatePartitionsAssignment(CreatePartitionsAssignment field);

			/// <summary>
			/// <para>The new partition assignments.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithAssignmentsCollection(IEnumerable<CreateCreatePartitionsAssignment> createFields)
			{
				AssignmentsCollection = createFields
					.Select(createField => createField(new CreatePartitionsAssignment(Version)))
					.ToArray();
				return this;
			}

			public class CreatePartitionsAssignment : ISerialize
			{
				internal CreatePartitionsAssignment(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_brokerIdsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<CreatePartitionsAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreatePartitionsAssignment(version);
					instance.BrokerIdsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsAssignment is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _brokerIdsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Array<Int32> _brokerIdsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The assigned broker IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> BrokerIdsCollection 
				{
					get => _brokerIdsCollection;
					private set 
					{
						_brokerIdsCollection = value;
					}
				}

				/// <summary>
				/// <para>The assigned broker IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreatePartitionsAssignment WithBrokerIdsCollection(Array<Int32> brokerIdsCollection)
				{
					BrokerIdsCollection = brokerIdsCollection;
					return this;
				}
			}
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>The time in ms to wait for the partitions to be created.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the partitions to be created.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>If true, then validate the request, but don't actually increase the number of partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			private set 
			{
				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>If true, then validate the request, but don't actually increase the number of partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public CreatePartitionsResponse Respond()
			=> new CreatePartitionsResponse(Version);
	}

	public class CreatePartitionsResponse : Message
	{
		public CreatePartitionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreatePartitionsResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(37);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreatePartitionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreatePartitionsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<CreatePartitionsTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatePartitionsTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<CreatePartitionsTopicResult> _resultsCollection = Array.Empty<CreatePartitionsTopicResult>();
		/// <summary>
		/// <para>The partition creation results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<CreatePartitionsTopicResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partition creation results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsResponse WithResultsCollection(params Func<CreatePartitionsTopicResult, CreatePartitionsTopicResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new CreatePartitionsTopicResult(Version)))
				.ToArray();
			return this;
		}

		public delegate CreatePartitionsTopicResult CreateCreatePartitionsTopicResult(CreatePartitionsTopicResult field);

		/// <summary>
		/// <para>The partition creation results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsResponse WithResultsCollection(IEnumerable<CreateCreatePartitionsTopicResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new CreatePartitionsTopicResult(Version)))
				.ToArray();
			return this;
		}

		public class CreatePartitionsTopicResult : ISerialize
		{
			internal CreatePartitionsTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<CreatePartitionsTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatePartitionsTopicResult(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopicResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = new NullableString(null);
			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public CreatePartitionsTopicResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class CreateTopicsRequest : Message, IRespond<CreateTopicsResponse>
	{
		public CreateTopicsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreateTopicsRequest does not support version {version}. Valid versions are: 0-7");

			Version = version;
			IsFlexibleVersion = version >= 5;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(19);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_validateOnly.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreateTopicsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateTopicsRequest(version);
			instance.TopicsCollection = await Map<String, CreatableTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateTopicsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _validateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<String, CreatableTopic> _topicsCollection = Map<String, CreatableTopic>.Default;
		/// <summary>
		/// <para>The topics to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, CreatableTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateTopicsRequest WithTopicsCollection(params Func<CreatableTopic, CreatableTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new CreatableTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate CreatableTopic CreateCreatableTopic(CreatableTopic field);

		/// <summary>
		/// <para>The topics to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateTopicsRequest WithTopicsCollection(IEnumerable<CreateCreatableTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new CreatableTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class CreatableTopic : ISerialize
		{
			internal CreatableTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 5;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_numPartitions.GetSize(IsFlexibleVersion) +
				_replicationFactor.GetSize(IsFlexibleVersion) +
				_assignmentsCollection.GetSize(IsFlexibleVersion) +
				_configsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<CreatableTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatableTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.NumPartitions = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ReplicationFactor = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AssignmentsCollection = await Map<Int32, CreatableReplicaAssignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableReplicaAssignment.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.PartitionIndex, cancellationToken).ConfigureAwait(false);
				instance.ConfigsCollection = await Map<String, CreateableTopicConfig>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreateableTopicConfig.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _numPartitions.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _replicationFactor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignmentsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _configsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32 _numPartitions = Int32.Default;
			/// <summary>
			/// <para>The number of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 NumPartitions 
			{
				get => _numPartitions;
				private set 
				{
					_numPartitions = value;
				}
			}

			/// <summary>
			/// <para>The number of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithNumPartitions(Int32 numPartitions)
			{
				NumPartitions = numPartitions;
				return this;
			}

			private Int16 _replicationFactor = Int16.Default;
			/// <summary>
			/// <para>The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ReplicationFactor 
			{
				get => _replicationFactor;
				private set 
				{
					_replicationFactor = value;
				}
			}

			/// <summary>
			/// <para>The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithReplicationFactor(Int16 replicationFactor)
			{
				ReplicationFactor = replicationFactor;
				return this;
			}

			private Map<Int32, CreatableReplicaAssignment> _assignmentsCollection = Map<Int32, CreatableReplicaAssignment>.Default;
			/// <summary>
			/// <para>The manual partition assignment, or the empty array if we are using automatic assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<Int32, CreatableReplicaAssignment> AssignmentsCollection 
			{
				get => _assignmentsCollection;
				private set 
				{
					_assignmentsCollection = value;
				}
			}

			/// <summary>
			/// <para>The manual partition assignment, or the empty array if we are using automatic assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithAssignmentsCollection(params Func<CreatableReplicaAssignment, CreatableReplicaAssignment>[] createFields)
			{
				AssignmentsCollection = createFields
					.Select(createField => createField(new CreatableReplicaAssignment(Version)))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			public delegate CreatableReplicaAssignment CreateCreatableReplicaAssignment(CreatableReplicaAssignment field);

			/// <summary>
			/// <para>The manual partition assignment, or the empty array if we are using automatic assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithAssignmentsCollection(IEnumerable<CreateCreatableReplicaAssignment> createFields)
			{
				AssignmentsCollection = createFields
					.Select(createField => createField(new CreatableReplicaAssignment(Version)))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			public class CreatableReplicaAssignment : ISerialize
			{
				internal CreatableReplicaAssignment(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 5;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_brokerIdsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<CreatableReplicaAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreatableReplicaAssignment(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.BrokerIdsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableReplicaAssignment is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _brokerIdsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreatableReplicaAssignment WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Array<Int32> _brokerIdsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The brokers to place the partition on.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> BrokerIdsCollection 
				{
					get => _brokerIdsCollection;
					private set 
					{
						_brokerIdsCollection = value;
					}
				}

				/// <summary>
				/// <para>The brokers to place the partition on.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreatableReplicaAssignment WithBrokerIdsCollection(Array<Int32> brokerIdsCollection)
				{
					BrokerIdsCollection = brokerIdsCollection;
					return this;
				}
			}

			private Map<String, CreateableTopicConfig> _configsCollection = Map<String, CreateableTopicConfig>.Default;
			/// <summary>
			/// <para>The custom topic configurations to set.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<String, CreateableTopicConfig> ConfigsCollection 
			{
				get => _configsCollection;
				private set 
				{
					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>The custom topic configurations to set.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithConfigsCollection(params Func<CreateableTopicConfig, CreateableTopicConfig>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new CreateableTopicConfig(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public delegate CreateableTopicConfig CreateCreateableTopicConfig(CreateableTopicConfig field);

			/// <summary>
			/// <para>The custom topic configurations to set.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithConfigsCollection(IEnumerable<CreateCreateableTopicConfig> createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new CreateableTopicConfig(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public class CreateableTopicConfig : ISerialize
			{
				internal CreateableTopicConfig(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 5;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_value.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<CreateableTopicConfig> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreateableTopicConfig(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateableTopicConfig is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreateableTopicConfig WithName(String name)
				{
					Name = name;
					return this;
				}

				private NullableString _value = NullableString.Default;
				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					private set 
					{
						_value = value;
					}
				}

				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreateableTopicConfig WithValue(String? value)
				{
					Value = value;
					return this;
				}
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public CreateTopicsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Boolean _validateOnly = new Boolean(false);
		/// <summary>
		/// <para>If true, check that the topics can be created as specified, but don't create anything.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>If true, check that the topics can be created as specified, but don't create anything.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public CreateTopicsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public CreateTopicsResponse Respond()
			=> new CreateTopicsResponse(Version);
	}

	public class CreateTopicsResponse : Message
	{
		public CreateTopicsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"CreateTopicsResponse does not support version {version}. Valid versions are: 0-7");

			Version = version;
			IsFlexibleVersion = version >= 5;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(19);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 2 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<CreateTopicsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateTopicsResponse(version);
			if (instance.Version >= 2) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<String, CreatableTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateTopicsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 2)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public CreateTopicsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<String, CreatableTopicResult> _topicsCollection = Map<String, CreatableTopicResult>.Default;
		/// <summary>
		/// <para>Results for each topic we tried to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, CreatableTopicResult> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Results for each topic we tried to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateTopicsResponse WithTopicsCollection(params Func<CreatableTopicResult, CreatableTopicResult>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new CreatableTopicResult(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate CreatableTopicResult CreateCreatableTopicResult(CreatableTopicResult field);

		/// <summary>
		/// <para>Results for each topic we tried to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateTopicsResponse WithTopicsCollection(IEnumerable<CreateCreatableTopicResult> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new CreatableTopicResult(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class CreatableTopicResult : ISerialize
		{
			internal CreatableTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 5;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				var tags = new List<Tags.TaggedField>();
				if (Version >= 5 && _topicConfigErrorCodeIsSet) 
					tags.Add(new Tags.TaggedField
					{
						Tag = 0,
						Field = _topicConfigErrorCode
					});
				return new Tags.TagSection(tags.ToArray());
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				(Version >= 7 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_errorCode.GetSize(IsFlexibleVersion) +
				(Version >= 1 ? 
					_errorMessage.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_numPartitions.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_replicationFactor.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_configsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<CreatableTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatableTopicResult(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 7) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.NumPartitions = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.ReplicationFactor = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.ConfigsCollection = await NullableArray<CreatableTopicConfigs>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableTopicConfigs.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							case 0:
								if (instance.Version >= 5) 
									instance.TopicConfigErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
								else
									throw new InvalidOperationException($"Field TopicConfigErrorCode is not supported for version {instance.Version}");
								{
									var size = instance._topicConfigErrorCode.GetSize(true);
									if (size != tag.Length)
										throw new CorruptMessageException($"Tagged field TopicConfigErrorCode read length {tag.Length} but had actual length of {size}");
								}
								break;
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 7)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _numPartitions.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _replicationFactor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _configsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public CreatableTopicResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopicResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public CreatableTopicResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private bool _topicConfigErrorCodeIsSet;
			private Int16 _topicConfigErrorCode = Int16.Default;
			/// <summary>
			/// <para>Optional topic config error returned if configs are not returned in the response.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Int16 TopicConfigErrorCode 
			{
				get => _topicConfigErrorCode;
				private set 
				{
					_topicConfigErrorCode = value;
					_topicConfigErrorCodeIsSet = true;
				}
			}

			/// <summary>
			/// <para>Optional topic config error returned if configs are not returned in the response.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public CreatableTopicResult WithTopicConfigErrorCode(Int16 topicConfigErrorCode)
			{
				TopicConfigErrorCode = topicConfigErrorCode;
				return this;
			}

			private Int32 _numPartitions = new Int32(-1);
			/// <summary>
			/// <para>Number of partitions of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int32 NumPartitions 
			{
				get => _numPartitions;
				private set 
				{
					_numPartitions = value;
				}
			}

			/// <summary>
			/// <para>Number of partitions of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public CreatableTopicResult WithNumPartitions(Int32 numPartitions)
			{
				NumPartitions = numPartitions;
				return this;
			}

			private Int16 _replicationFactor = new Int16(-1);
			/// <summary>
			/// <para>Replication factor of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int16 ReplicationFactor 
			{
				get => _replicationFactor;
				private set 
				{
					_replicationFactor = value;
				}
			}

			/// <summary>
			/// <para>Replication factor of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public CreatableTopicResult WithReplicationFactor(Int16 replicationFactor)
			{
				ReplicationFactor = replicationFactor;
				return this;
			}

			private NullableArray<CreatableTopicConfigs> _configsCollection = Array.Empty<CreatableTopicConfigs>();
			/// <summary>
			/// <para>Configuration of the topic.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Array<CreatableTopicConfigs>? ConfigsCollection 
			{
				get => _configsCollection;
				private set 
				{
					if (Version >= 5 == false &&
						value == null) 
						throw new UnsupportedVersionException($"ConfigsCollection does not support null for version {Version}. Supported versions for null value: 5+");

					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>Configuration of the topic.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public CreatableTopicResult WithConfigsCollection(params Func<CreatableTopicConfigs, CreatableTopicConfigs>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new CreatableTopicConfigs(Version)))
					.ToArray();
				return this;
			}

			public delegate CreatableTopicConfigs CreateCreatableTopicConfigs(CreatableTopicConfigs field);

			/// <summary>
			/// <para>Configuration of the topic.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public CreatableTopicResult WithConfigsCollection(IEnumerable<CreateCreatableTopicConfigs> createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new CreatableTopicConfigs(Version)))
					.ToArray();
				return this;
			}

			public class CreatableTopicConfigs : ISerialize
			{
				internal CreatableTopicConfigs(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 5;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 5 ? 
						_name.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_value.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_readOnly.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_configSource.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_isSensitive.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<CreatableTopicConfigs> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreatableTopicConfigs(version);
					if (instance.Version >= 5) 
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.ReadOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.ConfigSource = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.IsSensitive = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableTopicConfigs is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 5)
						await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _readOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _configSource.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _isSensitive.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						if (Version >= 5 == false)
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithName(String name)
				{
					Name = name;
					return this;
				}

				private NullableString _value = NullableString.Default;
				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					private set 
					{
						if (Version >= 5 == false)
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

						if (Version >= 5 == false &&
							value == null) 
							throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 5+");

						_value = value;
					}
				}

				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithValue(String? value)
				{
					Value = value;
					return this;
				}

				private Boolean _readOnly = Boolean.Default;
				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public Boolean ReadOnly 
				{
					get => _readOnly;
					private set 
					{
						if (Version >= 5 == false)
							throw new UnsupportedVersionException($"ReadOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

						_readOnly = value;
					}
				}

				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithReadOnly(Boolean readOnly)
				{
					ReadOnly = readOnly;
					return this;
				}

				private Int8 _configSource = new Int8(-1);
				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int8 ConfigSource 
				{
					get => _configSource;
					private set 
					{
						_configSource = value;
					}
				}

				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public CreatableTopicConfigs WithConfigSource(Int8 configSource)
				{
					ConfigSource = configSource;
					return this;
				}

				private Boolean _isSensitive = Boolean.Default;
				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public Boolean IsSensitive 
				{
					get => _isSensitive;
					private set 
					{
						if (Version >= 5 == false)
							throw new UnsupportedVersionException($"IsSensitive does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

						_isSensitive = value;
					}
				}

				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithIsSensitive(Boolean isSensitive)
				{
					IsSensitive = isSensitive;
					return this;
				}
			}
		}
	}

	public class DeleteAclsRequest : Message, IRespond<DeleteAclsResponse>
	{
		public DeleteAclsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteAclsRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(31);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_filtersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteAclsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteAclsRequest(version);
			instance.FiltersCollection = await Array<DeleteAclsFilter>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteAclsFilter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _filtersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<DeleteAclsFilter> _filtersCollection = Array.Empty<DeleteAclsFilter>();
		/// <summary>
		/// <para>The filters to use when deleting ACLs.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DeleteAclsFilter> FiltersCollection 
		{
			get => _filtersCollection;
			private set 
			{
				_filtersCollection = value;
			}
		}

		/// <summary>
		/// <para>The filters to use when deleting ACLs.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsRequest WithFiltersCollection(params Func<DeleteAclsFilter, DeleteAclsFilter>[] createFields)
		{
			FiltersCollection = createFields
				.Select(createField => createField(new DeleteAclsFilter(Version)))
				.ToArray();
			return this;
		}

		public delegate DeleteAclsFilter CreateDeleteAclsFilter(DeleteAclsFilter field);

		/// <summary>
		/// <para>The filters to use when deleting ACLs.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsRequest WithFiltersCollection(IEnumerable<CreateDeleteAclsFilter> createFields)
		{
			FiltersCollection = createFields
				.Select(createField => createField(new DeleteAclsFilter(Version)))
				.ToArray();
			return this;
		}

		public class DeleteAclsFilter : ISerialize
		{
			internal DeleteAclsFilter(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_resourceTypeFilter.GetSize(IsFlexibleVersion) +
				_resourceNameFilter.GetSize(IsFlexibleVersion) +
				(Version >= 1 ? 
					_patternTypeFilter.GetSize(IsFlexibleVersion):
					0) +
				_principalFilter.GetSize(IsFlexibleVersion) +
				_hostFilter.GetSize(IsFlexibleVersion) +
				_operation.GetSize(IsFlexibleVersion) +
				_permissionType.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteAclsFilter> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteAclsFilter(version);
				instance.ResourceTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceNameFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.PatternTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PrincipalFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.HostFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsFilter is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _resourceTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceNameFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _patternTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _principalFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _hostFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _permissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int8 _resourceTypeFilter = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceTypeFilter 
			{
				get => _resourceTypeFilter;
				private set 
				{
					_resourceTypeFilter = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithResourceTypeFilter(Int8 resourceTypeFilter)
			{
				ResourceTypeFilter = resourceTypeFilter;
				return this;
			}

			private NullableString _resourceNameFilter = NullableString.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ResourceNameFilter 
			{
				get => _resourceNameFilter;
				private set 
				{
					_resourceNameFilter = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithResourceNameFilter(String? resourceNameFilter)
			{
				ResourceNameFilter = resourceNameFilter;
				return this;
			}

			private Int8 _patternTypeFilter = new Int8(3);
			/// <summary>
			/// <para>The pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public Int8 PatternTypeFilter 
			{
				get => _patternTypeFilter;
				private set 
				{
					if (Version >= 1 == false)
						throw new UnsupportedVersionException($"PatternTypeFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

					_patternTypeFilter = value;
				}
			}

			/// <summary>
			/// <para>The pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public DeleteAclsFilter WithPatternTypeFilter(Int8 patternTypeFilter)
			{
				PatternTypeFilter = patternTypeFilter;
				return this;
			}

			private NullableString _principalFilter = NullableString.Default;
			/// <summary>
			/// <para>The principal filter, or null to accept all principals.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? PrincipalFilter 
			{
				get => _principalFilter;
				private set 
				{
					_principalFilter = value;
				}
			}

			/// <summary>
			/// <para>The principal filter, or null to accept all principals.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithPrincipalFilter(String? principalFilter)
			{
				PrincipalFilter = principalFilter;
				return this;
			}

			private NullableString _hostFilter = NullableString.Default;
			/// <summary>
			/// <para>The host filter, or null to accept all hosts.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? HostFilter 
			{
				get => _hostFilter;
				private set 
				{
					_hostFilter = value;
				}
			}

			/// <summary>
			/// <para>The host filter, or null to accept all hosts.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithHostFilter(String? hostFilter)
			{
				HostFilter = hostFilter;
				return this;
			}

			private Int8 _operation = Int8.Default;
			/// <summary>
			/// <para>The ACL operation.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Operation 
			{
				get => _operation;
				private set 
				{
					_operation = value;
				}
			}

			/// <summary>
			/// <para>The ACL operation.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithOperation(Int8 operation)
			{
				Operation = operation;
				return this;
			}

			private Int8 _permissionType = Int8.Default;
			/// <summary>
			/// <para>The permission type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 PermissionType 
			{
				get => _permissionType;
				private set 
				{
					_permissionType = value;
				}
			}

			/// <summary>
			/// <para>The permission type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithPermissionType(Int8 permissionType)
			{
				PermissionType = permissionType;
				return this;
			}
		}

		public DeleteAclsResponse Respond()
			=> new DeleteAclsResponse(Version);
	}

	public class DeleteAclsResponse : Message
	{
		public DeleteAclsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteAclsResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(31);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_filterResultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteAclsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteAclsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.FilterResultsCollection = await Array<DeleteAclsFilterResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteAclsFilterResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _filterResultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<DeleteAclsFilterResult> _filterResultsCollection = Array.Empty<DeleteAclsFilterResult>();
		/// <summary>
		/// <para>The results for each filter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DeleteAclsFilterResult> FilterResultsCollection 
		{
			get => _filterResultsCollection;
			private set 
			{
				_filterResultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each filter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsResponse WithFilterResultsCollection(params Func<DeleteAclsFilterResult, DeleteAclsFilterResult>[] createFields)
		{
			FilterResultsCollection = createFields
				.Select(createField => createField(new DeleteAclsFilterResult(Version)))
				.ToArray();
			return this;
		}

		public delegate DeleteAclsFilterResult CreateDeleteAclsFilterResult(DeleteAclsFilterResult field);

		/// <summary>
		/// <para>The results for each filter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsResponse WithFilterResultsCollection(IEnumerable<CreateDeleteAclsFilterResult> createFields)
		{
			FilterResultsCollection = createFields
				.Select(createField => createField(new DeleteAclsFilterResult(Version)))
				.ToArray();
			return this;
		}

		public class DeleteAclsFilterResult : ISerialize
		{
			internal DeleteAclsFilterResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_matchingAclsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteAclsFilterResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteAclsFilterResult(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MatchingAclsCollection = await Array<DeleteAclsMatchingAcl>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteAclsMatchingAcl.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsFilterResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _matchingAclsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The error message, or null if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Array<DeleteAclsMatchingAcl> _matchingAclsCollection = Array.Empty<DeleteAclsMatchingAcl>();
			/// <summary>
			/// <para>The ACLs which matched this filter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DeleteAclsMatchingAcl> MatchingAclsCollection 
			{
				get => _matchingAclsCollection;
				private set 
				{
					_matchingAclsCollection = value;
				}
			}

			/// <summary>
			/// <para>The ACLs which matched this filter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithMatchingAclsCollection(params Func<DeleteAclsMatchingAcl, DeleteAclsMatchingAcl>[] createFields)
			{
				MatchingAclsCollection = createFields
					.Select(createField => createField(new DeleteAclsMatchingAcl(Version)))
					.ToArray();
				return this;
			}

			public delegate DeleteAclsMatchingAcl CreateDeleteAclsMatchingAcl(DeleteAclsMatchingAcl field);

			/// <summary>
			/// <para>The ACLs which matched this filter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithMatchingAclsCollection(IEnumerable<CreateDeleteAclsMatchingAcl> createFields)
			{
				MatchingAclsCollection = createFields
					.Select(createField => createField(new DeleteAclsMatchingAcl(Version)))
					.ToArray();
				return this;
			}

			public class DeleteAclsMatchingAcl : ISerialize
			{
				internal DeleteAclsMatchingAcl(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					_resourceType.GetSize(IsFlexibleVersion) +
					_resourceName.GetSize(IsFlexibleVersion) +
					(Version >= 1 ? 
						_patternType.GetSize(IsFlexibleVersion):
						0) +
					_principal.GetSize(IsFlexibleVersion) +
					_host.GetSize(IsFlexibleVersion) +
					_operation.GetSize(IsFlexibleVersion) +
					_permissionType.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DeleteAclsMatchingAcl> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DeleteAclsMatchingAcl(version);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.PatternType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Principal = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsMatchingAcl is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _patternType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _principal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _permissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = NullableString.Default;
				/// <summary>
				/// <para>The deletion error message, or null if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The deletion error message, or null if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Int8 _resourceType = Int8.Default;
				/// <summary>
				/// <para>The ACL resource type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 ResourceType 
				{
					get => _resourceType;
					private set 
					{
						_resourceType = value;
					}
				}

				/// <summary>
				/// <para>The ACL resource type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithResourceType(Int8 resourceType)
				{
					ResourceType = resourceType;
					return this;
				}

				private String _resourceName = String.Default;
				/// <summary>
				/// <para>The ACL resource name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ResourceName 
				{
					get => _resourceName;
					private set 
					{
						_resourceName = value;
					}
				}

				/// <summary>
				/// <para>The ACL resource name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithResourceName(String resourceName)
				{
					ResourceName = resourceName;
					return this;
				}

				private Int8 _patternType = new Int8(3);
				/// <summary>
				/// <para>The ACL resource pattern type.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 3</para>
				/// </summary>
				public Int8 PatternType 
				{
					get => _patternType;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"PatternType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_patternType = value;
					}
				}

				/// <summary>
				/// <para>The ACL resource pattern type.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 3</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithPatternType(Int8 patternType)
				{
					PatternType = patternType;
					return this;
				}

				private String _principal = String.Default;
				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Principal 
				{
					get => _principal;
					private set 
					{
						_principal = value;
					}
				}

				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithPrincipal(String principal)
				{
					Principal = principal;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					private set 
					{
						_host = value;
					}
				}

				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithHost(String host)
				{
					Host = host;
					return this;
				}

				private Int8 _operation = Int8.Default;
				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 Operation 
				{
					get => _operation;
					private set 
					{
						_operation = value;
					}
				}

				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithOperation(Int8 operation)
				{
					Operation = operation;
					return this;
				}

				private Int8 _permissionType = Int8.Default;
				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 PermissionType 
				{
					get => _permissionType;
					private set 
					{
						_permissionType = value;
					}
				}

				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithPermissionType(Int8 permissionType)
				{
					PermissionType = permissionType;
					return this;
				}
			}
		}
	}

	public class DeleteGroupsRequest : Message, IRespond<DeleteGroupsResponse>
	{
		public DeleteGroupsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteGroupsRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(42);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupsNamesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteGroupsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteGroupsRequest(version);
			instance.GroupsNamesCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteGroupsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupsNamesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _groupsNamesCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The group names to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> GroupsNamesCollection 
		{
			get => _groupsNamesCollection;
			private set 
			{
				_groupsNamesCollection = value;
			}
		}

		/// <summary>
		/// <para>The group names to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsRequest WithGroupsNamesCollection(Array<String> groupsNamesCollection)
		{
			GroupsNamesCollection = groupsNamesCollection;
			return this;
		}

		public DeleteGroupsResponse Respond()
			=> new DeleteGroupsResponse(Version);
	}

	public class DeleteGroupsResponse : Message
	{
		public DeleteGroupsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteGroupsResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(42);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteGroupsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteGroupsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Map<String, DeletableGroupResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeletableGroupResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.GroupId, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteGroupsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<String, DeletableGroupResult> _resultsCollection = Map<String, DeletableGroupResult>.Default;
		/// <summary>
		/// <para>The deletion results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, DeletableGroupResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The deletion results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsResponse WithResultsCollection(params Func<DeletableGroupResult, DeletableGroupResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DeletableGroupResult(Version)))
				.ToDictionary(field => field.GroupId);
			return this;
		}

		public delegate DeletableGroupResult CreateDeletableGroupResult(DeletableGroupResult field);

		/// <summary>
		/// <para>The deletion results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsResponse WithResultsCollection(IEnumerable<CreateDeletableGroupResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DeletableGroupResult(Version)))
				.ToDictionary(field => field.GroupId);
			return this;
		}

		public class DeletableGroupResult : ISerialize
		{
			internal DeletableGroupResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_groupId.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeletableGroupResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeletableGroupResult(version);
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeletableGroupResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group id</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group id</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableGroupResult WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableGroupResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class DeleteRecordsRequest : Message, IRespond<DeleteRecordsResponse>
	{
		public DeleteRecordsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteRecordsRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(21);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteRecordsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteRecordsRequest(version);
			instance.TopicsCollection = await Array<DeleteRecordsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<DeleteRecordsTopic> _topicsCollection = Array.Empty<DeleteRecordsTopic>();
		/// <summary>
		/// <para>Each topic that we want to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DeleteRecordsTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsRequest WithTopicsCollection(params Func<DeleteRecordsTopic, DeleteRecordsTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteRecordsTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate DeleteRecordsTopic CreateDeleteRecordsTopic(DeleteRecordsTopic field);

		/// <summary>
		/// <para>Each topic that we want to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsRequest WithTopicsCollection(IEnumerable<CreateDeleteRecordsTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteRecordsTopic(Version)))
				.ToArray();
			return this;
		}

		public class DeleteRecordsTopic : ISerialize
		{
			internal DeleteRecordsTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteRecordsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteRecordsTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<DeleteRecordsPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<DeleteRecordsPartition> _partitionsCollection = Array.Empty<DeleteRecordsPartition>();
			/// <summary>
			/// <para>Each partition that we want to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DeleteRecordsPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition that we want to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopic WithPartitionsCollection(params Func<DeleteRecordsPartition, DeleteRecordsPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new DeleteRecordsPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate DeleteRecordsPartition CreateDeleteRecordsPartition(DeleteRecordsPartition field);

			/// <summary>
			/// <para>Each partition that we want to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopic WithPartitionsCollection(IEnumerable<CreateDeleteRecordsPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new DeleteRecordsPartition(Version)))
					.ToArray();
				return this;
			}

			public class DeleteRecordsPartition : ISerialize
			{
				internal DeleteRecordsPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_offset.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DeleteRecordsPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DeleteRecordsPartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Offset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _offset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _offset = Int64.Default;
				/// <summary>
				/// <para>The deletion offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Offset 
				{
					get => _offset;
					private set 
					{
						_offset = value;
					}
				}

				/// <summary>
				/// <para>The deletion offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartition WithOffset(Int64 offset)
				{
					Offset = offset;
					return this;
				}
			}
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>How long to wait for the deletion to complete, in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>How long to wait for the deletion to complete, in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		public DeleteRecordsResponse Respond()
			=> new DeleteRecordsResponse(Version);
	}

	public class DeleteRecordsResponse : Message
	{
		public DeleteRecordsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteRecordsResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(21);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteRecordsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteRecordsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<String, DeleteRecordsTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<String, DeleteRecordsTopicResult> _topicsCollection = Map<String, DeleteRecordsTopicResult>.Default;
		/// <summary>
		/// <para>Each topic that we wanted to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, DeleteRecordsTopicResult> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we wanted to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsResponse WithTopicsCollection(params Func<DeleteRecordsTopicResult, DeleteRecordsTopicResult>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteRecordsTopicResult(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate DeleteRecordsTopicResult CreateDeleteRecordsTopicResult(DeleteRecordsTopicResult field);

		/// <summary>
		/// <para>Each topic that we wanted to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsResponse WithTopicsCollection(IEnumerable<CreateDeleteRecordsTopicResult> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteRecordsTopicResult(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class DeleteRecordsTopicResult : ISerialize
		{
			internal DeleteRecordsTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteRecordsTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteRecordsTopicResult(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Map<Int32, DeleteRecordsPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.PartitionIndex, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Map<Int32, DeleteRecordsPartitionResult> _partitionsCollection = Map<Int32, DeleteRecordsPartitionResult>.Default;
			/// <summary>
			/// <para>Each partition that we wanted to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<Int32, DeleteRecordsPartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition that we wanted to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopicResult WithPartitionsCollection(params Func<DeleteRecordsPartitionResult, DeleteRecordsPartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new DeleteRecordsPartitionResult(Version)))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			public delegate DeleteRecordsPartitionResult CreateDeleteRecordsPartitionResult(DeleteRecordsPartitionResult field);

			/// <summary>
			/// <para>Each partition that we wanted to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopicResult WithPartitionsCollection(IEnumerable<CreateDeleteRecordsPartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new DeleteRecordsPartitionResult(Version)))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			public class DeleteRecordsPartitionResult : ISerialize
			{
				internal DeleteRecordsPartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_lowWatermark.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DeleteRecordsPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DeleteRecordsPartitionResult(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LowWatermark = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsPartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _lowWatermark.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartitionResult WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _lowWatermark = Int64.Default;
				/// <summary>
				/// <para>The partition low water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 LowWatermark 
				{
					get => _lowWatermark;
					private set 
					{
						_lowWatermark = value;
					}
				}

				/// <summary>
				/// <para>The partition low water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartitionResult WithLowWatermark(Int64 lowWatermark)
				{
					LowWatermark = lowWatermark;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class DeleteShareGroupStateRequest : Message, IRespond<DeleteShareGroupStateResponse>
	{
		public DeleteShareGroupStateRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteShareGroupStateRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(86);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteShareGroupStateRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteShareGroupStateRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<DeleteStateData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteStateData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteShareGroupStateRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteShareGroupStateRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Array<DeleteStateData> _topicsCollection = Array.Empty<DeleteStateData>();
		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DeleteStateData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteShareGroupStateRequest WithTopicsCollection(params Func<DeleteStateData, DeleteStateData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteStateData(Version)))
				.ToArray();
			return this;
		}

		public delegate DeleteStateData CreateDeleteStateData(DeleteStateData field);

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteShareGroupStateRequest WithTopicsCollection(IEnumerable<CreateDeleteStateData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteStateData(Version)))
				.ToArray();
			return this;
		}

		public class DeleteStateData : ISerialize
		{
			internal DeleteStateData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteStateData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteStateData(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteStateData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteStateData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteStateData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteStateData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}
			}
		}

		public DeleteShareGroupStateResponse Respond()
			=> new DeleteShareGroupStateResponse(Version);
	}

	public class DeleteShareGroupStateResponse : Message
	{
		public DeleteShareGroupStateResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteShareGroupStateResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(86);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteShareGroupStateResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteShareGroupStateResponse(version);
			instance.ResultsCollection = await Array<DeleteStateResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteStateResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteShareGroupStateResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<DeleteStateResult> _resultsCollection = Array.Empty<DeleteStateResult>();
		/// <summary>
		/// <para>The delete results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DeleteStateResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The delete results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteShareGroupStateResponse WithResultsCollection(params Func<DeleteStateResult, DeleteStateResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DeleteStateResult(Version)))
				.ToArray();
			return this;
		}

		public delegate DeleteStateResult CreateDeleteStateResult(DeleteStateResult field);

		/// <summary>
		/// <para>The delete results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteShareGroupStateResponse WithResultsCollection(IEnumerable<CreateDeleteStateResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DeleteStateResult(Version)))
				.ToArray();
			return this;
		}

		public class DeleteStateResult : ISerialize
		{
			internal DeleteStateResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteStateResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteStateResult(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteStateResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteStateResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionResult> _partitionsCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteStateResult WithPartitionsCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResult CreatePartitionResult(PartitionResult field);

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteStateResult WithPartitionsCollection(IEnumerable<CreatePartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class DeleteTopicsRequest : Message, IRespond<DeleteTopicsResponse>
	{
		public DeleteTopicsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteTopicsRequest does not support version {version}. Valid versions are: 0-6");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(20);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 6 ? 
				_topicsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 5 ? 
				_topicNamesCollection.GetSize(IsFlexibleVersion):
				0) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteTopicsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteTopicsRequest(version);
			if (instance.Version >= 6) 
				instance.TopicsCollection = await Array<DeleteTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 5) 
				instance.TopicNamesCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteTopicsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 6)
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 5)
				await _topicNamesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<DeleteTopicState> _topicsCollection = Array.Empty<DeleteTopicState>();
		/// <summary>
		/// <para>The name or topic ID of the topic</para>
		/// <para>Versions: 6+</para>
		/// </summary>
		public Array<DeleteTopicState> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				if (Version >= 6 == false)
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The name or topic ID of the topic</para>
		/// <para>Versions: 6+</para>
		/// </summary>
		public DeleteTopicsRequest WithTopicsCollection(params Func<DeleteTopicState, DeleteTopicState>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteTopicState(Version)))
				.ToArray();
			return this;
		}

		public delegate DeleteTopicState CreateDeleteTopicState(DeleteTopicState field);

		/// <summary>
		/// <para>The name or topic ID of the topic</para>
		/// <para>Versions: 6+</para>
		/// </summary>
		public DeleteTopicsRequest WithTopicsCollection(IEnumerable<CreateDeleteTopicState> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DeleteTopicState(Version)))
				.ToArray();
			return this;
		}

		public class DeleteTopicState : ISerialize
		{
			internal DeleteTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 6 ? 
					_name.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 6 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeleteTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteTopicState(version);
				if (instance.Version >= 6) 
					instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 6) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteTopicState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 6)
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 6)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private NullableString _name = new NullableString(null);
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 6+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 6 == false)
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");

					if (Version >= 6 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 6+");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 6+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DeleteTopicState WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					if (Version >= 6 == false)
						throw new UnsupportedVersionException($"TopicId does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");

					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public DeleteTopicState WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}
		}

		private Array<String> _topicNamesCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The names of the topics to delete</para>
		/// <para>Versions: 0-5</para>
		/// </summary>
		public Array<String> TopicNamesCollection 
		{
			get => _topicNamesCollection;
			private set 
			{
				_topicNamesCollection = value;
			}
		}

		/// <summary>
		/// <para>The names of the topics to delete</para>
		/// <para>Versions: 0-5</para>
		/// </summary>
		public DeleteTopicsRequest WithTopicNamesCollection(Array<String> topicNamesCollection)
		{
			TopicNamesCollection = topicNamesCollection;
			return this;
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>The length of time in milliseconds to wait for the deletions to complete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The length of time in milliseconds to wait for the deletions to complete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteTopicsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		public DeleteTopicsResponse Respond()
			=> new DeleteTopicsResponse(Version);
	}

	public class DeleteTopicsResponse : Message
	{
		public DeleteTopicsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DeleteTopicsResponse does not support version {version}. Valid versions are: 0-6");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(20);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DeleteTopicsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteTopicsResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Map<NullableString, DeletableTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeletableTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteTopicsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public DeleteTopicsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<NullableString, DeletableTopicResult> _responsesCollection = Map<NullableString, DeletableTopicResult>.Default;
		/// <summary>
		/// <para>The results for each topic we tried to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<NullableString, DeletableTopicResult> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each topic we tried to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteTopicsResponse WithResponsesCollection(params Func<DeletableTopicResult, DeletableTopicResult>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new DeletableTopicResult(Version)))
				.ToDictionary(field => (NullableString)field.Name);
			return this;
		}

		public delegate DeletableTopicResult CreateDeletableTopicResult(DeletableTopicResult field);

		/// <summary>
		/// <para>The results for each topic we tried to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteTopicsResponse WithResponsesCollection(IEnumerable<CreateDeletableTopicResult> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new DeletableTopicResult(Version)))
				.ToDictionary(field => (NullableString)field.Name);
			return this;
		}

		public class DeletableTopicResult : ISerialize
		{
			internal DeletableTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				(Version >= 6 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_errorCode.GetSize(IsFlexibleVersion) +
				(Version >= 5 ? 
					_errorMessage.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DeletableTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeletableTopicResult(version);
				instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 6) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeletableTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 6)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private NullableString _name = NullableString.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 6 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 6+");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableTopicResult WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>the unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>the unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public DeletableTopicResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableTopicResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = new NullableString(null);
			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					if (Version >= 5 == false &&
						value == null) 
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 5+");

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DeletableTopicResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class DescribeAclsRequest : Message, IRespond<DescribeAclsResponse>
	{
		public DescribeAclsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeAclsRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(29);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resourceTypeFilter.GetSize(IsFlexibleVersion) +
			_resourceNameFilter.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_patternTypeFilter.GetSize(IsFlexibleVersion):
				0) +
			_principalFilter.GetSize(IsFlexibleVersion) +
			_hostFilter.GetSize(IsFlexibleVersion) +
			_operation.GetSize(IsFlexibleVersion) +
			_permissionType.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeAclsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeAclsRequest(version);
			instance.ResourceTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResourceNameFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.PatternTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.PrincipalFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.HostFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeAclsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resourceTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resourceNameFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _patternTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _principalFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _hostFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _permissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int8 _resourceTypeFilter = Int8.Default;
		/// <summary>
		/// <para>The resource type.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 ResourceTypeFilter 
		{
			get => _resourceTypeFilter;
			private set 
			{
				_resourceTypeFilter = value;
			}
		}

		/// <summary>
		/// <para>The resource type.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithResourceTypeFilter(Int8 resourceTypeFilter)
		{
			ResourceTypeFilter = resourceTypeFilter;
			return this;
		}

		private NullableString _resourceNameFilter = NullableString.Default;
		/// <summary>
		/// <para>The resource name, or null to match any resource name.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ResourceNameFilter 
		{
			get => _resourceNameFilter;
			private set 
			{
				_resourceNameFilter = value;
			}
		}

		/// <summary>
		/// <para>The resource name, or null to match any resource name.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithResourceNameFilter(String? resourceNameFilter)
		{
			ResourceNameFilter = resourceNameFilter;
			return this;
		}

		private Int8 _patternTypeFilter = new Int8(3);
		/// <summary>
		/// <para>The resource pattern to match.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 3</para>
		/// </summary>
		public Int8 PatternTypeFilter 
		{
			get => _patternTypeFilter;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"PatternTypeFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_patternTypeFilter = value;
			}
		}

		/// <summary>
		/// <para>The resource pattern to match.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 3</para>
		/// </summary>
		public DescribeAclsRequest WithPatternTypeFilter(Int8 patternTypeFilter)
		{
			PatternTypeFilter = patternTypeFilter;
			return this;
		}

		private NullableString _principalFilter = NullableString.Default;
		/// <summary>
		/// <para>The principal to match, or null to match any principal.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? PrincipalFilter 
		{
			get => _principalFilter;
			private set 
			{
				_principalFilter = value;
			}
		}

		/// <summary>
		/// <para>The principal to match, or null to match any principal.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithPrincipalFilter(String? principalFilter)
		{
			PrincipalFilter = principalFilter;
			return this;
		}

		private NullableString _hostFilter = NullableString.Default;
		/// <summary>
		/// <para>The host to match, or null to match any host.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? HostFilter 
		{
			get => _hostFilter;
			private set 
			{
				_hostFilter = value;
			}
		}

		/// <summary>
		/// <para>The host to match, or null to match any host.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithHostFilter(String? hostFilter)
		{
			HostFilter = hostFilter;
			return this;
		}

		private Int8 _operation = Int8.Default;
		/// <summary>
		/// <para>The operation to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 Operation 
		{
			get => _operation;
			private set 
			{
				_operation = value;
			}
		}

		/// <summary>
		/// <para>The operation to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithOperation(Int8 operation)
		{
			Operation = operation;
			return this;
		}

		private Int8 _permissionType = Int8.Default;
		/// <summary>
		/// <para>The permission type to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 PermissionType 
		{
			get => _permissionType;
			private set 
			{
				_permissionType = value;
			}
		}

		/// <summary>
		/// <para>The permission type to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithPermissionType(Int8 permissionType)
		{
			PermissionType = permissionType;
			return this;
		}

		public DescribeAclsResponse Respond()
			=> new DescribeAclsResponse(Version);
	}

	public class DescribeAclsResponse : Message
	{
		public DescribeAclsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeAclsResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(29);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_resourcesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeAclsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeAclsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResourcesCollection = await Array<DescribeAclsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeAclsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeAclsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resourcesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<DescribeAclsResource> _resourcesCollection = Array.Empty<DescribeAclsResource>();
		/// <summary>
		/// <para>Each Resource that is referenced in an ACL.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribeAclsResource> ResourcesCollection 
		{
			get => _resourcesCollection;
			private set 
			{
				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each Resource that is referenced in an ACL.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithResourcesCollection(params Func<DescribeAclsResource, DescribeAclsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new DescribeAclsResource(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribeAclsResource CreateDescribeAclsResource(DescribeAclsResource field);

		/// <summary>
		/// <para>Each Resource that is referenced in an ACL.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithResourcesCollection(IEnumerable<CreateDescribeAclsResource> createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new DescribeAclsResource(Version)))
				.ToArray();
			return this;
		}

		public class DescribeAclsResource : ISerialize
		{
			internal DescribeAclsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				(Version >= 1 ? 
					_patternType.GetSize(IsFlexibleVersion):
					0) +
				_aclsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeAclsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeAclsResource(version);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.PatternType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AclsCollection = await Array<AclDescription>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AclDescription.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeAclsResource is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _patternType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _aclsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Int8 _patternType = new Int8(3);
			/// <summary>
			/// <para>The resource pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public Int8 PatternType 
			{
				get => _patternType;
				private set 
				{
					if (Version >= 1 == false)
						throw new UnsupportedVersionException($"PatternType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

					_patternType = value;
				}
			}

			/// <summary>
			/// <para>The resource pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public DescribeAclsResource WithPatternType(Int8 patternType)
			{
				PatternType = patternType;
				return this;
			}

			private Array<AclDescription> _aclsCollection = Array.Empty<AclDescription>();
			/// <summary>
			/// <para>The ACLs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<AclDescription> AclsCollection 
			{
				get => _aclsCollection;
				private set 
				{
					_aclsCollection = value;
				}
			}

			/// <summary>
			/// <para>The ACLs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithAclsCollection(params Func<AclDescription, AclDescription>[] createFields)
			{
				AclsCollection = createFields
					.Select(createField => createField(new AclDescription(Version)))
					.ToArray();
				return this;
			}

			public delegate AclDescription CreateAclDescription(AclDescription field);

			/// <summary>
			/// <para>The ACLs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithAclsCollection(IEnumerable<CreateAclDescription> createFields)
			{
				AclsCollection = createFields
					.Select(createField => createField(new AclDescription(Version)))
					.ToArray();
				return this;
			}

			public class AclDescription : ISerialize
			{
				internal AclDescription(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_principal.GetSize(IsFlexibleVersion) +
					_host.GetSize(IsFlexibleVersion) +
					_operation.GetSize(IsFlexibleVersion) +
					_permissionType.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<AclDescription> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AclDescription(version);
					instance.Principal = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AclDescription is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _principal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _permissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _principal = String.Default;
				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Principal 
				{
					get => _principal;
					private set 
					{
						_principal = value;
					}
				}

				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithPrincipal(String principal)
				{
					Principal = principal;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					private set 
					{
						_host = value;
					}
				}

				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithHost(String host)
				{
					Host = host;
					return this;
				}

				private Int8 _operation = Int8.Default;
				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 Operation 
				{
					get => _operation;
					private set 
					{
						_operation = value;
					}
				}

				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithOperation(Int8 operation)
				{
					Operation = operation;
					return this;
				}

				private Int8 _permissionType = Int8.Default;
				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 PermissionType 
				{
					get => _permissionType;
					private set 
					{
						_permissionType = value;
					}
				}

				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithPermissionType(Int8 permissionType)
				{
					PermissionType = permissionType;
					return this;
				}
			}
		}
	}

	public class DescribeClientQuotasRequest : Message, IRespond<DescribeClientQuotasResponse>
	{
		public DescribeClientQuotasRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeClientQuotasRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(48);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_componentsCollection.GetSize(IsFlexibleVersion) +
			_strict.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeClientQuotasRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClientQuotasRequest(version);
			instance.ComponentsCollection = await Array<ComponentData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ComponentData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.Strict = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClientQuotasRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _componentsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _strict.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<ComponentData> _componentsCollection = Array.Empty<ComponentData>();
		/// <summary>
		/// <para>Filter components to apply to quota entities.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ComponentData> ComponentsCollection 
		{
			get => _componentsCollection;
			private set 
			{
				_componentsCollection = value;
			}
		}

		/// <summary>
		/// <para>Filter components to apply to quota entities.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasRequest WithComponentsCollection(params Func<ComponentData, ComponentData>[] createFields)
		{
			ComponentsCollection = createFields
				.Select(createField => createField(new ComponentData(Version)))
				.ToArray();
			return this;
		}

		public delegate ComponentData CreateComponentData(ComponentData field);

		/// <summary>
		/// <para>Filter components to apply to quota entities.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasRequest WithComponentsCollection(IEnumerable<CreateComponentData> createFields)
		{
			ComponentsCollection = createFields
				.Select(createField => createField(new ComponentData(Version)))
				.ToArray();
			return this;
		}

		public class ComponentData : ISerialize
		{
			internal ComponentData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_entityType.GetSize(IsFlexibleVersion) +
				_matchType.GetSize(IsFlexibleVersion) +
				_match.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ComponentData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ComponentData(version);
				instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MatchType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Match = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ComponentData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _entityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _matchType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _match.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _entityType = String.Default;
			/// <summary>
			/// <para>The entity type that the filter component applies to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String EntityType 
			{
				get => _entityType;
				private set 
				{
					_entityType = value;
				}
			}

			/// <summary>
			/// <para>The entity type that the filter component applies to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ComponentData WithEntityType(String entityType)
			{
				EntityType = entityType;
				return this;
			}

			private Int8 _matchType = Int8.Default;
			/// <summary>
			/// <para>How to match the entity {0 = exact name, 1 = default name, 2 = any specified name}.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 MatchType 
			{
				get => _matchType;
				private set 
				{
					_matchType = value;
				}
			}

			/// <summary>
			/// <para>How to match the entity {0 = exact name, 1 = default name, 2 = any specified name}.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ComponentData WithMatchType(Int8 matchType)
			{
				MatchType = matchType;
				return this;
			}

			private NullableString _match = NullableString.Default;
			/// <summary>
			/// <para>The string to match against, or null if unused for the match type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Match 
			{
				get => _match;
				private set 
				{
					_match = value;
				}
			}

			/// <summary>
			/// <para>The string to match against, or null if unused for the match type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ComponentData WithMatch(String? match)
			{
				Match = match;
				return this;
			}
		}

		private Boolean _strict = Boolean.Default;
		/// <summary>
		/// <para>Whether the match is strict, i.e. should exclude entities with unspecified entity types.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean Strict 
		{
			get => _strict;
			private set 
			{
				_strict = value;
			}
		}

		/// <summary>
		/// <para>Whether the match is strict, i.e. should exclude entities with unspecified entity types.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasRequest WithStrict(Boolean strict)
		{
			Strict = strict;
			return this;
		}

		public DescribeClientQuotasResponse Respond()
			=> new DescribeClientQuotasResponse(Version);
	}

	public class DescribeClientQuotasResponse : Message
	{
		public DescribeClientQuotasResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeClientQuotasResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(48);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_entriesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeClientQuotasResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClientQuotasResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.EntriesCollection = await NullableArray<EntryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClientQuotasResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _entriesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or `0` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or `0` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or `null` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or `null` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private NullableArray<EntryData> _entriesCollection = Array.Empty<EntryData>();
		/// <summary>
		/// <para>A result entry.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<EntryData>? EntriesCollection 
		{
			get => _entriesCollection;
			private set 
			{
				_entriesCollection = value;
			}
		}

		/// <summary>
		/// <para>A result entry.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithEntriesCollection(params Func<EntryData, EntryData>[] createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(new EntryData(Version)))
				.ToArray();
			return this;
		}

		public delegate EntryData CreateEntryData(EntryData field);

		/// <summary>
		/// <para>A result entry.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithEntriesCollection(IEnumerable<CreateEntryData> createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(new EntryData(Version)))
				.ToArray();
			return this;
		}

		public class EntryData : ISerialize
		{
			internal EntryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_entityCollection.GetSize(IsFlexibleVersion) +
				_valuesCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<EntryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new EntryData(version);
				instance.EntityCollection = await Array<EntityData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntityData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.ValuesCollection = await Array<ValueData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ValueData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for EntryData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _entityCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _valuesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Array<EntityData> _entityCollection = Array.Empty<EntityData>();
			/// <summary>
			/// <para>The quota entity description.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<EntityData> EntityCollection 
			{
				get => _entityCollection;
				private set 
				{
					_entityCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota entity description.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(params Func<EntityData, EntityData>[] createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(new EntityData(Version)))
					.ToArray();
				return this;
			}

			public delegate EntityData CreateEntityData(EntityData field);

			/// <summary>
			/// <para>The quota entity description.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(IEnumerable<CreateEntityData> createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(new EntityData(Version)))
					.ToArray();
				return this;
			}

			public class EntityData : ISerialize
			{
				internal EntityData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_entityType.GetSize(IsFlexibleVersion) +
					_entityName.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<EntityData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EntityData(version);
					instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.EntityName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EntityData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _entityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _entityName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _entityType = String.Default;
				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String EntityType 
				{
					get => _entityType;
					private set 
					{
						_entityType = value;
					}
				}

				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityType(String entityType)
				{
					EntityType = entityType;
					return this;
				}

				private NullableString _entityName = NullableString.Default;
				/// <summary>
				/// <para>The entity name, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? EntityName 
				{
					get => _entityName;
					private set 
					{
						_entityName = value;
					}
				}

				/// <summary>
				/// <para>The entity name, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityName(String? entityName)
				{
					EntityName = entityName;
					return this;
				}
			}

			private Array<ValueData> _valuesCollection = Array.Empty<ValueData>();
			/// <summary>
			/// <para>The quota values for the entity.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<ValueData> ValuesCollection 
			{
				get => _valuesCollection;
				private set 
				{
					_valuesCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota values for the entity.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithValuesCollection(params Func<ValueData, ValueData>[] createFields)
			{
				ValuesCollection = createFields
					.Select(createField => createField(new ValueData(Version)))
					.ToArray();
				return this;
			}

			public delegate ValueData CreateValueData(ValueData field);

			/// <summary>
			/// <para>The quota values for the entity.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithValuesCollection(IEnumerable<CreateValueData> createFields)
			{
				ValuesCollection = createFields
					.Select(createField => createField(new ValueData(Version)))
					.ToArray();
				return this;
			}

			public class ValueData : ISerialize
			{
				internal ValueData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_key.GetSize(IsFlexibleVersion) +
					_value.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<ValueData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ValueData(version);
					instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Value = await Float64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ValueData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _key = String.Default;
				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Key 
				{
					get => _key;
					private set 
					{
						_key = value;
					}
				}

				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ValueData WithKey(String key)
				{
					Key = key;
					return this;
				}

				private Float64 _value = Float64.Default;
				/// <summary>
				/// <para>The quota configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Float64 Value 
				{
					get => _value;
					private set 
					{
						_value = value;
					}
				}

				/// <summary>
				/// <para>The quota configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ValueData WithValue(Float64 value)
				{
					Value = value;
					return this;
				}
			}
		}
	}

	public class DescribeClusterRequest : Message, IRespond<DescribeClusterResponse>
	{
		public DescribeClusterRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeClusterRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(60);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_includeClusterAuthorizedOperations.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_endpointType.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeClusterRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClusterRequest(version);
			instance.IncludeClusterAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.EndpointType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClusterRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _includeClusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _endpointType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Boolean _includeClusterAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean IncludeClusterAuthorizedOperations 
		{
			get => _includeClusterAuthorizedOperations;
			private set 
			{
				_includeClusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterRequest WithIncludeClusterAuthorizedOperations(Boolean includeClusterAuthorizedOperations)
		{
			IncludeClusterAuthorizedOperations = includeClusterAuthorizedOperations;
			return this;
		}

		private Int8 _endpointType = new Int8(1);
		/// <summary>
		/// <para>The endpoint type to describe. 1=brokers, 2=controllers.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 1</para>
		/// </summary>
		public Int8 EndpointType 
		{
			get => _endpointType;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"EndpointType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_endpointType = value;
			}
		}

		/// <summary>
		/// <para>The endpoint type to describe. 1=brokers, 2=controllers.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 1</para>
		/// </summary>
		public DescribeClusterRequest WithEndpointType(Int8 endpointType)
		{
			EndpointType = endpointType;
			return this;
		}

		public DescribeClusterResponse Respond()
			=> new DescribeClusterResponse(Version);
	}

	public class DescribeClusterResponse : Message
	{
		public DescribeClusterResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeClusterResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(60);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_endpointType.GetSize(IsFlexibleVersion):
				0) +
			_clusterId.GetSize(IsFlexibleVersion) +
			_controllerId.GetSize(IsFlexibleVersion) +
			_brokersCollection.GetSize(IsFlexibleVersion) +
			_clusterAuthorizedOperations.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeClusterResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClusterResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.EndpointType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokersCollection = await Map<Int32, DescribeClusterBroker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeClusterBroker.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.BrokerId, cancellationToken).ConfigureAwait(false);
			instance.ClusterAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClusterResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _endpointType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _controllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _clusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = new NullableString(null);
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public DescribeClusterResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Int8 _endpointType = new Int8(1);
		/// <summary>
		/// <para>The endpoint type that was described. 1=brokers, 2=controllers.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 1</para>
		/// </summary>
		public Int8 EndpointType 
		{
			get => _endpointType;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"EndpointType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_endpointType = value;
			}
		}

		/// <summary>
		/// <para>The endpoint type that was described. 1=brokers, 2=controllers.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 1</para>
		/// </summary>
		public DescribeClusterResponse WithEndpointType(Int8 endpointType)
		{
			EndpointType = endpointType;
			return this;
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _controllerId = new Int32(-1);
		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			private set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public DescribeClusterResponse WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Map<Int32, DescribeClusterBroker> _brokersCollection = Map<Int32, DescribeClusterBroker>.Default;
		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int32, DescribeClusterBroker> BrokersCollection 
		{
			get => _brokersCollection;
			private set 
			{
				_brokersCollection = value;
			}
		}

		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithBrokersCollection(params Func<DescribeClusterBroker, DescribeClusterBroker>[] createFields)
		{
			BrokersCollection = createFields
				.Select(createField => createField(new DescribeClusterBroker(Version)))
				.ToDictionary(field => field.BrokerId);
			return this;
		}

		public delegate DescribeClusterBroker CreateDescribeClusterBroker(DescribeClusterBroker field);

		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithBrokersCollection(IEnumerable<CreateDescribeClusterBroker> createFields)
		{
			BrokersCollection = createFields
				.Select(createField => createField(new DescribeClusterBroker(Version)))
				.ToDictionary(field => field.BrokerId);
			return this;
		}

		public class DescribeClusterBroker : ISerialize
		{
			internal DescribeClusterBroker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_brokerId.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				_rack.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeClusterBroker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeClusterBroker(version);
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClusterBroker is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _brokerId = Int32.Default;
			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 BrokerId 
			{
				get => _brokerId;
				private set 
				{
					_brokerId = value;
				}
			}

			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeClusterBroker WithBrokerId(Int32 brokerId)
			{
				BrokerId = brokerId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeClusterBroker WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeClusterBroker WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private NullableString _rack = new NullableString(null);
			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DescribeClusterBroker WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}

		private Int32 _clusterAuthorizedOperations = new Int32(-2147483648);
		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public Int32 ClusterAuthorizedOperations 
		{
			get => _clusterAuthorizedOperations;
			private set 
			{
				_clusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public DescribeClusterResponse WithClusterAuthorizedOperations(Int32 clusterAuthorizedOperations)
		{
			ClusterAuthorizedOperations = clusterAuthorizedOperations;
			return this;
		}
	}

	public class DescribeConfigsRequest : Message, IRespond<DescribeConfigsResponse>
	{
		public DescribeConfigsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeConfigsRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(32);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resourcesCollection.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_includeSynonyms.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_includeDocumentation.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeConfigsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeConfigsRequest(version);
			instance.ResourcesCollection = await Array<DescribeConfigsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.IncludeSynonyms = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.IncludeDocumentation = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resourcesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _includeSynonyms.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _includeDocumentation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<DescribeConfigsResource> _resourcesCollection = Array.Empty<DescribeConfigsResource>();
		/// <summary>
		/// <para>The resources whose configurations we want to describe.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribeConfigsResource> ResourcesCollection 
		{
			get => _resourcesCollection;
			private set 
			{
				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>The resources whose configurations we want to describe.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsRequest WithResourcesCollection(params Func<DescribeConfigsResource, DescribeConfigsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new DescribeConfigsResource(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribeConfigsResource CreateDescribeConfigsResource(DescribeConfigsResource field);

		/// <summary>
		/// <para>The resources whose configurations we want to describe.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsRequest WithResourcesCollection(IEnumerable<CreateDescribeConfigsResource> createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new DescribeConfigsResource(Version)))
				.ToArray();
			return this;
		}

		public class DescribeConfigsResource : ISerialize
		{
			internal DescribeConfigsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				_configurationKeysCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeConfigsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeConfigsResource(version);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ConfigurationKeysCollection = await NullableArray<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResource is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _configurationKeysCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private NullableArray<String> _configurationKeysCollection = Array.Empty<String>();
			/// <summary>
			/// <para>The configuration keys to list, or null to list all configuration keys.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<String>? ConfigurationKeysCollection 
			{
				get => _configurationKeysCollection;
				private set 
				{
					_configurationKeysCollection = value;
				}
			}

			/// <summary>
			/// <para>The configuration keys to list, or null to list all configuration keys.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResource WithConfigurationKeysCollection(Array<String>? configurationKeysCollection)
			{
				ConfigurationKeysCollection = configurationKeysCollection;
				return this;
			}
		}

		private Boolean _includeSynonyms = new Boolean(false);
		/// <summary>
		/// <para>True if we should include all synonyms.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IncludeSynonyms 
		{
			get => _includeSynonyms;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"IncludeSynonyms does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_includeSynonyms = value;
			}
		}

		/// <summary>
		/// <para>True if we should include all synonyms.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public DescribeConfigsRequest WithIncludeSynonyms(Boolean includeSynonyms)
		{
			IncludeSynonyms = includeSynonyms;
			return this;
		}

		private Boolean _includeDocumentation = new Boolean(false);
		/// <summary>
		/// <para>True if we should include configuration documentation.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IncludeDocumentation 
		{
			get => _includeDocumentation;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"IncludeDocumentation does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_includeDocumentation = value;
			}
		}

		/// <summary>
		/// <para>True if we should include configuration documentation.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: false</para>
		/// </summary>
		public DescribeConfigsRequest WithIncludeDocumentation(Boolean includeDocumentation)
		{
			IncludeDocumentation = includeDocumentation;
			return this;
		}

		public DescribeConfigsResponse Respond()
			=> new DescribeConfigsResponse(Version);
	}

	public class DescribeConfigsResponse : Message
	{
		public DescribeConfigsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeConfigsResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(32);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeConfigsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeConfigsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<DescribeConfigsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<DescribeConfigsResult> _resultsCollection = Array.Empty<DescribeConfigsResult>();
		/// <summary>
		/// <para>The results for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribeConfigsResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResponse WithResultsCollection(params Func<DescribeConfigsResult, DescribeConfigsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DescribeConfigsResult(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribeConfigsResult CreateDescribeConfigsResult(DescribeConfigsResult field);

		/// <summary>
		/// <para>The results for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResponse WithResultsCollection(IEnumerable<CreateDescribeConfigsResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DescribeConfigsResult(Version)))
				.ToArray();
			return this;
		}

		public class DescribeConfigsResult : ISerialize
		{
			internal DescribeConfigsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				_configsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeConfigsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeConfigsResult(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ConfigsCollection = await Array<DescribeConfigsResourceResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsResourceResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _configsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The error message, or null if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Array<DescribeConfigsResourceResult> _configsCollection = Array.Empty<DescribeConfigsResourceResult>();
			/// <summary>
			/// <para>Each listed configuration.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DescribeConfigsResourceResult> ConfigsCollection 
			{
				get => _configsCollection;
				private set 
				{
					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each listed configuration.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithConfigsCollection(params Func<DescribeConfigsResourceResult, DescribeConfigsResourceResult>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new DescribeConfigsResourceResult(Version)))
					.ToArray();
				return this;
			}

			public delegate DescribeConfigsResourceResult CreateDescribeConfigsResourceResult(DescribeConfigsResourceResult field);

			/// <summary>
			/// <para>Each listed configuration.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithConfigsCollection(IEnumerable<CreateDescribeConfigsResourceResult> createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new DescribeConfigsResourceResult(Version)))
					.ToArray();
				return this;
			}

			public class DescribeConfigsResourceResult : ISerialize
			{
				internal DescribeConfigsResourceResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 4;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_value.GetSize(IsFlexibleVersion) +
					_readOnly.GetSize(IsFlexibleVersion) +
					(Version >= 0 && Version <= 0 ? 
						_isDefault.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 ? 
						_configSource.GetSize(IsFlexibleVersion):
						0) +
					_isSensitive.GetSize(IsFlexibleVersion) +
					(Version >= 1 ? 
						_synonymsCollection.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 3 ? 
						_configType.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 3 ? 
						_documentation.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DescribeConfigsResourceResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribeConfigsResourceResult(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ReadOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 0) 
						instance.IsDefault = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.ConfigSource = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.IsSensitive = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.SynonymsCollection = await Array<DescribeConfigsSynonym>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsSynonym.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 3) 
						instance.ConfigType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 3) 
						instance.Documentation = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResourceResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _readOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 0)
						await _isDefault.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _configSource.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _isSensitive.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _synonymsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 3)
						await _configType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 3)
						await _documentation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithName(String name)
				{
					Name = name;
					return this;
				}

				private NullableString _value = NullableString.Default;
				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					private set 
					{
						_value = value;
					}
				}

				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithValue(String? value)
				{
					Value = value;
					return this;
				}

				private Boolean _readOnly = Boolean.Default;
				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean ReadOnly 
				{
					get => _readOnly;
					private set 
					{
						_readOnly = value;
					}
				}

				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithReadOnly(Boolean readOnly)
				{
					ReadOnly = readOnly;
					return this;
				}

				private Boolean _isDefault = Boolean.Default;
				/// <summary>
				/// <para>True if the configuration is not set.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public Boolean IsDefault 
				{
					get => _isDefault;
					private set 
					{
						if (Version >= 0 && Version <= 0 == false)
							throw new UnsupportedVersionException($"IsDefault does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

						_isDefault = value;
					}
				}

				/// <summary>
				/// <para>True if the configuration is not set.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public DescribeConfigsResourceResult WithIsDefault(Boolean isDefault)
				{
					IsDefault = isDefault;
					return this;
				}

				private Int8 _configSource = new Int8(-1);
				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int8 ConfigSource 
				{
					get => _configSource;
					private set 
					{
						_configSource = value;
					}
				}

				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public DescribeConfigsResourceResult WithConfigSource(Int8 configSource)
				{
					ConfigSource = configSource;
					return this;
				}

				private Boolean _isSensitive = Boolean.Default;
				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean IsSensitive 
				{
					get => _isSensitive;
					private set 
					{
						_isSensitive = value;
					}
				}

				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithIsSensitive(Boolean isSensitive)
				{
					IsSensitive = isSensitive;
					return this;
				}

				private Array<DescribeConfigsSynonym> _synonymsCollection = Array.Empty<DescribeConfigsSynonym>();
				/// <summary>
				/// <para>The synonyms for this configuration key.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public Array<DescribeConfigsSynonym> SynonymsCollection 
				{
					get => _synonymsCollection;
					private set 
					{
						_synonymsCollection = value;
					}
				}

				/// <summary>
				/// <para>The synonyms for this configuration key.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithSynonymsCollection(params Func<DescribeConfigsSynonym, DescribeConfigsSynonym>[] createFields)
				{
					SynonymsCollection = createFields
						.Select(createField => createField(new DescribeConfigsSynonym(Version)))
						.ToArray();
					return this;
				}

				public delegate DescribeConfigsSynonym CreateDescribeConfigsSynonym(DescribeConfigsSynonym field);

				/// <summary>
				/// <para>The synonyms for this configuration key.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithSynonymsCollection(IEnumerable<CreateDescribeConfigsSynonym> createFields)
				{
					SynonymsCollection = createFields
						.Select(createField => createField(new DescribeConfigsSynonym(Version)))
						.ToArray();
					return this;
				}

				public class DescribeConfigsSynonym : ISerialize
				{
					internal DescribeConfigsSynonym(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 4;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 1 ? 
							_name.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 1 ? 
							_value.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 1 ? 
							_source.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<DescribeConfigsSynonym> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new DescribeConfigsSynonym(version);
						if (instance.Version >= 1) 
							instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 1) 
							instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 1) 
							instance.Source = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsSynonym is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 1)
							await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 1)
							await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 1)
							await _source.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private String _name = String.Default;
					/// <summary>
					/// <para>The synonym name.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public String Name 
					{
						get => _name;
						private set 
						{
							if (Version >= 1 == false)
								throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

							_name = value;
						}
					}

					/// <summary>
					/// <para>The synonym name.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public DescribeConfigsSynonym WithName(String name)
					{
						Name = name;
						return this;
					}

					private NullableString _value = NullableString.Default;
					/// <summary>
					/// <para>The synonym value.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public String? Value 
					{
						get => _value;
						private set 
						{
							if (Version >= 1 == false)
								throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

							_value = value;
						}
					}

					/// <summary>
					/// <para>The synonym value.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public DescribeConfigsSynonym WithValue(String? value)
					{
						Value = value;
						return this;
					}

					private Int8 _source = Int8.Default;
					/// <summary>
					/// <para>The synonym source.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public Int8 Source 
					{
						get => _source;
						private set 
						{
							if (Version >= 1 == false)
								throw new UnsupportedVersionException($"Source does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

							_source = value;
						}
					}

					/// <summary>
					/// <para>The synonym source.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public DescribeConfigsSynonym WithSource(Int8 source)
					{
						Source = source;
						return this;
					}
				}

				private Int8 _configType = new Int8(0);
				/// <summary>
				/// <para>The configuration data type. Type can be one of the following values - BOOLEAN, STRING, INT, SHORT, LONG, DOUBLE, LIST, CLASS, PASSWORD</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public Int8 ConfigType 
				{
					get => _configType;
					private set 
					{
						_configType = value;
					}
				}

				/// <summary>
				/// <para>The configuration data type. Type can be one of the following values - BOOLEAN, STRING, INT, SHORT, LONG, DOUBLE, LIST, CLASS, PASSWORD</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public DescribeConfigsResourceResult WithConfigType(Int8 configType)
				{
					ConfigType = configType;
					return this;
				}

				private NullableString _documentation = NullableString.Default;
				/// <summary>
				/// <para>The configuration documentation.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public String? Documentation 
				{
					get => _documentation;
					private set 
					{
						_documentation = value;
					}
				}

				/// <summary>
				/// <para>The configuration documentation.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithDocumentation(String? documentation)
				{
					Documentation = documentation;
					return this;
				}
			}
		}
	}

	public class DescribeDelegationTokenRequest : Message, IRespond<DescribeDelegationTokenResponse>
	{
		public DescribeDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeDelegationTokenRequest does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(41);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_ownersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeDelegationTokenRequest(version);
			instance.OwnersCollection = await NullableArray<DescribeDelegationTokenOwner>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeDelegationTokenOwner.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _ownersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableArray<DescribeDelegationTokenOwner> _ownersCollection = Array.Empty<DescribeDelegationTokenOwner>();
		/// <summary>
		/// <para>Each owner that we want to describe delegation tokens for, or null to describe all tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribeDelegationTokenOwner>? OwnersCollection 
		{
			get => _ownersCollection;
			private set 
			{
				_ownersCollection = value;
			}
		}

		/// <summary>
		/// <para>Each owner that we want to describe delegation tokens for, or null to describe all tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenRequest WithOwnersCollection(params Func<DescribeDelegationTokenOwner, DescribeDelegationTokenOwner>[] createFields)
		{
			OwnersCollection = createFields
				.Select(createField => createField(new DescribeDelegationTokenOwner(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribeDelegationTokenOwner CreateDescribeDelegationTokenOwner(DescribeDelegationTokenOwner field);

		/// <summary>
		/// <para>Each owner that we want to describe delegation tokens for, or null to describe all tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenRequest WithOwnersCollection(IEnumerable<CreateDescribeDelegationTokenOwner> createFields)
		{
			OwnersCollection = createFields
				.Select(createField => createField(new DescribeDelegationTokenOwner(Version)))
				.ToArray();
			return this;
		}

		public class DescribeDelegationTokenOwner : ISerialize
		{
			internal DescribeDelegationTokenOwner(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_principalType.GetSize(IsFlexibleVersion) +
				_principalName.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeDelegationTokenOwner> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeDelegationTokenOwner(version);
				instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeDelegationTokenOwner is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _principalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _principalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _principalType = String.Default;
			/// <summary>
			/// <para>The owner principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalType 
			{
				get => _principalType;
				private set 
				{
					_principalType = value;
				}
			}

			/// <summary>
			/// <para>The owner principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeDelegationTokenOwner WithPrincipalType(String principalType)
			{
				PrincipalType = principalType;
				return this;
			}

			private String _principalName = String.Default;
			/// <summary>
			/// <para>The owner principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalName 
			{
				get => _principalName;
				private set 
				{
					_principalName = value;
				}
			}

			/// <summary>
			/// <para>The owner principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeDelegationTokenOwner WithPrincipalName(String principalName)
			{
				PrincipalName = principalName;
				return this;
			}
		}

		public DescribeDelegationTokenResponse Respond()
			=> new DescribeDelegationTokenResponse(Version);
	}

	public class DescribeDelegationTokenResponse : Message
	{
		public DescribeDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeDelegationTokenResponse does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(41);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_tokensCollection.GetSize(IsFlexibleVersion) +
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeDelegationTokenResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TokensCollection = await Array<DescribedDelegationToken>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedDelegationToken.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _tokensCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<DescribedDelegationToken> _tokensCollection = Array.Empty<DescribedDelegationToken>();
		/// <summary>
		/// <para>The tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribedDelegationToken> TokensCollection 
		{
			get => _tokensCollection;
			private set 
			{
				_tokensCollection = value;
			}
		}

		/// <summary>
		/// <para>The tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithTokensCollection(params Func<DescribedDelegationToken, DescribedDelegationToken>[] createFields)
		{
			TokensCollection = createFields
				.Select(createField => createField(new DescribedDelegationToken(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribedDelegationToken CreateDescribedDelegationToken(DescribedDelegationToken field);

		/// <summary>
		/// <para>The tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithTokensCollection(IEnumerable<CreateDescribedDelegationToken> createFields)
		{
			TokensCollection = createFields
				.Select(createField => createField(new DescribedDelegationToken(Version)))
				.ToArray();
			return this;
		}

		public class DescribedDelegationToken : ISerialize
		{
			internal DescribedDelegationToken(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_principalType.GetSize(IsFlexibleVersion) +
				_principalName.GetSize(IsFlexibleVersion) +
				(Version >= 3 ? 
					_tokenRequesterPrincipalType.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_tokenRequesterPrincipalName.GetSize(IsFlexibleVersion):
					0) +
				_issueTimestamp.GetSize(IsFlexibleVersion) +
				_expiryTimestamp.GetSize(IsFlexibleVersion) +
				_maxTimestamp.GetSize(IsFlexibleVersion) +
				_tokenId.GetSize(IsFlexibleVersion) +
				_hmac.GetSize(IsFlexibleVersion) +
				_renewersCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribedDelegationToken> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribedDelegationToken(version);
				instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.TokenRequesterPrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.TokenRequesterPrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.IssueTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ExpiryTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MaxTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TokenId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.RenewersCollection = await Array<DescribedDelegationTokenRenewer>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedDelegationTokenRenewer.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedDelegationToken is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _principalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _principalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _tokenRequesterPrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _tokenRequesterPrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _issueTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _expiryTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _maxTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _tokenId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _renewersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _principalType = String.Default;
			/// <summary>
			/// <para>The token principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalType 
			{
				get => _principalType;
				private set 
				{
					_principalType = value;
				}
			}

			/// <summary>
			/// <para>The token principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithPrincipalType(String principalType)
			{
				PrincipalType = principalType;
				return this;
			}

			private String _principalName = String.Default;
			/// <summary>
			/// <para>The token principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalName 
			{
				get => _principalName;
				private set 
				{
					_principalName = value;
				}
			}

			/// <summary>
			/// <para>The token principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithPrincipalName(String principalName)
			{
				PrincipalName = principalName;
				return this;
			}

			private String _tokenRequesterPrincipalType = String.Default;
			/// <summary>
			/// <para>The principal type of the requester of the token.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String TokenRequesterPrincipalType 
			{
				get => _tokenRequesterPrincipalType;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"TokenRequesterPrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_tokenRequesterPrincipalType = value;
				}
			}

			/// <summary>
			/// <para>The principal type of the requester of the token.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public DescribedDelegationToken WithTokenRequesterPrincipalType(String tokenRequesterPrincipalType)
			{
				TokenRequesterPrincipalType = tokenRequesterPrincipalType;
				return this;
			}

			private String _tokenRequesterPrincipalName = String.Default;
			/// <summary>
			/// <para>The principal type of the requester of the token.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String TokenRequesterPrincipalName 
			{
				get => _tokenRequesterPrincipalName;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"TokenRequesterPrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_tokenRequesterPrincipalName = value;
				}
			}

			/// <summary>
			/// <para>The principal type of the requester of the token.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public DescribedDelegationToken WithTokenRequesterPrincipalName(String tokenRequesterPrincipalName)
			{
				TokenRequesterPrincipalName = tokenRequesterPrincipalName;
				return this;
			}

			private Int64 _issueTimestamp = Int64.Default;
			/// <summary>
			/// <para>The token issue timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 IssueTimestamp 
			{
				get => _issueTimestamp;
				private set 
				{
					_issueTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The token issue timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithIssueTimestamp(Int64 issueTimestamp)
			{
				IssueTimestamp = issueTimestamp;
				return this;
			}

			private Int64 _expiryTimestamp = Int64.Default;
			/// <summary>
			/// <para>The token expiry timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ExpiryTimestamp 
			{
				get => _expiryTimestamp;
				private set 
				{
					_expiryTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The token expiry timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithExpiryTimestamp(Int64 expiryTimestamp)
			{
				ExpiryTimestamp = expiryTimestamp;
				return this;
			}

			private Int64 _maxTimestamp = Int64.Default;
			/// <summary>
			/// <para>The token maximum timestamp length in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 MaxTimestamp 
			{
				get => _maxTimestamp;
				private set 
				{
					_maxTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The token maximum timestamp length in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithMaxTimestamp(Int64 maxTimestamp)
			{
				MaxTimestamp = maxTimestamp;
				return this;
			}

			private String _tokenId = String.Default;
			/// <summary>
			/// <para>The token ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TokenId 
			{
				get => _tokenId;
				private set 
				{
					_tokenId = value;
				}
			}

			/// <summary>
			/// <para>The token ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithTokenId(String tokenId)
			{
				TokenId = tokenId;
				return this;
			}

			private Bytes _hmac = Bytes.Default;
			/// <summary>
			/// <para>The token HMAC.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Hmac 
			{
				get => _hmac;
				private set 
				{
					_hmac = value;
				}
			}

			/// <summary>
			/// <para>The token HMAC.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithHmac(Bytes hmac)
			{
				Hmac = hmac;
				return this;
			}

			private Array<DescribedDelegationTokenRenewer> _renewersCollection = Array.Empty<DescribedDelegationTokenRenewer>();
			/// <summary>
			/// <para>Those who are able to renew this token before it expires.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DescribedDelegationTokenRenewer> RenewersCollection 
			{
				get => _renewersCollection;
				private set 
				{
					_renewersCollection = value;
				}
			}

			/// <summary>
			/// <para>Those who are able to renew this token before it expires.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithRenewersCollection(params Func<DescribedDelegationTokenRenewer, DescribedDelegationTokenRenewer>[] createFields)
			{
				RenewersCollection = createFields
					.Select(createField => createField(new DescribedDelegationTokenRenewer(Version)))
					.ToArray();
				return this;
			}

			public delegate DescribedDelegationTokenRenewer CreateDescribedDelegationTokenRenewer(DescribedDelegationTokenRenewer field);

			/// <summary>
			/// <para>Those who are able to renew this token before it expires.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithRenewersCollection(IEnumerable<CreateDescribedDelegationTokenRenewer> createFields)
			{
				RenewersCollection = createFields
					.Select(createField => createField(new DescribedDelegationTokenRenewer(Version)))
					.ToArray();
				return this;
			}

			public class DescribedDelegationTokenRenewer : ISerialize
			{
				internal DescribedDelegationTokenRenewer(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_principalType.GetSize(IsFlexibleVersion) +
					_principalName.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DescribedDelegationTokenRenewer> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribedDelegationTokenRenewer(version);
					instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedDelegationTokenRenewer is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _principalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _principalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _principalType = String.Default;
				/// <summary>
				/// <para>The renewer principal type</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String PrincipalType 
				{
					get => _principalType;
					private set 
					{
						_principalType = value;
					}
				}

				/// <summary>
				/// <para>The renewer principal type</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedDelegationTokenRenewer WithPrincipalType(String principalType)
				{
					PrincipalType = principalType;
					return this;
				}

				private String _principalName = String.Default;
				/// <summary>
				/// <para>The renewer principal name</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String PrincipalName 
				{
					get => _principalName;
					private set 
					{
						_principalName = value;
					}
				}

				/// <summary>
				/// <para>The renewer principal name</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedDelegationTokenRenewer WithPrincipalName(String principalName)
				{
					PrincipalName = principalName;
					return this;
				}
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class DescribeGroupsRequest : Message, IRespond<DescribeGroupsResponse>
	{
		public DescribeGroupsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeGroupsRequest does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 5;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(15);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupsCollection.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_includeAuthorizedOperations.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeGroupsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeGroupsRequest(version);
			instance.GroupsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.IncludeAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeGroupsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _includeAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _groupsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The names of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>The names of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeGroupsRequest WithGroupsCollection(Array<String> groupsCollection)
		{
			GroupsCollection = groupsCollection;
			return this;
		}

		private Boolean _includeAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Boolean IncludeAuthorizedOperations 
		{
			get => _includeAuthorizedOperations;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"IncludeAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_includeAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public DescribeGroupsRequest WithIncludeAuthorizedOperations(Boolean includeAuthorizedOperations)
		{
			IncludeAuthorizedOperations = includeAuthorizedOperations;
			return this;
		}

		public DescribeGroupsResponse Respond()
			=> new DescribeGroupsResponse(Version);
	}

	public class DescribeGroupsResponse : Message
	{
		public DescribeGroupsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeGroupsResponse does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 5;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(15);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_groupsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeGroupsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeGroupsResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GroupsCollection = await Array<DescribedGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeGroupsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public DescribeGroupsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<DescribedGroup> _groupsCollection = Array.Empty<DescribedGroup>();
		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribedGroup> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeGroupsResponse WithGroupsCollection(params Func<DescribedGroup, DescribedGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new DescribedGroup(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribedGroup CreateDescribedGroup(DescribedGroup field);

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeGroupsResponse WithGroupsCollection(IEnumerable<CreateDescribedGroup> createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new DescribedGroup(Version)))
				.ToArray();
			return this;
		}

		public class DescribedGroup : ISerialize
		{
			internal DescribedGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 5;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_groupId.GetSize(IsFlexibleVersion) +
				_groupState.GetSize(IsFlexibleVersion) +
				_protocolType.GetSize(IsFlexibleVersion) +
				_protocolData.GetSize(IsFlexibleVersion) +
				_membersCollection.GetSize(IsFlexibleVersion) +
				(Version >= 3 ? 
					_authorizedOperations.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribedGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribedGroup(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupState = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProtocolType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProtocolData = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MembersCollection = await Array<DescribedGroupMember>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedGroupMember.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.AuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedGroup is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _protocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _protocolData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _membersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _authorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private String _groupState = String.Default;
			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupState 
			{
				get => _groupState;
				private set 
				{
					_groupState = value;
				}
			}

			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupState(String groupState)
			{
				GroupState = groupState;
				return this;
			}

			private String _protocolType = String.Default;
			/// <summary>
			/// <para>The group protocol type, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ProtocolType 
			{
				get => _protocolType;
				private set 
				{
					_protocolType = value;
				}
			}

			/// <summary>
			/// <para>The group protocol type, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithProtocolType(String protocolType)
			{
				ProtocolType = protocolType;
				return this;
			}

			private String _protocolData = String.Default;
			/// <summary>
			/// <para>The group protocol data, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ProtocolData 
			{
				get => _protocolData;
				private set 
				{
					_protocolData = value;
				}
			}

			/// <summary>
			/// <para>The group protocol data, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithProtocolData(String protocolData)
			{
				ProtocolData = protocolData;
				return this;
			}

			private Array<DescribedGroupMember> _membersCollection = Array.Empty<DescribedGroupMember>();
			/// <summary>
			/// <para>The group members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DescribedGroupMember> MembersCollection 
			{
				get => _membersCollection;
				private set 
				{
					_membersCollection = value;
				}
			}

			/// <summary>
			/// <para>The group members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(params Func<DescribedGroupMember, DescribedGroupMember>[] createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(new DescribedGroupMember(Version)))
					.ToArray();
				return this;
			}

			public delegate DescribedGroupMember CreateDescribedGroupMember(DescribedGroupMember field);

			/// <summary>
			/// <para>The group members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(IEnumerable<CreateDescribedGroupMember> createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(new DescribedGroupMember(Version)))
					.ToArray();
				return this;
			}

			public class DescribedGroupMember : ISerialize
			{
				internal DescribedGroupMember(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 5;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_memberId.GetSize(IsFlexibleVersion) +
					(Version >= 4 ? 
						_groupInstanceId.GetSize(IsFlexibleVersion):
						0) +
					_clientId.GetSize(IsFlexibleVersion) +
					_clientHost.GetSize(IsFlexibleVersion) +
					_memberMetadata.GetSize(IsFlexibleVersion) +
					_memberAssignment.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DescribedGroupMember> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribedGroupMember(version);
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 4) 
						instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ClientId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ClientHost = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.MemberMetadata = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.MemberAssignment = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedGroupMember is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 4)
						await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _clientId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _clientHost.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _memberMetadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _memberAssignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _memberId = String.Default;
				/// <summary>
				/// <para>The member ID assigned by the group coordinator.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String MemberId 
				{
					get => _memberId;
					private set 
					{
						_memberId = value;
					}
				}

				/// <summary>
				/// <para>The member ID assigned by the group coordinator.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithMemberId(String memberId)
				{
					MemberId = memberId;
					return this;
				}

				private NullableString _groupInstanceId = new NullableString(null);
				/// <summary>
				/// <para>The unique identifier of the consumer instance provided by end user.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? GroupInstanceId 
				{
					get => _groupInstanceId;
					private set 
					{
						if (Version >= 4 == false &&
							value == null) 
							throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 4+");

						_groupInstanceId = value;
					}
				}

				/// <summary>
				/// <para>The unique identifier of the consumer instance provided by end user.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: null</para>
				/// </summary>
				public DescribedGroupMember WithGroupInstanceId(String? groupInstanceId)
				{
					GroupInstanceId = groupInstanceId;
					return this;
				}

				private String _clientId = String.Default;
				/// <summary>
				/// <para>The client ID used in the member's latest join group request.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientId 
				{
					get => _clientId;
					private set 
					{
						_clientId = value;
					}
				}

				/// <summary>
				/// <para>The client ID used in the member's latest join group request.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithClientId(String clientId)
				{
					ClientId = clientId;
					return this;
				}

				private String _clientHost = String.Default;
				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientHost 
				{
					get => _clientHost;
					private set 
					{
						_clientHost = value;
					}
				}

				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithClientHost(String clientHost)
				{
					ClientHost = clientHost;
					return this;
				}

				private Bytes _memberMetadata = Bytes.Default;
				/// <summary>
				/// <para>The metadata corresponding to the current group protocol in use.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Bytes MemberMetadata 
				{
					get => _memberMetadata;
					private set 
					{
						_memberMetadata = value;
					}
				}

				/// <summary>
				/// <para>The metadata corresponding to the current group protocol in use.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithMemberMetadata(Bytes memberMetadata)
				{
					MemberMetadata = memberMetadata;
					return this;
				}

				private Bytes _memberAssignment = Bytes.Default;
				/// <summary>
				/// <para>The current assignment provided by the group leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Bytes MemberAssignment 
				{
					get => _memberAssignment;
					private set 
					{
						_memberAssignment = value;
					}
				}

				/// <summary>
				/// <para>The current assignment provided by the group leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithMemberAssignment(Bytes memberAssignment)
				{
					MemberAssignment = memberAssignment;
					return this;
				}
			}

			private Int32 _authorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 AuthorizedOperations 
			{
				get => _authorizedOperations;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"AuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_authorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public DescribedGroup WithAuthorizedOperations(Int32 authorizedOperations)
			{
				AuthorizedOperations = authorizedOperations;
				return this;
			}
		}
	}

	public class DescribeLogDirsRequest : Message, IRespond<DescribeLogDirsResponse>
	{
		public DescribeLogDirsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeLogDirsRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(35);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeLogDirsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeLogDirsRequest(version);
			instance.TopicsCollection = await NullableMap<String, DescribableLogDirTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribableLogDirTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableMap<String, DescribableLogDirTopic> _topicsCollection = NullableMap<String, DescribableLogDirTopic>.Default;
		/// <summary>
		/// <para>Each topic that we want to describe log directories for, or null for all topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, DescribableLogDirTopic>? TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to describe log directories for, or null for all topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsRequest WithTopicsCollection(params Func<DescribableLogDirTopic, DescribableLogDirTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DescribableLogDirTopic(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public delegate DescribableLogDirTopic CreateDescribableLogDirTopic(DescribableLogDirTopic field);

		/// <summary>
		/// <para>Each topic that we want to describe log directories for, or null for all topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsRequest WithTopicsCollection(IEnumerable<CreateDescribableLogDirTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DescribableLogDirTopic(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public class DescribableLogDirTopic : ISerialize
		{
			internal DescribableLogDirTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topic.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribableLogDirTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribableLogDirTopic(version);
				instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribableLogDirTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribableLogDirTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribableLogDirTopic WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public DescribeLogDirsResponse Respond()
			=> new DescribeLogDirsResponse(Version);
	}

	public class DescribeLogDirsResponse : Message
	{
		public DescribeLogDirsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeLogDirsResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(35);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_errorCode.GetSize(IsFlexibleVersion):
				0) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeLogDirsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeLogDirsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<DescribeLogDirsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeLogDirsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public DescribeLogDirsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<DescribeLogDirsResult> _resultsCollection = Array.Empty<DescribeLogDirsResult>();
		/// <summary>
		/// <para>The log directories.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribeLogDirsResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The log directories.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsResponse WithResultsCollection(params Func<DescribeLogDirsResult, DescribeLogDirsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DescribeLogDirsResult(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribeLogDirsResult CreateDescribeLogDirsResult(DescribeLogDirsResult field);

		/// <summary>
		/// <para>The log directories.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsResponse WithResultsCollection(IEnumerable<CreateDescribeLogDirsResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DescribeLogDirsResult(Version)))
				.ToArray();
			return this;
		}

		public class DescribeLogDirsResult : ISerialize
		{
			internal DescribeLogDirsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_logDir.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				(Version >= 4 ? 
					_totalBytes.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_usableBytes.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeLogDirsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeLogDirsResult(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.LogDir = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Array<DescribeLogDirsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeLogDirsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.TotalBytes = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.UsableBytes = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _logDir.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _totalBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _usableBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String _logDir = String.Default;
			/// <summary>
			/// <para>The absolute log directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String LogDir 
			{
				get => _logDir;
				private set 
				{
					_logDir = value;
				}
			}

			/// <summary>
			/// <para>The absolute log directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithLogDir(String logDir)
			{
				LogDir = logDir;
				return this;
			}

			private Array<DescribeLogDirsTopic> _topicsCollection = Array.Empty<DescribeLogDirsTopic>();
			/// <summary>
			/// <para>Each topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DescribeLogDirsTopic> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithTopicsCollection(params Func<DescribeLogDirsTopic, DescribeLogDirsTopic>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new DescribeLogDirsTopic(Version)))
					.ToArray();
				return this;
			}

			public delegate DescribeLogDirsTopic CreateDescribeLogDirsTopic(DescribeLogDirsTopic field);

			/// <summary>
			/// <para>Each topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithTopicsCollection(IEnumerable<CreateDescribeLogDirsTopic> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new DescribeLogDirsTopic(Version)))
					.ToArray();
				return this;
			}

			public class DescribeLogDirsTopic : ISerialize
			{
				internal DescribeLogDirsTopic(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_partitionsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DescribeLogDirsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribeLogDirsTopic(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionsCollection = await Array<DescribeLogDirsPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeLogDirsPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsTopic is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeLogDirsTopic WithName(String name)
				{
					Name = name;
					return this;
				}

				private Array<DescribeLogDirsPartition> _partitionsCollection = Array.Empty<DescribeLogDirsPartition>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<DescribeLogDirsPartition> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeLogDirsTopic WithPartitionsCollection(params Func<DescribeLogDirsPartition, DescribeLogDirsPartition>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new DescribeLogDirsPartition(Version)))
						.ToArray();
					return this;
				}

				public delegate DescribeLogDirsPartition CreateDescribeLogDirsPartition(DescribeLogDirsPartition field);

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeLogDirsTopic WithPartitionsCollection(IEnumerable<CreateDescribeLogDirsPartition> createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new DescribeLogDirsPartition(Version)))
						.ToArray();
					return this;
				}

				public class DescribeLogDirsPartition : ISerialize
				{
					internal DescribeLogDirsPartition(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 2;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_partitionIndex.GetSize(IsFlexibleVersion) +
						_partitionSize.GetSize(IsFlexibleVersion) +
						_offsetLag.GetSize(IsFlexibleVersion) +
						_isFutureKey.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<DescribeLogDirsPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new DescribeLogDirsPartition(version);
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.PartitionSize = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.OffsetLag = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.IsFutureKey = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsPartition is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _partitionSize.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _offsetLag.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _isFutureKey.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						private set 
						{
							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int64 _partitionSize = Int64.Default;
					/// <summary>
					/// <para>The size of the log segments in this partition in bytes.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 PartitionSize 
					{
						get => _partitionSize;
						private set 
						{
							_partitionSize = value;
						}
					}

					/// <summary>
					/// <para>The size of the log segments in this partition in bytes.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithPartitionSize(Int64 partitionSize)
					{
						PartitionSize = partitionSize;
						return this;
					}

					private Int64 _offsetLag = Int64.Default;
					/// <summary>
					/// <para>The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 OffsetLag 
					{
						get => _offsetLag;
						private set 
						{
							_offsetLag = value;
						}
					}

					/// <summary>
					/// <para>The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithOffsetLag(Int64 offsetLag)
					{
						OffsetLag = offsetLag;
						return this;
					}

					private Boolean _isFutureKey = Boolean.Default;
					/// <summary>
					/// <para>True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Boolean IsFutureKey 
					{
						get => _isFutureKey;
						private set 
						{
							_isFutureKey = value;
						}
					}

					/// <summary>
					/// <para>True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithIsFutureKey(Boolean isFutureKey)
					{
						IsFutureKey = isFutureKey;
						return this;
					}
				}
			}

			private Int64 _totalBytes = new Int64(-1);
			/// <summary>
			/// <para>The total size in bytes of the volume the log directory is in.</para>
			/// <para>Versions: 4+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int64 TotalBytes 
			{
				get => _totalBytes;
				private set 
				{
					_totalBytes = value;
				}
			}

			/// <summary>
			/// <para>The total size in bytes of the volume the log directory is in.</para>
			/// <para>Versions: 4+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public DescribeLogDirsResult WithTotalBytes(Int64 totalBytes)
			{
				TotalBytes = totalBytes;
				return this;
			}

			private Int64 _usableBytes = new Int64(-1);
			/// <summary>
			/// <para>The usable size in bytes of the volume the log directory is in.</para>
			/// <para>Versions: 4+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int64 UsableBytes 
			{
				get => _usableBytes;
				private set 
				{
					_usableBytes = value;
				}
			}

			/// <summary>
			/// <para>The usable size in bytes of the volume the log directory is in.</para>
			/// <para>Versions: 4+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public DescribeLogDirsResult WithUsableBytes(Int64 usableBytes)
			{
				UsableBytes = usableBytes;
				return this;
			}
		}
	}

	public class DescribeProducersRequest : Message, IRespond<DescribeProducersResponse>
	{
		public DescribeProducersRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeProducersRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(61);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeProducersRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeProducersRequest(version);
			instance.TopicsCollection = await Array<TopicRequest>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicRequest.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeProducersRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<TopicRequest> _topicsCollection = Array.Empty<TopicRequest>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicRequest> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersRequest WithTopicsCollection(params Func<TopicRequest, TopicRequest>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicRequest(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicRequest CreateTopicRequest(TopicRequest field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersRequest WithTopicsCollection(IEnumerable<CreateTopicRequest> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicRequest(Version)))
				.ToArray();
			return this;
		}

		public class TopicRequest : ISerialize
		{
			internal TopicRequest(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionIndexesCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicRequest(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicRequest is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndexesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicRequest WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<Int32> _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The indexes of the partitions to list producers for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				private set 
				{
					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The indexes of the partitions to list producers for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicRequest WithPartitionIndexesCollection(Array<Int32> partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		public DescribeProducersResponse Respond()
			=> new DescribeProducersResponse(Version);
	}

	public class DescribeProducersResponse : Message
	{
		public DescribeProducersResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeProducersResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(61);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeProducersResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeProducersResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeProducersResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<TopicResponse> _topicsCollection = Array.Empty<TopicResponse>();
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicResponse> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersResponse WithTopicsCollection(params Func<TopicResponse, TopicResponse>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicResponse CreateTopicResponse(TopicResponse field);

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersResponse WithTopicsCollection(IEnumerable<CreateTopicResponse> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicResponse(Version)))
				.ToArray();
			return this;
		}

		public class TopicResponse : ISerialize
		{
			internal TopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicResponse(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<PartitionResponse> _partitionsCollection = Array.Empty<PartitionResponse>();
			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResponse> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicResponse WithPartitionsCollection(params Func<PartitionResponse, PartitionResponse>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResponse(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResponse CreatePartitionResponse(PartitionResponse field);

			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicResponse WithPartitionsCollection(IEnumerable<CreatePartitionResponse> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResponse(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResponse : ISerialize
			{
				internal PartitionResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					_activeProducersCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResponse(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ActiveProducersCollection = await Array<ProducerState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ProducerState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResponse is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _activeProducersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The partition error message, which may be null if no additional details are available</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The partition error message, which may be null if no additional details are available</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResponse WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Array<ProducerState> _activeProducersCollection = Array.Empty<ProducerState>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<ProducerState> ActiveProducersCollection 
				{
					get => _activeProducersCollection;
					private set 
					{
						_activeProducersCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithActiveProducersCollection(params Func<ProducerState, ProducerState>[] createFields)
				{
					ActiveProducersCollection = createFields
						.Select(createField => createField(new ProducerState(Version)))
						.ToArray();
					return this;
				}

				public delegate ProducerState CreateProducerState(ProducerState field);

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithActiveProducersCollection(IEnumerable<CreateProducerState> createFields)
				{
					ActiveProducersCollection = createFields
						.Select(createField => createField(new ProducerState(Version)))
						.ToArray();
					return this;
				}

				public class ProducerState : ISerialize
				{
					internal ProducerState(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_producerId.GetSize(IsFlexibleVersion) +
						_producerEpoch.GetSize(IsFlexibleVersion) +
						_lastSequence.GetSize(IsFlexibleVersion) +
						_lastTimestamp.GetSize(IsFlexibleVersion) +
						_coordinatorEpoch.GetSize(IsFlexibleVersion) +
						_currentTxnStartOffset.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<ProducerState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new ProducerState(version);
						instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.ProducerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastSequence = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.CoordinatorEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.CurrentTxnStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for ProducerState is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastSequence.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _coordinatorEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _currentTxnStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _producerId = Int64.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 ProducerId 
					{
						get => _producerId;
						private set 
						{
							_producerId = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public ProducerState WithProducerId(Int64 producerId)
					{
						ProducerId = producerId;
						return this;
					}

					private Int32 _producerEpoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 ProducerEpoch 
					{
						get => _producerEpoch;
						private set 
						{
							_producerEpoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public ProducerState WithProducerEpoch(Int32 producerEpoch)
					{
						ProducerEpoch = producerEpoch;
						return this;
					}

					private Int32 _lastSequence = new Int32(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LastSequence 
					{
						get => _lastSequence;
						private set 
						{
							_lastSequence = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public ProducerState WithLastSequence(Int32 lastSequence)
					{
						LastSequence = lastSequence;
						return this;
					}

					private Int64 _lastTimestamp = new Int64(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 LastTimestamp 
					{
						get => _lastTimestamp;
						private set 
						{
							_lastTimestamp = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public ProducerState WithLastTimestamp(Int64 lastTimestamp)
					{
						LastTimestamp = lastTimestamp;
						return this;
					}

					private Int32 _coordinatorEpoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 CoordinatorEpoch 
					{
						get => _coordinatorEpoch;
						private set 
						{
							_coordinatorEpoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public ProducerState WithCoordinatorEpoch(Int32 coordinatorEpoch)
					{
						CoordinatorEpoch = coordinatorEpoch;
						return this;
					}

					private Int64 _currentTxnStartOffset = new Int64(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 CurrentTxnStartOffset 
					{
						get => _currentTxnStartOffset;
						private set 
						{
							_currentTxnStartOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public ProducerState WithCurrentTxnStartOffset(Int64 currentTxnStartOffset)
					{
						CurrentTxnStartOffset = currentTxnStartOffset;
						return this;
					}
				}
			}
		}
	}

	public class DescribeQuorumRequest : Message, IRespond<DescribeQuorumResponse>
	{
		public DescribeQuorumRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeQuorumRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(55);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeQuorumRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeQuorumRequest(version);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeQuorumRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumRequest WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}
			}
		}

		public DescribeQuorumResponse Respond()
			=> new DescribeQuorumResponse(Version);
	}

	public class DescribeQuorumResponse : Message
	{
		public DescribeQuorumResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeQuorumResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(55);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			(Version >= 2 ? 
				_errorMessage.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(Version >= 2 ? 
				_nodesCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeQuorumResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeQuorumResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.NodesCollection = await Map<Int32, Node>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Node.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.NodeId, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeQuorumResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _nodesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				if (Version >= 2 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 2+");

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public DescribeQuorumResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumResponse WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(Version >= 2 ? 
						_errorMessage.GetSize(IsFlexibleVersion):
						0) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					_highWatermark.GetSize(IsFlexibleVersion) +
					_currentVotersCollection.GetSize(IsFlexibleVersion) +
					_observersCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 2) 
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.HighWatermark = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CurrentVotersCollection = await Array<ReplicaState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReplicaState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.ObserversCollection = await Array<ReplicaState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReplicaState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 2)
						await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _highWatermark.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _currentVotersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _observersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = NullableString.Default;
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						if (Version >= 2 == false &&
							value == null) 
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 2+");

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public PartitionData WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int64 _highWatermark = Int64.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 HighWatermark 
				{
					get => _highWatermark;
					private set 
					{
						_highWatermark = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithHighWatermark(Int64 highWatermark)
				{
					HighWatermark = highWatermark;
					return this;
				}

				private Array<ReplicaState> _currentVotersCollection = Array.Empty<ReplicaState>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<ReplicaState> CurrentVotersCollection 
				{
					get => _currentVotersCollection;
					private set 
					{
						_currentVotersCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCurrentVotersCollection(Array<ReplicaState> currentVotersCollection)
				{
					CurrentVotersCollection = currentVotersCollection;
					return this;
				}

				private Array<ReplicaState> _observersCollection = Array.Empty<ReplicaState>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<ReplicaState> ObserversCollection 
				{
					get => _observersCollection;
					private set 
					{
						_observersCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithObserversCollection(Array<ReplicaState> observersCollection)
				{
					ObserversCollection = observersCollection;
					return this;
				}
			}
		}

		private Map<Int32, Node> _nodesCollection = Map<Int32, Node>.Default;
		/// <summary>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Map<Int32, Node> NodesCollection 
		{
			get => _nodesCollection;
			private set 
			{
				if (Version >= 2 == false)
					throw new UnsupportedVersionException($"NodesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

				_nodesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 2+</para>
		/// </summary>
		public DescribeQuorumResponse WithNodesCollection(params Func<Node, Node>[] createFields)
		{
			NodesCollection = createFields
				.Select(createField => createField(new Node(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public delegate Node CreateNode(Node field);

		/// <summary>
		/// <para>Versions: 2+</para>
		/// </summary>
		public DescribeQuorumResponse WithNodesCollection(IEnumerable<CreateNode> createFields)
		{
			NodesCollection = createFields
				.Select(createField => createField(new Node(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public class Node : ISerialize
		{
			internal Node(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 2 ? 
					_nodeId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 2 ? 
					_listenersCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Node> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Node(version);
				if (instance.Version >= 2) 
					instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 2) 
					instance.ListenersCollection = await Map<String, Listener>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Listener.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Node is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 2)
					await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _listenersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The ID of the associated node</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					if (Version >= 2 == false)
						throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the associated node</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Node WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private Map<String, Listener> _listenersCollection = Map<String, Listener>.Default;
			/// <summary>
			/// <para>The listeners of this controller</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Map<String, Listener> ListenersCollection 
			{
				get => _listenersCollection;
				private set 
				{
					if (Version >= 2 == false)
						throw new UnsupportedVersionException($"ListenersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

					_listenersCollection = value;
				}
			}

			/// <summary>
			/// <para>The listeners of this controller</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Node WithListenersCollection(params Func<Listener, Listener>[] createFields)
			{
				ListenersCollection = createFields
					.Select(createField => createField(new Listener(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public delegate Listener CreateListener(Listener field);

			/// <summary>
			/// <para>The listeners of this controller</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Node WithListenersCollection(IEnumerable<CreateListener> createFields)
			{
				ListenersCollection = createFields
					.Select(createField => createField(new Listener(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public class Listener : ISerialize
			{
				internal Listener(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 2 ? 
						_name.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 2 ? 
						_host.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 2 ? 
						_port.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<Listener> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new Listener(version);
					if (instance.Version >= 2) 
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 2) 
						instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 2) 
						instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for Listener is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 2)
						await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 2)
						await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 2)
						await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The name of the endpoint</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						if (Version >= 2 == false)
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

						_name = value;
					}
				}

				/// <summary>
				/// <para>The name of the endpoint</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public Listener WithName(String name)
				{
					Name = name;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The hostname</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					private set 
					{
						if (Version >= 2 == false)
							throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

						_host = value;
					}
				}

				/// <summary>
				/// <para>The hostname</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public Listener WithHost(String host)
				{
					Host = host;
					return this;
				}

				private UInt16 _port = UInt16.Default;
				/// <summary>
				/// <para>The port</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public UInt16 Port 
				{
					get => _port;
					private set 
					{
						if (Version >= 2 == false)
							throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

						_port = value;
					}
				}

				/// <summary>
				/// <para>The port</para>
				/// <para>Versions: 2+</para>
				/// </summary>
				public Listener WithPort(UInt16 port)
				{
					Port = port;
					return this;
				}
			}
		}

		public class ReplicaState : ISerialize
		{
			internal ReplicaState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_replicaId.GetSize(IsFlexibleVersion) +
				(Version >= 2 ? 
					_replicaDirectoryId.GetSize(IsFlexibleVersion):
					0) +
				_logEndOffset.GetSize(IsFlexibleVersion) +
				(Version >= 1 ? 
					_lastFetchTimestamp.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 ? 
					_lastCaughtUpTimestamp.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReplicaState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReplicaState(version);
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 2) 
					instance.ReplicaDirectoryId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.LogEndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.LastFetchTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.LastCaughtUpTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReplicaState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _replicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _replicaDirectoryId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _logEndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _lastFetchTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _lastCaughtUpTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _replicaId = Int32.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ReplicaId 
			{
				get => _replicaId;
				private set 
				{
					_replicaId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaState WithReplicaId(Int32 replicaId)
			{
				ReplicaId = replicaId;
				return this;
			}

			private Uuid _replicaDirectoryId = Uuid.Default;
			/// <summary>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Uuid ReplicaDirectoryId 
			{
				get => _replicaDirectoryId;
				private set 
				{
					if (Version >= 2 == false)
						throw new UnsupportedVersionException($"ReplicaDirectoryId does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

					_replicaDirectoryId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 2+</para>
			/// </summary>
			public ReplicaState WithReplicaDirectoryId(Uuid replicaDirectoryId)
			{
				ReplicaDirectoryId = replicaDirectoryId;
				return this;
			}

			private Int64 _logEndOffset = Int64.Default;
			/// <summary>
			/// <para>The last known log end offset of the follower or -1 if it is unknown</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 LogEndOffset 
			{
				get => _logEndOffset;
				private set 
				{
					_logEndOffset = value;
				}
			}

			/// <summary>
			/// <para>The last known log end offset of the follower or -1 if it is unknown</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaState WithLogEndOffset(Int64 logEndOffset)
			{
				LogEndOffset = logEndOffset;
				return this;
			}

			private Int64 _lastFetchTimestamp = new Int64(-1);
			/// <summary>
			/// <para>The last known leader wall clock time time when a follower fetched from the leader. This is reported as -1 both for the current leader or if it is unknown for a voter</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int64 LastFetchTimestamp 
			{
				get => _lastFetchTimestamp;
				private set 
				{
					_lastFetchTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The last known leader wall clock time time when a follower fetched from the leader. This is reported as -1 both for the current leader or if it is unknown for a voter</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public ReplicaState WithLastFetchTimestamp(Int64 lastFetchTimestamp)
			{
				LastFetchTimestamp = lastFetchTimestamp;
				return this;
			}

			private Int64 _lastCaughtUpTimestamp = new Int64(-1);
			/// <summary>
			/// <para>The leader wall clock append time of the offset for which the follower made the most recent fetch request. This is reported as the current time for the leader and -1 if unknown for a voter</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int64 LastCaughtUpTimestamp 
			{
				get => _lastCaughtUpTimestamp;
				private set 
				{
					_lastCaughtUpTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The leader wall clock append time of the offset for which the follower made the most recent fetch request. This is reported as the current time for the leader and -1 if unknown for a voter</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public ReplicaState WithLastCaughtUpTimestamp(Int64 lastCaughtUpTimestamp)
			{
				LastCaughtUpTimestamp = lastCaughtUpTimestamp;
				return this;
			}
		}
	}

	public class DescribeTopicPartitionsRequest : Message, IRespond<DescribeTopicPartitionsResponse>
	{
		public DescribeTopicPartitionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeTopicPartitionsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(75);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_responsePartitionLimit.GetSize(IsFlexibleVersion) +
			_cursor.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeTopicPartitionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeTopicPartitionsRequest(version);
			instance.TopicsCollection = await Array<TopicRequest>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicRequest.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.ResponsePartitionLimit = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Cursor_ = await Nullable<Cursor>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Cursor.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTopicPartitionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsePartitionLimit.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _cursor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<TopicRequest> _topicsCollection = Array.Empty<TopicRequest>();
		/// <summary>
		/// <para>The topics to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicRequest> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTopicPartitionsRequest WithTopicsCollection(params Func<TopicRequest, TopicRequest>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicRequest(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicRequest CreateTopicRequest(TopicRequest field);

		/// <summary>
		/// <para>The topics to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTopicPartitionsRequest WithTopicsCollection(IEnumerable<CreateTopicRequest> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicRequest(Version)))
				.ToArray();
			return this;
		}

		public class TopicRequest : ISerialize
		{
			internal TopicRequest(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicRequest(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicRequest is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicRequest WithName(String name)
			{
				Name = name;
				return this;
			}
		}

		private Int32 _responsePartitionLimit = new Int32(2000);
		/// <summary>
		/// <para>The maximum number of partitions included in the response.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 2000</para>
		/// </summary>
		public Int32 ResponsePartitionLimit 
		{
			get => _responsePartitionLimit;
			private set 
			{
				_responsePartitionLimit = value;
			}
		}

		/// <summary>
		/// <para>The maximum number of partitions included in the response.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 2000</para>
		/// </summary>
		public DescribeTopicPartitionsRequest WithResponsePartitionLimit(Int32 responsePartitionLimit)
		{
			ResponsePartitionLimit = responsePartitionLimit;
			return this;
		}

		private Nullable<Cursor> _cursor = new Nullable<Cursor>(null);
		/// <summary>
		/// <para>The first topic and partition index to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Cursor? Cursor_ 
		{
			get => _cursor;
			private set 
			{
				_cursor = value;
			}
		}

		/// <summary>
		/// <para>The first topic and partition index to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public DescribeTopicPartitionsRequest WithCursor_(Func<Cursor?, Cursor?> createField)
		{
			Cursor_ = createField(new Cursor(Version));
			return this;
		}

		public class Cursor : ISerialize
		{
			internal Cursor(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Cursor> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Cursor(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Cursor is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name for the first topic to process</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name for the first topic to process</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Cursor WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index to start with</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index to start with</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Cursor WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}
		}

		public DescribeTopicPartitionsResponse Respond()
			=> new DescribeTopicPartitionsResponse(Version);
	}

	public class DescribeTopicPartitionsResponse : Message
	{
		public DescribeTopicPartitionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeTopicPartitionsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(75);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_nextCursor.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeTopicPartitionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeTopicPartitionsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<NullableString, DescribeTopicPartitionsResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeTopicPartitionsResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.NextCursor = await Nullable<Cursor>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Cursor.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTopicPartitionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _nextCursor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTopicPartitionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<NullableString, DescribeTopicPartitionsResponseTopic> _topicsCollection = Map<NullableString, DescribeTopicPartitionsResponseTopic>.Default;
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<NullableString, DescribeTopicPartitionsResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTopicPartitionsResponse WithTopicsCollection(params Func<DescribeTopicPartitionsResponseTopic, DescribeTopicPartitionsResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DescribeTopicPartitionsResponseTopic(Version)))
				.ToDictionary(field => (NullableString)field.Name);
			return this;
		}

		public delegate DescribeTopicPartitionsResponseTopic CreateDescribeTopicPartitionsResponseTopic(DescribeTopicPartitionsResponseTopic field);

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTopicPartitionsResponse WithTopicsCollection(IEnumerable<CreateDescribeTopicPartitionsResponseTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new DescribeTopicPartitionsResponseTopic(Version)))
				.ToDictionary(field => (NullableString)field.Name);
			return this;
		}

		public class DescribeTopicPartitionsResponseTopic : ISerialize
		{
			internal DescribeTopicPartitionsResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_name.GetSize(IsFlexibleVersion) +
				_topicId.GetSize(IsFlexibleVersion) +
				_isInternal.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				_topicAuthorizedOperations.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeTopicPartitionsResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeTopicPartitionsResponseTopic(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.IsInternal = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<DescribeTopicPartitionsResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeTopicPartitionsResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.TopicAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTopicPartitionsResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _isInternal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The topic error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The topic error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _name = NullableString.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Boolean _isInternal = new Boolean(false);
			/// <summary>
			/// <para>True if the topic is internal.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: false</para>
			/// </summary>
			public Boolean IsInternal 
			{
				get => _isInternal;
				private set 
				{
					_isInternal = value;
				}
			}

			/// <summary>
			/// <para>True if the topic is internal.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: false</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithIsInternal(Boolean isInternal)
			{
				IsInternal = isInternal;
				return this;
			}

			private Array<DescribeTopicPartitionsResponsePartition> _partitionsCollection = Array.Empty<DescribeTopicPartitionsResponsePartition>();
			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<DescribeTopicPartitionsResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithPartitionsCollection(params Func<DescribeTopicPartitionsResponsePartition, DescribeTopicPartitionsResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new DescribeTopicPartitionsResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate DescribeTopicPartitionsResponsePartition CreateDescribeTopicPartitionsResponsePartition(DescribeTopicPartitionsResponsePartition field);

			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithPartitionsCollection(IEnumerable<CreateDescribeTopicPartitionsResponsePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new DescribeTopicPartitionsResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public class DescribeTopicPartitionsResponsePartition : ISerialize
			{
				internal DescribeTopicPartitionsResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_errorCode.GetSize(IsFlexibleVersion) +
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					_replicaNodesCollection.GetSize(IsFlexibleVersion) +
					_isrNodesCollection.GetSize(IsFlexibleVersion) +
					_eligibleLeaderReplicasCollection.GetSize(IsFlexibleVersion) +
					_lastKnownElrCollection.GetSize(IsFlexibleVersion) +
					_offlineReplicasCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<DescribeTopicPartitionsResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribeTopicPartitionsResponsePartition(version);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ReplicaNodesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.IsrNodesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.EligibleLeaderReplicasCollection = await NullableArray<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.LastKnownElrCollection = await NullableArray<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.OfflineReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTopicPartitionsResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _replicaNodesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _isrNodesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _eligibleLeaderReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _lastKnownElrCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _offlineReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the leader broker.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the leader broker.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Array<Int32> _replicaNodesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of all nodes that host this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> ReplicaNodesCollection 
				{
					get => _replicaNodesCollection;
					private set 
					{
						_replicaNodesCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of all nodes that host this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithReplicaNodesCollection(Array<Int32> replicaNodesCollection)
				{
					ReplicaNodesCollection = replicaNodesCollection;
					return this;
				}

				private Array<Int32> _isrNodesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of nodes that are in sync with the leader for this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> IsrNodesCollection 
				{
					get => _isrNodesCollection;
					private set 
					{
						_isrNodesCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of nodes that are in sync with the leader for this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithIsrNodesCollection(Array<Int32> isrNodesCollection)
				{
					IsrNodesCollection = isrNodesCollection;
					return this;
				}

				private NullableArray<Int32> _eligibleLeaderReplicasCollection = new NullableArray<Int32>(null);
				/// <summary>
				/// <para>The new eligible leader replicas otherwise.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Array<Int32>? EligibleLeaderReplicasCollection 
				{
					get => _eligibleLeaderReplicasCollection;
					private set 
					{
						_eligibleLeaderReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The new eligible leader replicas otherwise.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithEligibleLeaderReplicasCollection(Array<Int32>? eligibleLeaderReplicasCollection)
				{
					EligibleLeaderReplicasCollection = eligibleLeaderReplicasCollection;
					return this;
				}

				private NullableArray<Int32> _lastKnownElrCollection = new NullableArray<Int32>(null);
				/// <summary>
				/// <para>The last known ELR.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Array<Int32>? LastKnownElrCollection 
				{
					get => _lastKnownElrCollection;
					private set 
					{
						_lastKnownElrCollection = value;
					}
				}

				/// <summary>
				/// <para>The last known ELR.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithLastKnownElrCollection(Array<Int32>? lastKnownElrCollection)
				{
					LastKnownElrCollection = lastKnownElrCollection;
					return this;
				}

				private Array<Int32> _offlineReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of offline replicas of this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> OfflineReplicasCollection 
				{
					get => _offlineReplicasCollection;
					private set 
					{
						_offlineReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of offline replicas of this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeTopicPartitionsResponsePartition WithOfflineReplicasCollection(Array<Int32> offlineReplicasCollection)
				{
					OfflineReplicasCollection = offlineReplicasCollection;
					return this;
				}
			}

			private Int32 _topicAuthorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this topic.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 TopicAuthorizedOperations 
			{
				get => _topicAuthorizedOperations;
				private set 
				{
					_topicAuthorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this topic.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public DescribeTopicPartitionsResponseTopic WithTopicAuthorizedOperations(Int32 topicAuthorizedOperations)
			{
				TopicAuthorizedOperations = topicAuthorizedOperations;
				return this;
			}
		}

		private Nullable<Cursor> _nextCursor = new Nullable<Cursor>(null);
		/// <summary>
		/// <para>The next topic and partition index to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Cursor? NextCursor 
		{
			get => _nextCursor;
			private set 
			{
				_nextCursor = value;
			}
		}

		/// <summary>
		/// <para>The next topic and partition index to fetch details for.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public DescribeTopicPartitionsResponse WithNextCursor(Func<Cursor?, Cursor?> createField)
		{
			NextCursor = createField(new Cursor(Version));
			return this;
		}

		public class Cursor : ISerialize
		{
			internal Cursor(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Cursor> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Cursor(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Cursor is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name for the first topic to process</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name for the first topic to process</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Cursor WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index to start with</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index to start with</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Cursor WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}
		}
	}

	public class DescribeTransactionsRequest : Message, IRespond<DescribeTransactionsResponse>
	{
		public DescribeTransactionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeTransactionsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(65);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_transactionalIdsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeTransactionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeTransactionsRequest(version);
			instance.TransactionalIdsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTransactionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _transactionalIdsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _transactionalIdsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Array of transactionalIds to include in describe results. If empty, then no results will be returned.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> TransactionalIdsCollection 
		{
			get => _transactionalIdsCollection;
			private set 
			{
				_transactionalIdsCollection = value;
			}
		}

		/// <summary>
		/// <para>Array of transactionalIds to include in describe results. If empty, then no results will be returned.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsRequest WithTransactionalIdsCollection(Array<String> transactionalIdsCollection)
		{
			TransactionalIdsCollection = transactionalIdsCollection;
			return this;
		}

		public DescribeTransactionsResponse Respond()
			=> new DescribeTransactionsResponse(Version);
	}

	public class DescribeTransactionsResponse : Message
	{
		public DescribeTransactionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeTransactionsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(65);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_transactionStatesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeTransactionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeTransactionsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TransactionStatesCollection = await Array<TransactionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TransactionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTransactionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _transactionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<TransactionState> _transactionStatesCollection = Array.Empty<TransactionState>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TransactionState> TransactionStatesCollection 
		{
			get => _transactionStatesCollection;
			private set 
			{
				_transactionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsResponse WithTransactionStatesCollection(params Func<TransactionState, TransactionState>[] createFields)
		{
			TransactionStatesCollection = createFields
				.Select(createField => createField(new TransactionState(Version)))
				.ToArray();
			return this;
		}

		public delegate TransactionState CreateTransactionState(TransactionState field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsResponse WithTransactionStatesCollection(IEnumerable<CreateTransactionState> createFields)
		{
			TransactionStatesCollection = createFields
				.Select(createField => createField(new TransactionState(Version)))
				.ToArray();
			return this;
		}

		public class TransactionState : ISerialize
		{
			internal TransactionState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_transactionalId.GetSize(IsFlexibleVersion) +
				_transactionState.GetSize(IsFlexibleVersion) +
				_transactionTimeoutMs.GetSize(IsFlexibleVersion) +
				_transactionStartTimeMs.GetSize(IsFlexibleVersion) +
				_producerId.GetSize(IsFlexibleVersion) +
				_producerEpoch.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TransactionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TransactionState(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TransactionState_ = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TransactionTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TransactionStartTimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Map<String, TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TransactionState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _transactionState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _transactionTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _transactionStartTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String _transactionalId = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionalId 
			{
				get => _transactionalId;
				private set 
				{
					_transactionalId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionalId(String transactionalId)
			{
				TransactionalId = transactionalId;
				return this;
			}

			private String _transactionState = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionState_ 
			{
				get => _transactionState;
				private set 
				{
					_transactionState = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionState_(String transactionState)
			{
				TransactionState_ = transactionState;
				return this;
			}

			private Int32 _transactionTimeoutMs = Int32.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 TransactionTimeoutMs 
			{
				get => _transactionTimeoutMs;
				private set 
				{
					_transactionTimeoutMs = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionTimeoutMs(Int32 transactionTimeoutMs)
			{
				TransactionTimeoutMs = transactionTimeoutMs;
				return this;
			}

			private Int64 _transactionStartTimeMs = Int64.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 TransactionStartTimeMs 
			{
				get => _transactionStartTimeMs;
				private set 
				{
					_transactionStartTimeMs = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionStartTimeMs(Int64 transactionStartTimeMs)
			{
				TransactionStartTimeMs = transactionStartTimeMs;
				return this;
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				private set 
				{
					_producerId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private Int16 _producerEpoch = Int16.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ProducerEpoch 
			{
				get => _producerEpoch;
				private set 
				{
					_producerEpoch = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithProducerEpoch(Int16 producerEpoch)
			{
				ProducerEpoch = producerEpoch;
				return this;
			}

			private Map<String, TopicData> _topicsCollection = Map<String, TopicData>.Default;
			/// <summary>
			/// <para>The set of partitions included in the current transaction (if active). When a transaction is preparing to commit or abort, this will include only partitions which do not have markers.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<String, TopicData> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The set of partitions included in the current transaction (if active). When a transaction is preparing to commit or abort, this will include only partitions which do not have markers.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new TopicData(Version)))
					.ToDictionary(field => field.Topic);
				return this;
			}

			public delegate TopicData CreateTopicData(TopicData field);

			/// <summary>
			/// <para>The set of partitions included in the current transaction (if active). When a transaction is preparing to commit or abort, this will include only partitions which do not have markers.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new TopicData(Version)))
					.ToDictionary(field => field.Topic);
				return this;
			}

			public class TopicData : ISerialize
			{
				internal TopicData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_topic.GetSize(IsFlexibleVersion) +
					_partitionsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TopicData(version);
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _topic = String.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Topic 
				{
					get => _topic;
					private set 
					{
						_topic = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithTopic(String topic)
				{
					Topic = topic;
					return this;
				}

				private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithPartitionsCollection(Array<Int32> partitionsCollection)
				{
					PartitionsCollection = partitionsCollection;
					return this;
				}
			}
		}
	}

	public class DescribeUserScramCredentialsRequest : Message, IRespond<DescribeUserScramCredentialsResponse>
	{
		public DescribeUserScramCredentialsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeUserScramCredentialsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(50);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_usersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeUserScramCredentialsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeUserScramCredentialsRequest(version);
			instance.UsersCollection = await NullableArray<UserName>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UserName.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeUserScramCredentialsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _usersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableArray<UserName> _usersCollection = Array.Empty<UserName>();
		/// <summary>
		/// <para>The users to describe, or null/empty to describe all users.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<UserName>? UsersCollection 
		{
			get => _usersCollection;
			private set 
			{
				_usersCollection = value;
			}
		}

		/// <summary>
		/// <para>The users to describe, or null/empty to describe all users.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsRequest WithUsersCollection(params Func<UserName, UserName>[] createFields)
		{
			UsersCollection = createFields
				.Select(createField => createField(new UserName(Version)))
				.ToArray();
			return this;
		}

		public delegate UserName CreateUserName(UserName field);

		/// <summary>
		/// <para>The users to describe, or null/empty to describe all users.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsRequest WithUsersCollection(IEnumerable<CreateUserName> createFields)
		{
			UsersCollection = createFields
				.Select(createField => createField(new UserName(Version)))
				.ToArray();
			return this;
		}

		public class UserName : ISerialize
		{
			internal UserName(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<UserName> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UserName(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UserName is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UserName WithName(String name)
			{
				Name = name;
				return this;
			}
		}

		public DescribeUserScramCredentialsResponse Respond()
			=> new DescribeUserScramCredentialsResponse(Version);
	}

	public class DescribeUserScramCredentialsResponse : Message
	{
		public DescribeUserScramCredentialsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DescribeUserScramCredentialsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(50);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<DescribeUserScramCredentialsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeUserScramCredentialsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Array<DescribeUserScramCredentialsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeUserScramCredentialsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeUserScramCredentialsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The message-level error code, 0 except for user authorization or infrastructure issues.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The message-level error code, 0 except for user authorization or infrastructure issues.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The message-level error message, if any.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The message-level error message, if any.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<DescribeUserScramCredentialsResult> _resultsCollection = Array.Empty<DescribeUserScramCredentialsResult>();
		/// <summary>
		/// <para>The results for descriptions, one per user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribeUserScramCredentialsResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for descriptions, one per user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithResultsCollection(params Func<DescribeUserScramCredentialsResult, DescribeUserScramCredentialsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DescribeUserScramCredentialsResult(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribeUserScramCredentialsResult CreateDescribeUserScramCredentialsResult(DescribeUserScramCredentialsResult field);

		/// <summary>
		/// <para>The results for descriptions, one per user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithResultsCollection(IEnumerable<CreateDescribeUserScramCredentialsResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new DescribeUserScramCredentialsResult(Version)))
				.ToArray();
			return this;
		}

		public class DescribeUserScramCredentialsResult : ISerialize
		{
			internal DescribeUserScramCredentialsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_user.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_credentialInfosCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribeUserScramCredentialsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeUserScramCredentialsResult(version);
				instance.User = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.CredentialInfosCollection = await Array<CredentialInfo>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CredentialInfo.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeUserScramCredentialsResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _user.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _credentialInfosCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _user = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String User 
			{
				get => _user;
				private set 
				{
					_user = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithUser(String user)
			{
				User = user;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The user-level error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The user-level error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The user-level error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The user-level error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Array<CredentialInfo> _credentialInfosCollection = Array.Empty<CredentialInfo>();
			/// <summary>
			/// <para>The mechanism and related information associated with the user's SCRAM credentials.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<CredentialInfo> CredentialInfosCollection 
			{
				get => _credentialInfosCollection;
				private set 
				{
					_credentialInfosCollection = value;
				}
			}

			/// <summary>
			/// <para>The mechanism and related information associated with the user's SCRAM credentials.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithCredentialInfosCollection(params Func<CredentialInfo, CredentialInfo>[] createFields)
			{
				CredentialInfosCollection = createFields
					.Select(createField => createField(new CredentialInfo(Version)))
					.ToArray();
				return this;
			}

			public delegate CredentialInfo CreateCredentialInfo(CredentialInfo field);

			/// <summary>
			/// <para>The mechanism and related information associated with the user's SCRAM credentials.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithCredentialInfosCollection(IEnumerable<CreateCredentialInfo> createFields)
			{
				CredentialInfosCollection = createFields
					.Select(createField => createField(new CredentialInfo(Version)))
					.ToArray();
				return this;
			}

			public class CredentialInfo : ISerialize
			{
				internal CredentialInfo(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_mechanism.GetSize(IsFlexibleVersion) +
					_iterations.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<CredentialInfo> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CredentialInfo(version);
					instance.Mechanism = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Iterations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CredentialInfo is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _iterations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int8 _mechanism = Int8.Default;
				/// <summary>
				/// <para>The SCRAM mechanism.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 Mechanism 
				{
					get => _mechanism;
					private set 
					{
						_mechanism = value;
					}
				}

				/// <summary>
				/// <para>The SCRAM mechanism.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CredentialInfo WithMechanism(Int8 mechanism)
				{
					Mechanism = mechanism;
					return this;
				}

				private Int32 _iterations = Int32.Default;
				/// <summary>
				/// <para>The number of iterations used in the SCRAM credential.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Iterations 
				{
					get => _iterations;
					private set 
					{
						_iterations = value;
					}
				}

				/// <summary>
				/// <para>The number of iterations used in the SCRAM credential.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CredentialInfo WithIterations(Int32 iterations)
				{
					Iterations = iterations;
					return this;
				}
			}
		}
	}

	public class ElectLeadersRequest : Message, IRespond<ElectLeadersResponse>
	{
		public ElectLeadersRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ElectLeadersRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(43);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_electionType.GetSize(IsFlexibleVersion):
				0) +
			_topicPartitionsCollection.GetSize(IsFlexibleVersion) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ElectLeadersRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ElectLeadersRequest(version);
			if (instance.Version >= 1) 
				instance.ElectionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicPartitionsCollection = await NullableMap<String, TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ElectLeadersRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _electionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int8 _electionType = Int8.Default;
		/// <summary>
		/// <para>Type of elections to conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int8 ElectionType 
		{
			get => _electionType;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"ElectionType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_electionType = value;
			}
		}

		/// <summary>
		/// <para>Type of elections to conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ElectLeadersRequest WithElectionType(Int8 electionType)
		{
			ElectionType = electionType;
			return this;
		}

		private NullableMap<String, TopicPartitions> _topicPartitionsCollection = NullableMap<String, TopicPartitions>.Default;
		/// <summary>
		/// <para>The topic partitions to elect leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, TopicPartitions>? TopicPartitionsCollection 
		{
			get => _topicPartitionsCollection;
			private set 
			{
				_topicPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topic partitions to elect leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersRequest WithTopicPartitionsCollection(params Func<TopicPartitions, TopicPartitions>[] createFields)
		{
			TopicPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartitions(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public delegate TopicPartitions CreateTopicPartitions(TopicPartitions field);

		/// <summary>
		/// <para>The topic partitions to elect leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersRequest WithTopicPartitionsCollection(IEnumerable<CreateTopicPartitions> createFields)
		{
			TopicPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartitions(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topic.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The name of a topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The name of a topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions of this topic whose leader should be elected.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions of this topic whose leader should be elected.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>The time in ms to wait for the election to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the election to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public ElectLeadersRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		public ElectLeadersResponse Respond()
			=> new ElectLeadersResponse(Version);
	}

	public class ElectLeadersResponse : Message
	{
		public ElectLeadersResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ElectLeadersResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(43);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_errorCode.GetSize(IsFlexibleVersion):
				0) +
			_replicaElectionResultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ElectLeadersResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ElectLeadersResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ReplicaElectionResultsCollection = await Array<ReplicaElectionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReplicaElectionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ElectLeadersResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _replicaElectionResultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ElectLeadersResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<ReplicaElectionResult> _replicaElectionResultsCollection = Array.Empty<ReplicaElectionResult>();
		/// <summary>
		/// <para>The election results, or an empty array if the requester did not have permission and the request asks for all partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReplicaElectionResult> ReplicaElectionResultsCollection 
		{
			get => _replicaElectionResultsCollection;
			private set 
			{
				_replicaElectionResultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The election results, or an empty array if the requester did not have permission and the request asks for all partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersResponse WithReplicaElectionResultsCollection(params Func<ReplicaElectionResult, ReplicaElectionResult>[] createFields)
		{
			ReplicaElectionResultsCollection = createFields
				.Select(createField => createField(new ReplicaElectionResult(Version)))
				.ToArray();
			return this;
		}

		public delegate ReplicaElectionResult CreateReplicaElectionResult(ReplicaElectionResult field);

		/// <summary>
		/// <para>The election results, or an empty array if the requester did not have permission and the request asks for all partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersResponse WithReplicaElectionResultsCollection(IEnumerable<CreateReplicaElectionResult> createFields)
		{
			ReplicaElectionResultsCollection = createFields
				.Select(createField => createField(new ReplicaElectionResult(Version)))
				.ToArray();
			return this;
		}

		public class ReplicaElectionResult : ISerialize
		{
			internal ReplicaElectionResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topic.GetSize(IsFlexibleVersion) +
				_partitionResultCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReplicaElectionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReplicaElectionResult(version);
				instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionResultCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReplicaElectionResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionResultCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaElectionResult WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<PartitionResult> _partitionResultCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResult> PartitionResultCollection 
			{
				get => _partitionResultCollection;
				private set 
				{
					_partitionResultCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaElectionResult WithPartitionResultCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionResultCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResult CreatePartitionResult(PartitionResult field);

			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaElectionResult WithPartitionResultCollection(IEnumerable<CreatePartitionResult> createFields)
			{
				PartitionResultCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionId.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					instance.PartitionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionId = Int32.Default;
				/// <summary>
				/// <para>The partition id</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionId 
				{
					get => _partitionId;
					private set 
					{
						_partitionId = value;
					}
				}

				/// <summary>
				/// <para>The partition id</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartitionId(Int32 partitionId)
				{
					PartitionId = partitionId;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The result error, or zero if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The result error, or zero if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = NullableString.Default;
				/// <summary>
				/// <para>The result message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The result message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class EndQuorumEpochRequest : Message, IRespond<EndQuorumEpochResponse>
	{
		public EndQuorumEpochRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"EndQuorumEpochRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(54);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clusterId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<EndQuorumEpochRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndQuorumEpochRequest(version);
			instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndQuorumEpochRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _clusterId = new NullableString(null);
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public EndQuorumEpochRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochRequest WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = false;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					_preferredSuccessorsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PreferredSuccessorsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _preferredSuccessorsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The current leader ID that is resigning</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The current leader ID that is resigning</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The current epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Array<Int32> _preferredSuccessorsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>A sorted list of preferred successors to start the election</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> PreferredSuccessorsCollection 
				{
					get => _preferredSuccessorsCollection;
					private set 
					{
						_preferredSuccessorsCollection = value;
					}
				}

				/// <summary>
				/// <para>A sorted list of preferred successors to start the election</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPreferredSuccessorsCollection(Array<Int32> preferredSuccessorsCollection)
				{
					PreferredSuccessorsCollection = preferredSuccessorsCollection;
					return this;
				}
			}
		}

		public EndQuorumEpochResponse Respond()
			=> new EndQuorumEpochResponse(Version);
	}

	public class EndQuorumEpochResponse : Message
	{
		public EndQuorumEpochResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"EndQuorumEpochResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(54);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<EndQuorumEpochResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndQuorumEpochResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndQuorumEpochResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochResponse WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = false;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}
	}

	public class EndTxnRequest : Message, IRespond<EndTxnResponse>
	{
		public EndTxnRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"EndTxnRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(26);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_transactionalId.GetSize(IsFlexibleVersion) +
			_producerId.GetSize(IsFlexibleVersion) +
			_producerEpoch.GetSize(IsFlexibleVersion) +
			_committed.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<EndTxnRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndTxnRequest(version);
			instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Committed = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndTxnRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _committed.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The ID of the transaction to end.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			private set 
			{
				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the transaction to end.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>The producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			private set 
			{
				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>The current epoch associated with the producer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			private set 
			{
				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current epoch associated with the producer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private Boolean _committed = Boolean.Default;
		/// <summary>
		/// <para>True if the transaction was committed, false if it was aborted.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean Committed 
		{
			get => _committed;
			private set 
			{
				_committed = value;
			}
		}

		/// <summary>
		/// <para>True if the transaction was committed, false if it was aborted.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithCommitted(Boolean committed)
		{
			Committed = committed;
			return this;
		}

		public EndTxnResponse Respond()
			=> new EndTxnResponse(Version);
	}

	public class EndTxnResponse : Message
	{
		public EndTxnResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"EndTxnResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(26);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<EndTxnResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndTxnResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndTxnResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class EnvelopeRequest : Message, IRespond<EnvelopeResponse>
	{
		public EnvelopeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"EnvelopeRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(58);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_requestData.GetSize(IsFlexibleVersion) +
			_requestPrincipal.GetSize(IsFlexibleVersion) +
			_clientHostAddress.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<EnvelopeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EnvelopeRequest(version);
			instance.RequestData = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RequestPrincipal = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ClientHostAddress = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EnvelopeRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _requestData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _requestPrincipal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _clientHostAddress.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Bytes _requestData = Bytes.Default;
		/// <summary>
		/// <para>The embedded request header and data.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes RequestData 
		{
			get => _requestData;
			private set 
			{
				_requestData = value;
			}
		}

		/// <summary>
		/// <para>The embedded request header and data.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeRequest WithRequestData(Bytes requestData)
		{
			RequestData = requestData;
			return this;
		}

		private NullableBytes _requestPrincipal = NullableBytes.Default;
		/// <summary>
		/// <para>Value of the initial client principal when the request is redirected by a broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes? RequestPrincipal 
		{
			get => _requestPrincipal;
			private set 
			{
				_requestPrincipal = value;
			}
		}

		/// <summary>
		/// <para>Value of the initial client principal when the request is redirected by a broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeRequest WithRequestPrincipal(Bytes? requestPrincipal)
		{
			RequestPrincipal = requestPrincipal;
			return this;
		}

		private Bytes _clientHostAddress = Bytes.Default;
		/// <summary>
		/// <para>The original client's address in bytes.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes ClientHostAddress 
		{
			get => _clientHostAddress;
			private set 
			{
				_clientHostAddress = value;
			}
		}

		/// <summary>
		/// <para>The original client's address in bytes.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeRequest WithClientHostAddress(Bytes clientHostAddress)
		{
			ClientHostAddress = clientHostAddress;
			return this;
		}

		public EnvelopeResponse Respond()
			=> new EnvelopeResponse(Version);
	}

	public class EnvelopeResponse : Message
	{
		public EnvelopeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"EnvelopeResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(58);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_responseData.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<EnvelopeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EnvelopeResponse(version);
			instance.ResponseData = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EnvelopeResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _responseData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableBytes _responseData = new NullableBytes(null);
		/// <summary>
		/// <para>The embedded response header and data.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Bytes? ResponseData 
		{
			get => _responseData;
			private set 
			{
				_responseData = value;
			}
		}

		/// <summary>
		/// <para>The embedded response header and data.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public EnvelopeResponse WithResponseData(Bytes? responseData)
		{
			ResponseData = responseData;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class ExpireDelegationTokenRequest : Message, IRespond<ExpireDelegationTokenResponse>
	{
		public ExpireDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ExpireDelegationTokenRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(40);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_hmac.GetSize(IsFlexibleVersion) +
			_expiryTimePeriodMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ExpireDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ExpireDelegationTokenRequest(version);
			instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ExpiryTimePeriodMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ExpireDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _expiryTimePeriodMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Bytes _hmac = Bytes.Default;
		/// <summary>
		/// <para>The HMAC of the delegation token to be expired.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Hmac 
		{
			get => _hmac;
			private set 
			{
				_hmac = value;
			}
		}

		/// <summary>
		/// <para>The HMAC of the delegation token to be expired.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenRequest WithHmac(Bytes hmac)
		{
			Hmac = hmac;
			return this;
		}

		private Int64 _expiryTimePeriodMs = Int64.Default;
		/// <summary>
		/// <para>The expiry time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimePeriodMs 
		{
			get => _expiryTimePeriodMs;
			private set 
			{
				_expiryTimePeriodMs = value;
			}
		}

		/// <summary>
		/// <para>The expiry time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenRequest WithExpiryTimePeriodMs(Int64 expiryTimePeriodMs)
		{
			ExpiryTimePeriodMs = expiryTimePeriodMs;
			return this;
		}

		public ExpireDelegationTokenResponse Respond()
			=> new ExpireDelegationTokenResponse(Version);
	}

	public class ExpireDelegationTokenResponse : Message
	{
		public ExpireDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ExpireDelegationTokenResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(40);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_expiryTimestampMs.GetSize(IsFlexibleVersion) +
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ExpireDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ExpireDelegationTokenResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ExpiryTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ExpireDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _expiryTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _expiryTimestampMs = Int64.Default;
		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimestampMs 
		{
			get => _expiryTimestampMs;
			private set 
			{
				_expiryTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenResponse WithExpiryTimestampMs(Int64 expiryTimestampMs)
		{
			ExpiryTimestampMs = expiryTimestampMs;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class FetchRequest : Message, IRespond<FetchResponse>
	{
		public FetchRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"FetchRequest does not support version {version}. Valid versions are: 0-16");

			Version = version;
			IsFlexibleVersion = version >= 12;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(1);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(16);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (Version >= 12 && _clusterIdIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _clusterId
				});
			if (Version >= 15 && _replicaStateIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 1,
					Field = _replicaState
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
		 +
			(Version >= 0 && Version <= 14 ? 
				_replicaId.GetSize(IsFlexibleVersion):
				0) +
			_maxWaitMs.GetSize(IsFlexibleVersion) +
			_minBytes.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_maxBytes.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 4 ? 
				_isolationLevel.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 7 ? 
				_sessionId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 7 ? 
				_sessionEpoch.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(Version >= 7 ? 
				_forgottenTopicsDataCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 11 ? 
				_rackId.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<FetchRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchRequest(version);
			if (instance.Version >= 0 && instance.Version <= 14) 
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MaxWaitMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MinBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.MaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.IsolationLevel = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.SessionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.SessionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<FetchTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.ForgottenTopicsDataCollection = await Array<ForgottenTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ForgottenTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 11) 
				instance.RackId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version >= 12) 
								instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field ClusterId is not supported for version {instance.Version}");
							{
								var size = instance._clusterId.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field ClusterId read length {tag.Length} but had actual length of {size}");
							}
							break;

						case 1:
							if (instance.Version >= 15) 
								instance.ReplicaState_ = await ReplicaState.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field ReplicaState_ is not supported for version {instance.Version}");
							{
								var size = instance._replicaState.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field ReplicaState_ read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 0 && Version <= 14)
				await _replicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _maxWaitMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _minBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _maxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _isolationLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _sessionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _sessionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _forgottenTopicsDataCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 11)
				await _rackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private bool _clusterIdIsSet;
		private NullableString _clusterId = new NullableString(null);
		/// <summary>
		/// <para>The clusterId if known. This is used to validate metadata fetches prior to broker registration.</para>
		/// <para>Versions: 12+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			private set 
			{
				if (Version >= 12 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 12+");

				_clusterId = value;
				_clusterIdIsSet = true;
			}
		}

		/// <summary>
		/// <para>The clusterId if known. This is used to validate metadata fetches prior to broker registration.</para>
		/// <para>Versions: 12+</para>
		/// <para>Default: null</para>
		/// </summary>
		public FetchRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _replicaId = new Int32(-1);
		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 0-14</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			private set 
			{
				if (Version >= 0 && Version <= 14 == false)
					throw new UnsupportedVersionException($"ReplicaId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-14");

				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 0-14</para>
		/// <para>Default: -1</para>
		/// </summary>
		public FetchRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private bool _replicaStateIsSet;
		private ReplicaState _replicaState = default!;
		/// <summary>
		/// <para>Versions: 15+</para>
		/// </summary>
		public ReplicaState ReplicaState_ 
		{
			get => _replicaState;
			private set 
			{
				if (Version >= 15 == false)
					throw new UnsupportedVersionException($"ReplicaState_ does not support version {Version} and has been defined as not ignorable. Supported versions: 15+");

				_replicaState = value;
				_replicaStateIsSet = true;
			}
		}

		/// <summary>
		/// <para>Versions: 15+</para>
		/// </summary>
		public FetchRequest WithReplicaState_(Func<ReplicaState, ReplicaState> createField)
		{
			ReplicaState_ = createField(new ReplicaState(Version));
			return this;
		}

		public class ReplicaState : ISerialize
		{
			internal ReplicaState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 12;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 15 ? 
					_replicaId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 15 ? 
					_replicaEpoch.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReplicaState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReplicaState(version);
				if (instance.Version >= 15) 
					instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 15) 
					instance.ReplicaEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReplicaState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 15)
					await _replicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 15)
					await _replicaEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _replicaId = new Int32(-1);
			/// <summary>
			/// <para>The replica ID of the follower, or -1 if this request is from a consumer.</para>
			/// <para>Versions: 15+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int32 ReplicaId 
			{
				get => _replicaId;
				private set 
				{
					if (Version >= 15 == false)
						throw new UnsupportedVersionException($"ReplicaId does not support version {Version} and has been defined as not ignorable. Supported versions: 15+");

					_replicaId = value;
				}
			}

			/// <summary>
			/// <para>The replica ID of the follower, or -1 if this request is from a consumer.</para>
			/// <para>Versions: 15+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public ReplicaState WithReplicaId(Int32 replicaId)
			{
				ReplicaId = replicaId;
				return this;
			}

			private Int64 _replicaEpoch = new Int64(-1);
			/// <summary>
			/// <para>The epoch of this follower, or -1 if not available.</para>
			/// <para>Versions: 15+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int64 ReplicaEpoch 
			{
				get => _replicaEpoch;
				private set 
				{
					if (Version >= 15 == false)
						throw new UnsupportedVersionException($"ReplicaEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 15+");

					_replicaEpoch = value;
				}
			}

			/// <summary>
			/// <para>The epoch of this follower, or -1 if not available.</para>
			/// <para>Versions: 15+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public ReplicaState WithReplicaEpoch(Int64 replicaEpoch)
			{
				ReplicaEpoch = replicaEpoch;
				return this;
			}
		}

		private Int32 _maxWaitMs = Int32.Default;
		/// <summary>
		/// <para>The maximum time in milliseconds to wait for the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MaxWaitMs 
		{
			get => _maxWaitMs;
			private set 
			{
				_maxWaitMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum time in milliseconds to wait for the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithMaxWaitMs(Int32 maxWaitMs)
		{
			MaxWaitMs = maxWaitMs;
			return this;
		}

		private Int32 _minBytes = Int32.Default;
		/// <summary>
		/// <para>The minimum bytes to accumulate in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MinBytes 
		{
			get => _minBytes;
			private set 
			{
				_minBytes = value;
			}
		}

		/// <summary>
		/// <para>The minimum bytes to accumulate in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithMinBytes(Int32 minBytes)
		{
			MinBytes = minBytes;
			return this;
		}

		private Int32 _maxBytes = new Int32(0x7fffffff);
		/// <summary>
		/// <para>The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public Int32 MaxBytes 
		{
			get => _maxBytes;
			private set 
			{
				_maxBytes = value;
			}
		}

		/// <summary>
		/// <para>The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public FetchRequest WithMaxBytes(Int32 maxBytes)
		{
			MaxBytes = maxBytes;
			return this;
		}

		private Int8 _isolationLevel = new Int8(0);
		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int8 IsolationLevel 
		{
			get => _isolationLevel;
			private set 
			{
				_isolationLevel = value;
			}
		}

		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FetchRequest WithIsolationLevel(Int8 isolationLevel)
		{
			IsolationLevel = isolationLevel;
			return this;
		}

		private Int32 _sessionId = new Int32(0);
		/// <summary>
		/// <para>The fetch session ID.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int32 SessionId 
		{
			get => _sessionId;
			private set 
			{
				_sessionId = value;
			}
		}

		/// <summary>
		/// <para>The fetch session ID.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FetchRequest WithSessionId(Int32 sessionId)
		{
			SessionId = sessionId;
			return this;
		}

		private Int32 _sessionEpoch = new Int32(-1);
		/// <summary>
		/// <para>The fetch session epoch, which is used for ordering requests in a session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 SessionEpoch 
		{
			get => _sessionEpoch;
			private set 
			{
				_sessionEpoch = value;
			}
		}

		/// <summary>
		/// <para>The fetch session epoch, which is used for ordering requests in a session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public FetchRequest WithSessionEpoch(Int32 sessionEpoch)
		{
			SessionEpoch = sessionEpoch;
			return this;
		}

		private Array<FetchTopic> _topicsCollection = Array.Empty<FetchTopic>();
		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<FetchTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithTopicsCollection(params Func<FetchTopic, FetchTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new FetchTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate FetchTopic CreateFetchTopic(FetchTopic field);

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithTopicsCollection(IEnumerable<CreateFetchTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new FetchTopic(Version)))
				.ToArray();
			return this;
		}

		public class FetchTopic : ISerialize
		{
			internal FetchTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 12;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 12 ? 
					_topic.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 13 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<FetchTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FetchTopic(version);
				if (instance.Version >= 0 && instance.Version <= 12) 
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 13) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<FetchPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 12)
					await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 13)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public FetchTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public FetchTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<FetchPartition> _partitionsCollection = Array.Empty<FetchPartition>();
			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<FetchPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchTopic WithPartitionsCollection(params Func<FetchPartition, FetchPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new FetchPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate FetchPartition CreateFetchPartition(FetchPartition field);

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchTopic WithPartitionsCollection(IEnumerable<CreateFetchPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new FetchPartition(Version)))
					.ToArray();
				return this;
			}

			public class FetchPartition : ISerialize
			{
				internal FetchPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 12;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					(Version >= 9 ? 
						_currentLeaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					_fetchOffset.GetSize(IsFlexibleVersion) +
					(Version >= 12 ? 
						_lastFetchedEpoch.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_logStartOffset.GetSize(IsFlexibleVersion):
						0) +
					_partitionMaxBytes.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<FetchPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new FetchPartition(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 9) 
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.FetchOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 12) 
						instance.LastFetchedEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.LogStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionMaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 9)
						await _currentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _fetchOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 12)
						await _lastFetchedEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _logStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionMaxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _currentLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The current leader epoch of the partition.</para>
				/// <para>Versions: 9+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					private set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current leader epoch of the partition.</para>
				/// <para>Versions: 9+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public FetchPartition WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private Int64 _fetchOffset = Int64.Default;
				/// <summary>
				/// <para>The message offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 FetchOffset 
				{
					get => _fetchOffset;
					private set 
					{
						_fetchOffset = value;
					}
				}

				/// <summary>
				/// <para>The message offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithFetchOffset(Int64 fetchOffset)
				{
					FetchOffset = fetchOffset;
					return this;
				}

				private Int32 _lastFetchedEpoch = new Int32(-1);
				/// <summary>
				/// <para>The epoch of the last fetched record or -1 if there is none</para>
				/// <para>Versions: 12+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LastFetchedEpoch 
				{
					get => _lastFetchedEpoch;
					private set 
					{
						if (Version >= 12 == false)
							throw new UnsupportedVersionException($"LastFetchedEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

						_lastFetchedEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch of the last fetched record or -1 if there is none</para>
				/// <para>Versions: 12+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public FetchPartition WithLastFetchedEpoch(Int32 lastFetchedEpoch)
				{
					LastFetchedEpoch = lastFetchedEpoch;
					return this;
				}

				private Int64 _logStartOffset = new Int64(-1);
				/// <summary>
				/// <para>The earliest available offset of the follower replica.  The field is only used when the request is sent by the follower.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogStartOffset 
				{
					get => _logStartOffset;
					private set 
					{
						_logStartOffset = value;
					}
				}

				/// <summary>
				/// <para>The earliest available offset of the follower replica.  The field is only used when the request is sent by the follower.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public FetchPartition WithLogStartOffset(Int64 logStartOffset)
				{
					LogStartOffset = logStartOffset;
					return this;
				}

				private Int32 _partitionMaxBytes = Int32.Default;
				/// <summary>
				/// <para>The maximum bytes to fetch from this partition.  See KIP-74 for cases where this limit may not be honored.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionMaxBytes 
				{
					get => _partitionMaxBytes;
					private set 
					{
						_partitionMaxBytes = value;
					}
				}

				/// <summary>
				/// <para>The maximum bytes to fetch from this partition.  See KIP-74 for cases where this limit may not be honored.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithPartitionMaxBytes(Int32 partitionMaxBytes)
				{
					PartitionMaxBytes = partitionMaxBytes;
					return this;
				}
			}
		}

		private Array<ForgottenTopic> _forgottenTopicsDataCollection = Array.Empty<ForgottenTopic>();
		/// <summary>
		/// <para>In an incremental fetch request, the partitions to remove.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public Array<ForgottenTopic> ForgottenTopicsDataCollection 
		{
			get => _forgottenTopicsDataCollection;
			private set 
			{
				if (Version >= 7 == false)
					throw new UnsupportedVersionException($"ForgottenTopicsDataCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");

				_forgottenTopicsDataCollection = value;
			}
		}

		/// <summary>
		/// <para>In an incremental fetch request, the partitions to remove.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public FetchRequest WithForgottenTopicsDataCollection(params Func<ForgottenTopic, ForgottenTopic>[] createFields)
		{
			ForgottenTopicsDataCollection = createFields
				.Select(createField => createField(new ForgottenTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate ForgottenTopic CreateForgottenTopic(ForgottenTopic field);

		/// <summary>
		/// <para>In an incremental fetch request, the partitions to remove.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public FetchRequest WithForgottenTopicsDataCollection(IEnumerable<CreateForgottenTopic> createFields)
		{
			ForgottenTopicsDataCollection = createFields
				.Select(createField => createField(new ForgottenTopic(Version)))
				.ToArray();
			return this;
		}

		public class ForgottenTopic : ISerialize
		{
			internal ForgottenTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 12;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 7 && Version <= 12 ? 
					_topic.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 13 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 7 ? 
					_partitionsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ForgottenTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ForgottenTopic(version);
				if (instance.Version >= 7 && instance.Version <= 12) 
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 13) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 7) 
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ForgottenTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 7 && Version <= 12)
					await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 13)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 7)
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 7-12</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 7-12</para>
			/// </summary>
			public ForgottenTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public ForgottenTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions indexes to forget.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					if (Version >= 7 == false)
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions indexes to forget.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public ForgottenTopic WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private String _rackId = new String(string.Empty);
		/// <summary>
		/// <para>Rack ID of the consumer making this request</para>
		/// <para>Versions: 11+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public String RackId 
		{
			get => _rackId;
			private set 
			{
				_rackId = value;
			}
		}

		/// <summary>
		/// <para>Rack ID of the consumer making this request</para>
		/// <para>Versions: 11+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public FetchRequest WithRackId(String rackId)
		{
			RackId = rackId;
			return this;
		}

		public FetchResponse Respond()
			=> new FetchResponse(Version);
	}

	public class FetchResponse : Message
	{
		public FetchResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"FetchResponse does not support version {version}. Valid versions are: 0-16");

			Version = version;
			IsFlexibleVersion = version >= 12;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(1);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(16);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (Version >= 16 && _nodeEndpointsCollectionIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _nodeEndpointsCollection
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 7 ? 
				_errorCode.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 7 ? 
				_sessionId.GetSize(IsFlexibleVersion):
				0) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<FetchResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.SessionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Array<FetchableTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchableTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version >= 16) 
								instance.NodeEndpointsCollection = await Map<Int32, NodeEndpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => NodeEndpoint.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.NodeId, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field NodeEndpointsCollection is not supported for version {instance.Version}");
							{
								var size = instance._nodeEndpointsCollection.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field NodeEndpointsCollection read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _sessionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public FetchResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public FetchResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int32 _sessionId = new Int32(0);
		/// <summary>
		/// <para>The fetch session ID, or 0 if this is not part of a fetch session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int32 SessionId 
		{
			get => _sessionId;
			private set 
			{
				if (Version >= 7 == false)
					throw new UnsupportedVersionException($"SessionId does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");

				_sessionId = value;
			}
		}

		/// <summary>
		/// <para>The fetch session ID, or 0 if this is not part of a fetch session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FetchResponse WithSessionId(Int32 sessionId)
		{
			SessionId = sessionId;
			return this;
		}

		private Array<FetchableTopicResponse> _responsesCollection = Array.Empty<FetchableTopicResponse>();
		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<FetchableTopicResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchResponse WithResponsesCollection(params Func<FetchableTopicResponse, FetchableTopicResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new FetchableTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate FetchableTopicResponse CreateFetchableTopicResponse(FetchableTopicResponse field);

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchResponse WithResponsesCollection(IEnumerable<CreateFetchableTopicResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new FetchableTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public class FetchableTopicResponse : ISerialize
		{
			internal FetchableTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 12;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 12 ? 
					_topic.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 13 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<FetchableTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FetchableTopicResponse(version);
				if (instance.Version >= 0 && instance.Version <= 12) 
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 13) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchableTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 12)
					await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 13)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public FetchableTopicResponse WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public FetchableTopicResponse WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchableTopicResponse WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchableTopicResponse WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 12;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					var tags = new List<Tags.TaggedField>();
					if (Version >= 12 && _divergingEpochIsSet) 
						tags.Add(new Tags.TaggedField
						{
							Tag = 0,
							Field = _divergingEpoch
						});
					if (Version >= 12 && _currentLeaderIsSet) 
						tags.Add(new Tags.TaggedField
						{
							Tag = 1,
							Field = _currentLeader
						});
					if (Version >= 12 && _snapshotIdIsSet) 
						tags.Add(new Tags.TaggedField
						{
							Tag = 2,
							Field = _snapshotId
						});
					return new Tags.TagSection(tags.ToArray());
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_highWatermark.GetSize(IsFlexibleVersion) +
					(Version >= 4 ? 
						_lastStableOffset.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_logStartOffset.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 4 ? 
						_abortedTransactionsCollection.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 11 ? 
						_preferredReadReplica.GetSize(IsFlexibleVersion):
						0) +
					_records.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.HighWatermark = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 4) 
						instance.LastStableOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.LogStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 4) 
						instance.AbortedTransactionsCollection = await NullableArray<AbortedTransaction>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AbortedTransaction.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 11) 
						instance.PreferredReadReplica = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Records = await NullableRecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								case 0:
									if (instance.Version >= 12) 
										instance.DivergingEpoch = await EpochEndOffset.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									else
										throw new InvalidOperationException($"Field DivergingEpoch is not supported for version {instance.Version}");
									{
										var size = instance._divergingEpoch.GetSize(true);
										if (size != tag.Length)
											throw new CorruptMessageException($"Tagged field DivergingEpoch read length {tag.Length} but had actual length of {size}");
									}
									break;

								case 1:
									if (instance.Version >= 12) 
										instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									else
										throw new InvalidOperationException($"Field CurrentLeader is not supported for version {instance.Version}");
									{
										var size = instance._currentLeader.GetSize(true);
										if (size != tag.Length)
											throw new CorruptMessageException($"Tagged field CurrentLeader read length {tag.Length} but had actual length of {size}");
									}
									break;

								case 2:
									if (instance.Version >= 12) 
										instance.SnapshotId_ = await SnapshotId.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									else
										throw new InvalidOperationException($"Field SnapshotId_ is not supported for version {instance.Version}");
									{
										var size = instance._snapshotId.GetSize(true);
										if (size != tag.Length)
											throw new CorruptMessageException($"Tagged field SnapshotId_ read length {tag.Length} but had actual length of {size}");
									}
									break;
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _highWatermark.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 4)
						await _lastStableOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _logStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 4)
						await _abortedTransactionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 11)
						await _preferredReadReplica.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _records.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int64 _highWatermark = Int64.Default;
				/// <summary>
				/// <para>The current high water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 HighWatermark 
				{
					get => _highWatermark;
					private set 
					{
						_highWatermark = value;
					}
				}

				/// <summary>
				/// <para>The current high water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithHighWatermark(Int64 highWatermark)
				{
					HighWatermark = highWatermark;
					return this;
				}

				private Int64 _lastStableOffset = new Int64(-1);
				/// <summary>
				/// <para>The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LastStableOffset 
				{
					get => _lastStableOffset;
					private set 
					{
						_lastStableOffset = value;
					}
				}

				/// <summary>
				/// <para>The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionData WithLastStableOffset(Int64 lastStableOffset)
				{
					LastStableOffset = lastStableOffset;
					return this;
				}

				private Int64 _logStartOffset = new Int64(-1);
				/// <summary>
				/// <para>The current log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogStartOffset 
				{
					get => _logStartOffset;
					private set 
					{
						_logStartOffset = value;
					}
				}

				/// <summary>
				/// <para>The current log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionData WithLogStartOffset(Int64 logStartOffset)
				{
					LogStartOffset = logStartOffset;
					return this;
				}

				private bool _divergingEpochIsSet;
				private EpochEndOffset _divergingEpoch = default!;
				/// <summary>
				/// <para>In case divergence is detected based on the `LastFetchedEpoch` and `FetchOffset` in the request, this field indicates the largest epoch and its end offset such that subsequent records are known to diverge</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public EpochEndOffset DivergingEpoch 
				{
					get => _divergingEpoch;
					private set 
					{
						if (Version >= 12 == false)
							throw new UnsupportedVersionException($"DivergingEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

						_divergingEpoch = value;
						_divergingEpochIsSet = true;
					}
				}

				/// <summary>
				/// <para>In case divergence is detected based on the `LastFetchedEpoch` and `FetchOffset` in the request, this field indicates the largest epoch and its end offset such that subsequent records are known to diverge</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public PartitionData WithDivergingEpoch(Func<EpochEndOffset, EpochEndOffset> createField)
				{
					DivergingEpoch = createField(new EpochEndOffset(Version));
					return this;
				}

				public class EpochEndOffset : ISerialize
				{
					internal EpochEndOffset(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 12;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 12 ? 
							_epoch.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 12 ? 
							_endOffset.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<EpochEndOffset> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new EpochEndOffset(version);
						if (instance.Version >= 12) 
							instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 12) 
							instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for EpochEndOffset is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 12)
							await _epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 12)
							await _endOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _epoch = new Int32(-1);
					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						private set 
						{
							if (Version >= 12 == false)
								throw new UnsupportedVersionException($"Epoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public EpochEndOffset WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}

					private Int64 _endOffset = new Int64(-1);
					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						private set 
						{
							if (Version >= 12 == false)
								throw new UnsupportedVersionException($"EndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public EpochEndOffset WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}
				}

				private bool _currentLeaderIsSet;
				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 12+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					private set 
					{
						if (Version >= 12 == false)
							throw new UnsupportedVersionException($"CurrentLeader does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

						_currentLeader = value;
						_currentLeaderIsSet = true;
					}
				}

				/// <summary>
				/// <para>Versions: 12+</para>
				/// </summary>
				public PartitionData WithCurrentLeader(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(new LeaderIdAndEpoch(Version));
					return this;
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 12;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 12 ? 
							_leaderId.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 12 ? 
							_leaderEpoch.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						if (instance.Version >= 12) 
							instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 12) 
							instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 12)
							await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 12)
							await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _leaderId = new Int32(-1);
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						private set 
						{
							if (Version >= 12 == false)
								throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = new Int32(-1);
					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						private set 
						{
							if (Version >= 12 == false)
								throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}

				private bool _snapshotIdIsSet;
				private SnapshotId _snapshotId = default!;
				/// <summary>
				/// <para>In the case of fetching an offset less than the LogStartOffset, this is the end offset and epoch that should be used in the FetchSnapshot request.</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public SnapshotId SnapshotId_ 
				{
					get => _snapshotId;
					private set 
					{
						if (Version >= 12 == false)
							throw new UnsupportedVersionException($"SnapshotId_ does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");

						_snapshotId = value;
						_snapshotIdIsSet = true;
					}
				}

				/// <summary>
				/// <para>In the case of fetching an offset less than the LogStartOffset, this is the end offset and epoch that should be used in the FetchSnapshot request.</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public PartitionData WithSnapshotId_(Func<SnapshotId, SnapshotId> createField)
				{
					SnapshotId_ = createField(new SnapshotId(Version));
					return this;
				}

				public class SnapshotId : ISerialize
				{
					internal SnapshotId(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 12;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_endOffset.GetSize(IsFlexibleVersion) +
						_epoch.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<SnapshotId> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new SnapshotId(version);
						instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotId is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _endOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _endOffset = new Int64(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						private set 
						{
							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public SnapshotId WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}

					private Int32 _epoch = new Int32(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						private set 
						{
							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public SnapshotId WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}
				}

				private NullableArray<AbortedTransaction> _abortedTransactionsCollection = Array.Empty<AbortedTransaction>();
				/// <summary>
				/// <para>The aborted transactions.</para>
				/// <para>Versions: 4+</para>
				/// </summary>
				public Array<AbortedTransaction>? AbortedTransactionsCollection 
				{
					get => _abortedTransactionsCollection;
					private set 
					{
						if (Version >= 4 == false &&
							value == null) 
							throw new UnsupportedVersionException($"AbortedTransactionsCollection does not support null for version {Version}. Supported versions for null value: 4+");

						_abortedTransactionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The aborted transactions.</para>
				/// <para>Versions: 4+</para>
				/// </summary>
				public PartitionData WithAbortedTransactionsCollection(params Func<AbortedTransaction, AbortedTransaction>[] createFields)
				{
					AbortedTransactionsCollection = createFields
						.Select(createField => createField(new AbortedTransaction(Version)))
						.ToArray();
					return this;
				}

				public delegate AbortedTransaction CreateAbortedTransaction(AbortedTransaction field);

				/// <summary>
				/// <para>The aborted transactions.</para>
				/// <para>Versions: 4+</para>
				/// </summary>
				public PartitionData WithAbortedTransactionsCollection(IEnumerable<CreateAbortedTransaction> createFields)
				{
					AbortedTransactionsCollection = createFields
						.Select(createField => createField(new AbortedTransaction(Version)))
						.ToArray();
					return this;
				}

				public class AbortedTransaction : ISerialize
				{
					internal AbortedTransaction(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 12;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 4 ? 
							_producerId.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 4 ? 
							_firstOffset.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<AbortedTransaction> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new AbortedTransaction(version);
						if (instance.Version >= 4) 
							instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 4) 
							instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for AbortedTransaction is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 4)
							await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 4)
							await _firstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _producerId = Int64.Default;
					/// <summary>
					/// <para>The producer id associated with the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public Int64 ProducerId 
					{
						get => _producerId;
						private set 
						{
							if (Version >= 4 == false)
								throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

							_producerId = value;
						}
					}

					/// <summary>
					/// <para>The producer id associated with the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public AbortedTransaction WithProducerId(Int64 producerId)
					{
						ProducerId = producerId;
						return this;
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>The first offset in the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						private set 
						{
							if (Version >= 4 == false)
								throw new UnsupportedVersionException($"FirstOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>The first offset in the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public AbortedTransaction WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}
				}

				private Int32 _preferredReadReplica = new Int32(-1);
				/// <summary>
				/// <para>The preferred read replica for the consumer to use on its next fetch request</para>
				/// <para>Versions: 11+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 PreferredReadReplica 
				{
					get => _preferredReadReplica;
					private set 
					{
						if (Version >= 11 == false)
							throw new UnsupportedVersionException($"PreferredReadReplica does not support version {Version} and has been defined as not ignorable. Supported versions: 11+");

						_preferredReadReplica = value;
					}
				}

				/// <summary>
				/// <para>The preferred read replica for the consumer to use on its next fetch request</para>
				/// <para>Versions: 11+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionData WithPreferredReadReplica(Int32 preferredReadReplica)
				{
					PreferredReadReplica = preferredReadReplica;
					return this;
				}

				private NullableRecordBatch _records = NullableRecordBatch.Default;
				/// <summary>
				/// <para>The record data.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public RecordBatch? Records 
				{
					get => _records;
					private set 
					{
						_records = value;
					}
				}

				/// <summary>
				/// <para>The record data.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithRecords(RecordBatch? records)
				{
					Records = records;
					return this;
				}
			}
		}

		private bool _nodeEndpointsCollectionIsSet;
		private Map<Int32, NodeEndpoint> _nodeEndpointsCollection = Map<Int32, NodeEndpoint>.Default;
		/// <summary>
		/// <para>Endpoints for all current-leaders enumerated in PartitionData, with errors NOT_LEADER_OR_FOLLOWER & FENCED_LEADER_EPOCH.</para>
		/// <para>Versions: 16+</para>
		/// </summary>
		public Map<Int32, NodeEndpoint> NodeEndpointsCollection 
		{
			get => _nodeEndpointsCollection;
			private set 
			{
				if (Version >= 16 == false)
					throw new UnsupportedVersionException($"NodeEndpointsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 16+");

				_nodeEndpointsCollection = value;
				_nodeEndpointsCollectionIsSet = true;
			}
		}

		/// <summary>
		/// <para>Endpoints for all current-leaders enumerated in PartitionData, with errors NOT_LEADER_OR_FOLLOWER & FENCED_LEADER_EPOCH.</para>
		/// <para>Versions: 16+</para>
		/// </summary>
		public FetchResponse WithNodeEndpointsCollection(params Func<NodeEndpoint, NodeEndpoint>[] createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public delegate NodeEndpoint CreateNodeEndpoint(NodeEndpoint field);

		/// <summary>
		/// <para>Endpoints for all current-leaders enumerated in PartitionData, with errors NOT_LEADER_OR_FOLLOWER & FENCED_LEADER_EPOCH.</para>
		/// <para>Versions: 16+</para>
		/// </summary>
		public FetchResponse WithNodeEndpointsCollection(IEnumerable<CreateNodeEndpoint> createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public class NodeEndpoint : ISerialize
		{
			internal NodeEndpoint(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 12;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 16 ? 
					_nodeId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 16 ? 
					_host.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 16 ? 
					_port.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 16 ? 
					_rack.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<NodeEndpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new NodeEndpoint(version);
				if (instance.Version >= 16) 
					instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 16) 
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 16) 
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 16) 
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for NodeEndpoint is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 16)
					await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 16)
					await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 16)
					await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 16)
					await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 16+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					if (Version >= 16 == false)
						throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 16+");

					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 16+</para>
			/// </summary>
			public NodeEndpoint WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 16+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					if (Version >= 16 == false)
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 16+");

					_host = value;
				}
			}

			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 16+</para>
			/// </summary>
			public NodeEndpoint WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 16+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					if (Version >= 16 == false)
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 16+");

					_port = value;
				}
			}

			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 16+</para>
			/// </summary>
			public NodeEndpoint WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private NullableString _rack = new NullableString(null);
			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 16+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					if (Version >= 16 == false)
						throw new UnsupportedVersionException($"Rack does not support version {Version} and has been defined as not ignorable. Supported versions: 16+");

					if (Version >= 16 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 16+");

					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 16+</para>
			/// <para>Default: null</para>
			/// </summary>
			public NodeEndpoint WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}
	}

	public class FetchSnapshotRequest : Message, IRespond<FetchSnapshotResponse>
	{
		public FetchSnapshotRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"FetchSnapshotRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(59);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (_clusterIdIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _clusterId
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
		 +
			_replicaId.GetSize(IsFlexibleVersion) +
			_maxBytes.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<FetchSnapshotRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchSnapshotRequest(version);
			instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							{
								var size = instance._clusterId.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field ClusterId read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchSnapshotRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _replicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _maxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private bool _clusterIdIsSet;
		private NullableString _clusterId = new NullableString(null);
		/// <summary>
		/// <para>The clusterId if known, this is used to validate metadata fetches prior to broker registration</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
				_clusterIdIsSet = true;
			}
		}

		/// <summary>
		/// <para>The clusterId if known, this is used to validate metadata fetches prior to broker registration</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public FetchSnapshotRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _replicaId = new Int32(-1);
		/// <summary>
		/// <para>The broker ID of the follower</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			private set 
			{
				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the follower</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public FetchSnapshotRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Int32 _maxBytes = new Int32(0x7fffffff);
		/// <summary>
		/// <para>The maximum bytes to fetch from all of the snapshots</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public Int32 MaxBytes 
		{
			get => _maxBytes;
			private set 
			{
				_maxBytes = value;
			}
		}

		/// <summary>
		/// <para>The maximum bytes to fetch from all of the snapshots</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public FetchSnapshotRequest WithMaxBytes(Int32 maxBytes)
		{
			MaxBytes = maxBytes;
			return this;
		}

		private Array<TopicSnapshot> _topicsCollection = Array.Empty<TopicSnapshot>();
		/// <summary>
		/// <para>The topics to fetch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicSnapshot> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotRequest WithTopicsCollection(params Func<TopicSnapshot, TopicSnapshot>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicSnapshot(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicSnapshot CreateTopicSnapshot(TopicSnapshot field);

		/// <summary>
		/// <para>The topics to fetch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotRequest WithTopicsCollection(IEnumerable<CreateTopicSnapshot> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicSnapshot(Version)))
				.ToArray();
			return this;
		}

		public class TopicSnapshot : ISerialize
		{
			internal TopicSnapshot(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicSnapshot(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicSnapshot is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<PartitionSnapshot> _partitionsCollection = Array.Empty<PartitionSnapshot>();
			/// <summary>
			/// <para>The partitions to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionSnapshot> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithPartitionsCollection(params Func<PartitionSnapshot, PartitionSnapshot>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionSnapshot(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionSnapshot CreatePartitionSnapshot(PartitionSnapshot field);

			/// <summary>
			/// <para>The partitions to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithPartitionsCollection(IEnumerable<CreatePartitionSnapshot> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionSnapshot(Version)))
					.ToArray();
				return this;
			}

			public class PartitionSnapshot : ISerialize
			{
				internal PartitionSnapshot(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_currentLeaderEpoch.GetSize(IsFlexibleVersion) +
					_snapshotId.GetSize(IsFlexibleVersion) +
					_position.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionSnapshot(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.SnapshotId_ = await SnapshotId.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
					instance.Position = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionSnapshot is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _currentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _snapshotId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _position.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _currentLeaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The current leader epoch of the partition, -1 for unknown leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					private set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current leader epoch of the partition, -1 for unknown leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private SnapshotId _snapshotId = default!;
				/// <summary>
				/// <para>The snapshot endOffset and epoch to fetch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public SnapshotId SnapshotId_ 
				{
					get => _snapshotId;
					private set 
					{
						_snapshotId = value;
					}
				}

				/// <summary>
				/// <para>The snapshot endOffset and epoch to fetch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithSnapshotId_(Func<SnapshotId, SnapshotId> createField)
				{
					SnapshotId_ = createField(new SnapshotId(Version));
					return this;
				}

				public class SnapshotId : ISerialize
				{
					internal SnapshotId(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_endOffset.GetSize(IsFlexibleVersion) +
						_epoch.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<SnapshotId> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new SnapshotId(version);
						instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotId is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _endOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _endOffset = Int64.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						private set 
						{
							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}

					private Int32 _epoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						private set 
						{
							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}
				}

				private Int64 _position = Int64.Default;
				/// <summary>
				/// <para>The byte position within the snapshot to start fetching from</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Position 
				{
					get => _position;
					private set 
					{
						_position = value;
					}
				}

				/// <summary>
				/// <para>The byte position within the snapshot to start fetching from</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithPosition(Int64 position)
				{
					Position = position;
					return this;
				}
			}
		}

		public FetchSnapshotResponse Respond()
			=> new FetchSnapshotResponse(Version);
	}

	public class FetchSnapshotResponse : Message
	{
		public FetchSnapshotResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"FetchSnapshotResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(59);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<FetchSnapshotResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchSnapshotResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchSnapshotResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<TopicSnapshot> _topicsCollection = Array.Empty<TopicSnapshot>();
		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicSnapshot> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithTopicsCollection(params Func<TopicSnapshot, TopicSnapshot>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicSnapshot(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicSnapshot CreateTopicSnapshot(TopicSnapshot field);

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithTopicsCollection(IEnumerable<CreateTopicSnapshot> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicSnapshot(Version)))
				.ToArray();
			return this;
		}

		public class TopicSnapshot : ISerialize
		{
			internal TopicSnapshot(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicSnapshot(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicSnapshot is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<PartitionSnapshot> _partitionsCollection = Array.Empty<PartitionSnapshot>();
			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionSnapshot> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithPartitionsCollection(params Func<PartitionSnapshot, PartitionSnapshot>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionSnapshot(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionSnapshot CreatePartitionSnapshot(PartitionSnapshot field);

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithPartitionsCollection(IEnumerable<CreatePartitionSnapshot> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionSnapshot(Version)))
					.ToArray();
				return this;
			}

			public class PartitionSnapshot : ISerialize
			{
				internal PartitionSnapshot(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					var tags = new List<Tags.TaggedField>();
					if (_currentLeaderIsSet) 
						tags.Add(new Tags.TaggedField
						{
							Tag = 0,
							Field = _currentLeader
						});
					return new Tags.TagSection(tags.ToArray());
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_index.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_snapshotId.GetSize(IsFlexibleVersion) +
					_size.GetSize(IsFlexibleVersion) +
					_position.GetSize(IsFlexibleVersion) +
					_unalignedRecords.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionSnapshot(version);
					instance.Index = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.SnapshotId_ = await SnapshotId.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
					instance.Size = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Position = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.UnalignedRecords = await RecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								case 0:
									instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									{
										var size = instance._currentLeader.GetSize(true);
										if (size != tag.Length)
											throw new CorruptMessageException($"Tagged field CurrentLeader read length {tag.Length} but had actual length of {size}");
									}
									break;
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionSnapshot is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _index.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _snapshotId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _size.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _position.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _unalignedRecords.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _index = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Index 
				{
					get => _index;
					private set 
					{
						_index = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithIndex(Int32 index)
				{
					Index = index;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private SnapshotId _snapshotId = default!;
				/// <summary>
				/// <para>The snapshot endOffset and epoch fetched</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public SnapshotId SnapshotId_ 
				{
					get => _snapshotId;
					private set 
					{
						_snapshotId = value;
					}
				}

				/// <summary>
				/// <para>The snapshot endOffset and epoch fetched</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithSnapshotId_(Func<SnapshotId, SnapshotId> createField)
				{
					SnapshotId_ = createField(new SnapshotId(Version));
					return this;
				}

				public class SnapshotId : ISerialize
				{
					internal SnapshotId(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_endOffset.GetSize(IsFlexibleVersion) +
						_epoch.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<SnapshotId> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new SnapshotId(version);
						instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotId is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _endOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _endOffset = Int64.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						private set 
						{
							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}

					private Int32 _epoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						private set 
						{
							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}
				}

				private bool _currentLeaderIsSet;
				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					private set 
					{
						_currentLeader = value;
						_currentLeaderIsSet = true;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithCurrentLeader(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(new LeaderIdAndEpoch(Version));
					return this;
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_leaderId.GetSize(IsFlexibleVersion) +
						_leaderEpoch.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _leaderId = Int32.Default;
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						private set 
						{
							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = Int32.Default;
					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						private set 
						{
							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}

				private Int64 _size = Int64.Default;
				/// <summary>
				/// <para>The total size of the snapshot.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Size 
				{
					get => _size;
					private set 
					{
						_size = value;
					}
				}

				/// <summary>
				/// <para>The total size of the snapshot.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithSize(Int64 size)
				{
					Size = size;
					return this;
				}

				private Int64 _position = Int64.Default;
				/// <summary>
				/// <para>The starting byte position within the snapshot included in the Bytes field.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Position 
				{
					get => _position;
					private set 
					{
						_position = value;
					}
				}

				/// <summary>
				/// <para>The starting byte position within the snapshot included in the Bytes field.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithPosition(Int64 position)
				{
					Position = position;
					return this;
				}

				private RecordBatch _unalignedRecords = RecordBatch.Default;
				/// <summary>
				/// <para>Snapshot data in records format which may not be aligned on an offset boundary</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public RecordBatch UnalignedRecords 
				{
					get => _unalignedRecords;
					private set 
					{
						_unalignedRecords = value;
					}
				}

				/// <summary>
				/// <para>Snapshot data in records format which may not be aligned on an offset boundary</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithUnalignedRecords(RecordBatch unalignedRecords)
				{
					UnalignedRecords = unalignedRecords;
					return this;
				}
			}
		}
	}

	public class FindCoordinatorRequest : Message, IRespond<FindCoordinatorResponse>
	{
		public FindCoordinatorRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"FindCoordinatorRequest does not support version {version}. Valid versions are: 0-6");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(10);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 0 && Version <= 3 ? 
				_key.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 1 ? 
				_keyType.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 4 ? 
				_coordinatorKeysCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<FindCoordinatorRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FindCoordinatorRequest(version);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.KeyType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.CoordinatorKeysCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FindCoordinatorRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 0 && Version <= 3)
				await _key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _keyType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _coordinatorKeysCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _key = String.Default;
		/// <summary>
		/// <para>The coordinator key.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public String Key 
		{
			get => _key;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"Key does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_key = value;
			}
		}

		/// <summary>
		/// <para>The coordinator key.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorRequest WithKey(String key)
		{
			Key = key;
			return this;
		}

		private Int8 _keyType = new Int8(0);
		/// <summary>
		/// <para>The coordinator key type. (Group, transaction, etc.)</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int8 KeyType 
		{
			get => _keyType;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"KeyType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_keyType = value;
			}
		}

		/// <summary>
		/// <para>The coordinator key type. (Group, transaction, etc.)</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FindCoordinatorRequest WithKeyType(Int8 keyType)
		{
			KeyType = keyType;
			return this;
		}

		private Array<String> _coordinatorKeysCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The coordinator keys.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Array<String> CoordinatorKeysCollection 
		{
			get => _coordinatorKeysCollection;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"CoordinatorKeysCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_coordinatorKeysCollection = value;
			}
		}

		/// <summary>
		/// <para>The coordinator keys.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public FindCoordinatorRequest WithCoordinatorKeysCollection(Array<String> coordinatorKeysCollection)
		{
			CoordinatorKeysCollection = coordinatorKeysCollection;
			return this;
		}

		public FindCoordinatorResponse Respond()
			=> new FindCoordinatorResponse(Version);
	}

	public class FindCoordinatorResponse : Message
	{
		public FindCoordinatorResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"FindCoordinatorResponse does not support version {version}. Valid versions are: 0-6");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(10);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_errorCode.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 1 && Version <= 3 ? 
				_errorMessage.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_nodeId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_host.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 3 ? 
				_port.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 4 ? 
				_coordinatorsCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<FindCoordinatorResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FindCoordinatorResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1 && instance.Version <= 3) 
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 3) 
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.CoordinatorsCollection = await Array<Coordinator>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Coordinator.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FindCoordinatorResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1 && Version <= 3)
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 3)
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _coordinatorsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public FindCoordinatorResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 1-3</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				if (Version >= 1 && Version <= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 1-3");

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 1-3</para>
		/// </summary>
		public FindCoordinatorResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Int32 _nodeId = Int32.Default;
		/// <summary>
		/// <para>The node id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int32 NodeId 
		{
			get => _nodeId;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_nodeId = value;
			}
		}

		/// <summary>
		/// <para>The node id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithNodeId(Int32 nodeId)
		{
			NodeId = nodeId;
			return this;
		}

		private String _host = String.Default;
		/// <summary>
		/// <para>The host name.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public String Host 
		{
			get => _host;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_host = value;
			}
		}

		/// <summary>
		/// <para>The host name.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithHost(String host)
		{
			Host = host;
			return this;
		}

		private Int32 _port = Int32.Default;
		/// <summary>
		/// <para>The port.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int32 Port 
		{
			get => _port;
			private set 
			{
				if (Version >= 0 && Version <= 3 == false)
					throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");

				_port = value;
			}
		}

		/// <summary>
		/// <para>The port.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithPort(Int32 port)
		{
			Port = port;
			return this;
		}

		private Array<Coordinator> _coordinatorsCollection = Array.Empty<Coordinator>();
		/// <summary>
		/// <para>Each coordinator result in the response</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Array<Coordinator> CoordinatorsCollection 
		{
			get => _coordinatorsCollection;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"CoordinatorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_coordinatorsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each coordinator result in the response</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public FindCoordinatorResponse WithCoordinatorsCollection(params Func<Coordinator, Coordinator>[] createFields)
		{
			CoordinatorsCollection = createFields
				.Select(createField => createField(new Coordinator(Version)))
				.ToArray();
			return this;
		}

		public delegate Coordinator CreateCoordinator(Coordinator field);

		/// <summary>
		/// <para>Each coordinator result in the response</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public FindCoordinatorResponse WithCoordinatorsCollection(IEnumerable<CreateCoordinator> createFields)
		{
			CoordinatorsCollection = createFields
				.Select(createField => createField(new Coordinator(Version)))
				.ToArray();
			return this;
		}

		public class Coordinator : ISerialize
		{
			internal Coordinator(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 4 ? 
					_key.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_nodeId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_host.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_port.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_errorCode.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 4 ? 
					_errorMessage.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Coordinator> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Coordinator(version);
				if (instance.Version >= 4) 
					instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Coordinator is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 4)
					await _key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _key = String.Default;
			/// <summary>
			/// <para>The coordinator key.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String Key 
			{
				get => _key;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"Key does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_key = value;
				}
			}

			/// <summary>
			/// <para>The coordinator key.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithKey(String key)
			{
				Key = key;
				return this;
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The node id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The node id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The host name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_host = value;
				}
			}

			/// <summary>
			/// <para>The host name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_port = value;
				}
			}

			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					if (Version >= 4 == false)
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					if (Version >= 4 == false &&
						value == null) 
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 4+");

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class GetTelemetrySubscriptionsRequest : Message, IRespond<GetTelemetrySubscriptionsResponse>
	{
		public GetTelemetrySubscriptionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"GetTelemetrySubscriptionsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(71);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clientInstanceId.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<GetTelemetrySubscriptionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new GetTelemetrySubscriptionsRequest(version);
			instance.ClientInstanceId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for GetTelemetrySubscriptionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clientInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Uuid _clientInstanceId = Uuid.Default;
		/// <summary>
		/// <para>Unique id for this client instance, must be set to 0 on the first request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid ClientInstanceId 
		{
			get => _clientInstanceId;
			private set 
			{
				_clientInstanceId = value;
			}
		}

		/// <summary>
		/// <para>Unique id for this client instance, must be set to 0 on the first request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsRequest WithClientInstanceId(Uuid clientInstanceId)
		{
			ClientInstanceId = clientInstanceId;
			return this;
		}

		public GetTelemetrySubscriptionsResponse Respond()
			=> new GetTelemetrySubscriptionsResponse(Version);
	}

	public class GetTelemetrySubscriptionsResponse : Message
	{
		public GetTelemetrySubscriptionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"GetTelemetrySubscriptionsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(71);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_clientInstanceId.GetSize(IsFlexibleVersion) +
			_subscriptionId.GetSize(IsFlexibleVersion) +
			_acceptedCompressionTypesCollection.GetSize(IsFlexibleVersion) +
			_pushIntervalMs.GetSize(IsFlexibleVersion) +
			_telemetryMaxBytes.GetSize(IsFlexibleVersion) +
			_deltaTemporality.GetSize(IsFlexibleVersion) +
			_requestedMetricsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<GetTelemetrySubscriptionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new GetTelemetrySubscriptionsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ClientInstanceId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.SubscriptionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.AcceptedCompressionTypesCollection = await Array<Int8>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.PushIntervalMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TelemetryMaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.DeltaTemporality = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RequestedMetricsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for GetTelemetrySubscriptionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _clientInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _subscriptionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _acceptedCompressionTypesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _pushIntervalMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _telemetryMaxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _deltaTemporality.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _requestedMetricsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Uuid _clientInstanceId = Uuid.Default;
		/// <summary>
		/// <para>Assigned client instance id if ClientInstanceId was 0 in the request, else 0.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid ClientInstanceId 
		{
			get => _clientInstanceId;
			private set 
			{
				_clientInstanceId = value;
			}
		}

		/// <summary>
		/// <para>Assigned client instance id if ClientInstanceId was 0 in the request, else 0.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithClientInstanceId(Uuid clientInstanceId)
		{
			ClientInstanceId = clientInstanceId;
			return this;
		}

		private Int32 _subscriptionId = Int32.Default;
		/// <summary>
		/// <para>Unique identifier for the current subscription set for this client instance.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 SubscriptionId 
		{
			get => _subscriptionId;
			private set 
			{
				_subscriptionId = value;
			}
		}

		/// <summary>
		/// <para>Unique identifier for the current subscription set for this client instance.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithSubscriptionId(Int32 subscriptionId)
		{
			SubscriptionId = subscriptionId;
			return this;
		}

		private Array<Int8> _acceptedCompressionTypesCollection = Array.Empty<Int8>();
		/// <summary>
		/// <para>Compression types that broker accepts for the PushTelemetryRequest.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<Int8> AcceptedCompressionTypesCollection 
		{
			get => _acceptedCompressionTypesCollection;
			private set 
			{
				_acceptedCompressionTypesCollection = value;
			}
		}

		/// <summary>
		/// <para>Compression types that broker accepts for the PushTelemetryRequest.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithAcceptedCompressionTypesCollection(Array<Int8> acceptedCompressionTypesCollection)
		{
			AcceptedCompressionTypesCollection = acceptedCompressionTypesCollection;
			return this;
		}

		private Int32 _pushIntervalMs = Int32.Default;
		/// <summary>
		/// <para>Configured push interval, which is the lowest configured interval in the current subscription set.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 PushIntervalMs 
		{
			get => _pushIntervalMs;
			private set 
			{
				_pushIntervalMs = value;
			}
		}

		/// <summary>
		/// <para>Configured push interval, which is the lowest configured interval in the current subscription set.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithPushIntervalMs(Int32 pushIntervalMs)
		{
			PushIntervalMs = pushIntervalMs;
			return this;
		}

		private Int32 _telemetryMaxBytes = Int32.Default;
		/// <summary>
		/// <para>The maximum bytes of binary data the broker accepts in PushTelemetryRequest.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TelemetryMaxBytes 
		{
			get => _telemetryMaxBytes;
			private set 
			{
				_telemetryMaxBytes = value;
			}
		}

		/// <summary>
		/// <para>The maximum bytes of binary data the broker accepts in PushTelemetryRequest.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithTelemetryMaxBytes(Int32 telemetryMaxBytes)
		{
			TelemetryMaxBytes = telemetryMaxBytes;
			return this;
		}

		private Boolean _deltaTemporality = Boolean.Default;
		/// <summary>
		/// <para>Flag to indicate monotonic/counter metrics are to be emitted as deltas or cumulative values</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean DeltaTemporality 
		{
			get => _deltaTemporality;
			private set 
			{
				_deltaTemporality = value;
			}
		}

		/// <summary>
		/// <para>Flag to indicate monotonic/counter metrics are to be emitted as deltas or cumulative values</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithDeltaTemporality(Boolean deltaTemporality)
		{
			DeltaTemporality = deltaTemporality;
			return this;
		}

		private Array<String> _requestedMetricsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Requested metrics prefix string match. Empty array: No metrics subscribed, Array[0] empty string: All metrics subscribed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> RequestedMetricsCollection 
		{
			get => _requestedMetricsCollection;
			private set 
			{
				_requestedMetricsCollection = value;
			}
		}

		/// <summary>
		/// <para>Requested metrics prefix string match. Empty array: No metrics subscribed, Array[0] empty string: All metrics subscribed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public GetTelemetrySubscriptionsResponse WithRequestedMetricsCollection(Array<String> requestedMetricsCollection)
		{
			RequestedMetricsCollection = requestedMetricsCollection;
			return this;
		}
	}

	public class HeartbeatRequest : Message, IRespond<HeartbeatResponse>
	{
		public HeartbeatRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"HeartbeatRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(12);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_generationId.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_groupInstanceId.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<HeartbeatRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new HeartbeatRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for HeartbeatRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _generationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _generationId = Int32.Default;
		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			private set 
			{
				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private NullableString _groupInstanceId = new NullableString(null);
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public HeartbeatRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		public HeartbeatResponse Respond()
			=> new HeartbeatResponse(Version);
	}

	public class HeartbeatResponse : Message
	{
		public HeartbeatResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"HeartbeatResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(12);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<HeartbeatResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new HeartbeatResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for HeartbeatResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public HeartbeatResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class IncrementalAlterConfigsRequest : Message, IRespond<IncrementalAlterConfigsResponse>
	{
		public IncrementalAlterConfigsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"IncrementalAlterConfigsRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(44);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resourcesCollection.GetSize(IsFlexibleVersion) +
			_validateOnly.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<IncrementalAlterConfigsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new IncrementalAlterConfigsRequest(version);
			instance.ResourcesCollection = await Map<Int8, AlterConfigsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResource.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.ResourceType, cancellationToken).ConfigureAwait(false);
			instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for IncrementalAlterConfigsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resourcesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _validateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<Int8, AlterConfigsResource> _resourcesCollection = Map<Int8, AlterConfigsResource>.Default;
		/// <summary>
		/// <para>The incremental updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int8, AlterConfigsResource> ResourcesCollection 
		{
			get => _resourcesCollection;
			private set 
			{
				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>The incremental updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsRequest WithResourcesCollection(params Func<AlterConfigsResource, AlterConfigsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new AlterConfigsResource(Version)))
				.ToDictionary(field => field.ResourceType);
			return this;
		}

		public delegate AlterConfigsResource CreateAlterConfigsResource(AlterConfigsResource field);

		/// <summary>
		/// <para>The incremental updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsRequest WithResourcesCollection(IEnumerable<CreateAlterConfigsResource> createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(new AlterConfigsResource(Version)))
				.ToDictionary(field => field.ResourceType);
			return this;
		}

		public class AlterConfigsResource : ISerialize
		{
			internal AlterConfigsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				_configsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterConfigsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResource(version);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ConfigsCollection = await Map<String, AlterableConfig>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterableConfig.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResource is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _configsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Map<String, AlterableConfig> _configsCollection = Map<String, AlterableConfig>.Default;
			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<String, AlterableConfig> ConfigsCollection 
			{
				get => _configsCollection;
				private set 
				{
					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithConfigsCollection(params Func<AlterableConfig, AlterableConfig>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new AlterableConfig(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public delegate AlterableConfig CreateAlterableConfig(AlterableConfig field);

			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithConfigsCollection(IEnumerable<CreateAlterableConfig> createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(new AlterableConfig(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public class AlterableConfig : ISerialize
			{
				internal AlterableConfig(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_configOperation.GetSize(IsFlexibleVersion) +
					_value.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<AlterableConfig> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterableConfig(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ConfigOperation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterableConfig is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _configOperation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithName(String name)
				{
					Name = name;
					return this;
				}

				private Int8 _configOperation = Int8.Default;
				/// <summary>
				/// <para>The type (Set, Delete, Append, Subtract) of operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 ConfigOperation 
				{
					get => _configOperation;
					private set 
					{
						_configOperation = value;
					}
				}

				/// <summary>
				/// <para>The type (Set, Delete, Append, Subtract) of operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithConfigOperation(Int8 configOperation)
				{
					ConfigOperation = configOperation;
					return this;
				}

				private NullableString _value = NullableString.Default;
				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					private set 
					{
						_value = value;
					}
				}

				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithValue(String? value)
				{
					Value = value;
					return this;
				}
			}
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			private set 
			{
				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public IncrementalAlterConfigsResponse Respond()
			=> new IncrementalAlterConfigsResponse(Version);
	}

	public class IncrementalAlterConfigsResponse : Message
	{
		public IncrementalAlterConfigsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"IncrementalAlterConfigsResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(44);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<IncrementalAlterConfigsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new IncrementalAlterConfigsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Array<AlterConfigsResourceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResourceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for IncrementalAlterConfigsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<AlterConfigsResourceResponse> _responsesCollection = Array.Empty<AlterConfigsResourceResponse>();
		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AlterConfigsResourceResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsResponse WithResponsesCollection(params Func<AlterConfigsResourceResponse, AlterConfigsResourceResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new AlterConfigsResourceResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate AlterConfigsResourceResponse CreateAlterConfigsResourceResponse(AlterConfigsResourceResponse field);

		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsResponse WithResponsesCollection(IEnumerable<CreateAlterConfigsResourceResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new AlterConfigsResourceResponse(Version)))
				.ToArray();
			return this;
		}

		public class AlterConfigsResourceResponse : ISerialize
		{
			internal AlterConfigsResourceResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_resourceType.GetSize(IsFlexibleVersion) +
				_resourceName.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AlterConfigsResourceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResourceResponse(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResourceResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _resourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				private set 
				{
					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				private set 
				{
					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}
		}
	}

	public class InitializeShareGroupStateRequest : Message, IRespond<InitializeShareGroupStateResponse>
	{
		public InitializeShareGroupStateRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"InitializeShareGroupStateRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(83);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<InitializeShareGroupStateRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new InitializeShareGroupStateRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<InitializeStateData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => InitializeStateData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for InitializeShareGroupStateRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitializeShareGroupStateRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Array<InitializeStateData> _topicsCollection = Array.Empty<InitializeStateData>();
		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<InitializeStateData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitializeShareGroupStateRequest WithTopicsCollection(params Func<InitializeStateData, InitializeStateData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new InitializeStateData(Version)))
				.ToArray();
			return this;
		}

		public delegate InitializeStateData CreateInitializeStateData(InitializeStateData field);

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitializeShareGroupStateRequest WithTopicsCollection(IEnumerable<CreateInitializeStateData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new InitializeStateData(Version)))
				.ToArray();
			return this;
		}

		public class InitializeStateData : ISerialize
		{
			internal InitializeStateData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<InitializeStateData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new InitializeStateData(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for InitializeStateData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public InitializeStateData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public InitializeStateData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public InitializeStateData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_stateEpoch.GetSize(IsFlexibleVersion) +
					_startOffset.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StateEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _stateEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _startOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _stateEpoch = Int32.Default;
				/// <summary>
				/// <para>The state epoch for this share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 StateEpoch 
				{
					get => _stateEpoch;
					private set 
					{
						_stateEpoch = value;
					}
				}

				/// <summary>
				/// <para>The state epoch for this share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithStateEpoch(Int32 stateEpoch)
				{
					StateEpoch = stateEpoch;
					return this;
				}

				private Int64 _startOffset = Int64.Default;
				/// <summary>
				/// <para>The share-partition start offset, or -1 if the start offset is not being initialized.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 StartOffset 
				{
					get => _startOffset;
					private set 
					{
						_startOffset = value;
					}
				}

				/// <summary>
				/// <para>The share-partition start offset, or -1 if the start offset is not being initialized.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithStartOffset(Int64 startOffset)
				{
					StartOffset = startOffset;
					return this;
				}
			}
		}

		public InitializeShareGroupStateResponse Respond()
			=> new InitializeShareGroupStateResponse(Version);
	}

	public class InitializeShareGroupStateResponse : Message
	{
		public InitializeShareGroupStateResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"InitializeShareGroupStateResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(83);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<InitializeShareGroupStateResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new InitializeShareGroupStateResponse(version);
			instance.ResultsCollection = await Array<InitializeStateResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => InitializeStateResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for InitializeShareGroupStateResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<InitializeStateResult> _resultsCollection = Array.Empty<InitializeStateResult>();
		/// <summary>
		/// <para>The initialization results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<InitializeStateResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The initialization results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitializeShareGroupStateResponse WithResultsCollection(params Func<InitializeStateResult, InitializeStateResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new InitializeStateResult(Version)))
				.ToArray();
			return this;
		}

		public delegate InitializeStateResult CreateInitializeStateResult(InitializeStateResult field);

		/// <summary>
		/// <para>The initialization results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitializeShareGroupStateResponse WithResultsCollection(IEnumerable<CreateInitializeStateResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new InitializeStateResult(Version)))
				.ToArray();
			return this;
		}

		public class InitializeStateResult : ISerialize
		{
			internal InitializeStateResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<InitializeStateResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new InitializeStateResult(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for InitializeStateResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public InitializeStateResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionResult> _partitionsCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public InitializeStateResult WithPartitionsCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResult CreatePartitionResult(PartitionResult field);

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public InitializeStateResult WithPartitionsCollection(IEnumerable<CreatePartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class InitProducerIdRequest : Message, IRespond<InitProducerIdResponse>
	{
		public InitProducerIdRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"InitProducerIdRequest does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(22);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_transactionalId.GetSize(IsFlexibleVersion) +
			_transactionTimeoutMs.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_producerId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_producerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<InitProducerIdRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new InitProducerIdRequest(version);
			instance.TransactionalId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TransactionTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for InitProducerIdRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _transactionTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _transactionalId = NullableString.Default;
		/// <summary>
		/// <para>The transactional id, or null if the producer is not transactional.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? TransactionalId 
		{
			get => _transactionalId;
			private set 
			{
				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional id, or null if the producer is not transactional.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdRequest WithTransactionalId(String? transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int32 _transactionTimeoutMs = Int32.Default;
		/// <summary>
		/// <para>The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TransactionTimeoutMs 
		{
			get => _transactionTimeoutMs;
			private set 
			{
				_transactionTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdRequest WithTransactionTimeoutMs(Int32 transactionTimeoutMs)
		{
			TransactionTimeoutMs = transactionTimeoutMs;
			return this;
		}

		private Int64 _producerId = new Int64(-1);
		/// <summary>
		/// <para>The producer id. This is used to disambiguate requests if a transactional id is reused following its expiration.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The producer id. This is used to disambiguate requests if a transactional id is reused following its expiration.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public InitProducerIdRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = new Int16(-1);
		/// <summary>
		/// <para>The producer's current epoch. This will be checked against the producer epoch on the broker, and the request will return an error if they do not match.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The producer's current epoch. This will be checked against the producer epoch on the broker, and the request will return an error if they do not match.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public InitProducerIdRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		public InitProducerIdResponse Respond()
			=> new InitProducerIdResponse(Version);
	}

	public class InitProducerIdResponse : Message
	{
		public InitProducerIdResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"InitProducerIdResponse does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(22);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_producerId.GetSize(IsFlexibleVersion) +
			_producerEpoch.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<InitProducerIdResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new InitProducerIdResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for InitProducerIdResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _producerId = new Int64(-1);
		/// <summary>
		/// <para>The current producer id.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			private set 
			{
				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The current producer id.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public InitProducerIdResponse WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>The current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			private set 
			{
				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdResponse WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}
	}

	public class JoinGroupRequest : Message, IRespond<JoinGroupResponse>
	{
		public JoinGroupRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"JoinGroupRequest does not support version {version}. Valid versions are: 0-9");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(11);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_sessionTimeoutMs.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_rebalanceTimeoutMs.GetSize(IsFlexibleVersion):
				0) +
			_memberId.GetSize(IsFlexibleVersion) +
			(Version >= 5 ? 
				_groupInstanceId.GetSize(IsFlexibleVersion):
				0) +
			_protocolType.GetSize(IsFlexibleVersion) +
			_protocolsCollection.GetSize(IsFlexibleVersion) +
			(Version >= 8 ? 
				_reason.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<JoinGroupRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new JoinGroupRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.SessionTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.RebalanceTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProtocolType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProtocolsCollection = await Map<String, JoinGroupRequestProtocol>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => JoinGroupRequestProtocol.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8) 
				instance.Reason = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _sessionTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _rebalanceTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _protocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _protocolsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8)
				await _reason.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _sessionTimeoutMs = Int32.Default;
		/// <summary>
		/// <para>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 SessionTimeoutMs 
		{
			get => _sessionTimeoutMs;
			private set 
			{
				_sessionTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithSessionTimeoutMs(Int32 sessionTimeoutMs)
		{
			SessionTimeoutMs = sessionTimeoutMs;
			return this;
		}

		private Int32 _rebalanceTimeoutMs = new Int32(-1);
		/// <summary>
		/// <para>The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 RebalanceTimeoutMs 
		{
			get => _rebalanceTimeoutMs;
			private set 
			{
				_rebalanceTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public JoinGroupRequest WithRebalanceTimeoutMs(Int32 rebalanceTimeoutMs)
		{
			RebalanceTimeoutMs = rebalanceTimeoutMs;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member id assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member id assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private NullableString _groupInstanceId = new NullableString(null);
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			private set 
			{
				if (Version >= 5 == false)
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

				if (Version >= 5 == false &&
					value == null) 
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 5+");

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public JoinGroupRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private String _protocolType = String.Default;
		/// <summary>
		/// <para>The unique name the for class of protocols implemented by the group we want to join.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ProtocolType 
		{
			get => _protocolType;
			private set 
			{
				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The unique name the for class of protocols implemented by the group we want to join.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithProtocolType(String protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private Map<String, JoinGroupRequestProtocol> _protocolsCollection = Map<String, JoinGroupRequestProtocol>.Default;
		/// <summary>
		/// <para>The list of protocols that the member supports.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, JoinGroupRequestProtocol> ProtocolsCollection 
		{
			get => _protocolsCollection;
			private set 
			{
				_protocolsCollection = value;
			}
		}

		/// <summary>
		/// <para>The list of protocols that the member supports.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithProtocolsCollection(params Func<JoinGroupRequestProtocol, JoinGroupRequestProtocol>[] createFields)
		{
			ProtocolsCollection = createFields
				.Select(createField => createField(new JoinGroupRequestProtocol(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate JoinGroupRequestProtocol CreateJoinGroupRequestProtocol(JoinGroupRequestProtocol field);

		/// <summary>
		/// <para>The list of protocols that the member supports.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithProtocolsCollection(IEnumerable<CreateJoinGroupRequestProtocol> createFields)
		{
			ProtocolsCollection = createFields
				.Select(createField => createField(new JoinGroupRequestProtocol(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class JoinGroupRequestProtocol : ISerialize
		{
			internal JoinGroupRequestProtocol(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_metadata.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<JoinGroupRequestProtocol> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new JoinGroupRequestProtocol(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Metadata = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupRequestProtocol is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The protocol name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The protocol name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupRequestProtocol WithName(String name)
			{
				Name = name;
				return this;
			}

			private Bytes _metadata = Bytes.Default;
			/// <summary>
			/// <para>The protocol metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Metadata 
			{
				get => _metadata;
				private set 
				{
					_metadata = value;
				}
			}

			/// <summary>
			/// <para>The protocol metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupRequestProtocol WithMetadata(Bytes metadata)
			{
				Metadata = metadata;
				return this;
			}
		}

		private NullableString _reason = new NullableString(null);
		/// <summary>
		/// <para>The reason why the member (re-)joins the group.</para>
		/// <para>Versions: 8+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? Reason 
		{
			get => _reason;
			private set 
			{
				if (Version >= 8 == false &&
					value == null) 
					throw new UnsupportedVersionException($"Reason does not support null for version {Version}. Supported versions for null value: 8+");

				_reason = value;
			}
		}

		/// <summary>
		/// <para>The reason why the member (re-)joins the group.</para>
		/// <para>Versions: 8+</para>
		/// <para>Default: null</para>
		/// </summary>
		public JoinGroupRequest WithReason(String? reason)
		{
			Reason = reason;
			return this;
		}

		public JoinGroupResponse Respond()
			=> new JoinGroupResponse(Version);
	}

	public class JoinGroupResponse : Message
	{
		public JoinGroupResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"JoinGroupResponse does not support version {version}. Valid versions are: 0-9");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(11);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 2 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_generationId.GetSize(IsFlexibleVersion) +
			(Version >= 7 ? 
				_protocolType.GetSize(IsFlexibleVersion):
				0) +
			_protocolName.GetSize(IsFlexibleVersion) +
			_leader.GetSize(IsFlexibleVersion) +
			(Version >= 9 ? 
				_skipAssignment.GetSize(IsFlexibleVersion):
				0) +
			_memberId.GetSize(IsFlexibleVersion) +
			_membersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<JoinGroupResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new JoinGroupResponse(version);
			if (instance.Version >= 2) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.ProtocolType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProtocolName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Leader = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 9) 
				instance.SkipAssignment = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MembersCollection = await Array<JoinGroupResponseMember>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => JoinGroupResponseMember.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 2)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _generationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _protocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _protocolName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _leader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 9)
				await _skipAssignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _membersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public JoinGroupResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int32 _generationId = new Int32(-1);
		/// <summary>
		/// <para>The generation ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			private set 
			{
				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public JoinGroupResponse WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private NullableString _protocolType = new NullableString(null);
		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolType 
		{
			get => _protocolType;
			private set 
			{
				if (Version >= 7 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ProtocolType does not support null for version {Version}. Supported versions for null value: 7+");

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public JoinGroupResponse WithProtocolType(String? protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private NullableString _protocolName = NullableString.Default;
		/// <summary>
		/// <para>The group protocol selected by the coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ProtocolName 
		{
			get => _protocolName;
			private set 
			{
				if (Version >= 7 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ProtocolName does not support null for version {Version}. Supported versions for null value: 7+");

				_protocolName = value;
			}
		}

		/// <summary>
		/// <para>The group protocol selected by the coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithProtocolName(String? protocolName)
		{
			ProtocolName = protocolName;
			return this;
		}

		private String _leader = String.Default;
		/// <summary>
		/// <para>The leader of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Leader 
		{
			get => _leader;
			private set 
			{
				_leader = value;
			}
		}

		/// <summary>
		/// <para>The leader of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithLeader(String leader)
		{
			Leader = leader;
			return this;
		}

		private Boolean _skipAssignment = new Boolean(false);
		/// <summary>
		/// <para>True if the leader must skip running the assignment.</para>
		/// <para>Versions: 9+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean SkipAssignment 
		{
			get => _skipAssignment;
			private set 
			{
				if (Version >= 9 == false)
					throw new UnsupportedVersionException($"SkipAssignment does not support version {Version} and has been defined as not ignorable. Supported versions: 9+");

				_skipAssignment = value;
			}
		}

		/// <summary>
		/// <para>True if the leader must skip running the assignment.</para>
		/// <para>Versions: 9+</para>
		/// <para>Default: false</para>
		/// </summary>
		public JoinGroupResponse WithSkipAssignment(Boolean skipAssignment)
		{
			SkipAssignment = skipAssignment;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Array<JoinGroupResponseMember> _membersCollection = Array.Empty<JoinGroupResponseMember>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<JoinGroupResponseMember> MembersCollection 
		{
			get => _membersCollection;
			private set 
			{
				_membersCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithMembersCollection(params Func<JoinGroupResponseMember, JoinGroupResponseMember>[] createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(new JoinGroupResponseMember(Version)))
				.ToArray();
			return this;
		}

		public delegate JoinGroupResponseMember CreateJoinGroupResponseMember(JoinGroupResponseMember field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithMembersCollection(IEnumerable<CreateJoinGroupResponseMember> createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(new JoinGroupResponseMember(Version)))
				.ToArray();
			return this;
		}

		public class JoinGroupResponseMember : ISerialize
		{
			internal JoinGroupResponseMember(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_memberId.GetSize(IsFlexibleVersion) +
				(Version >= 5 ? 
					_groupInstanceId.GetSize(IsFlexibleVersion):
					0) +
				_metadata.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<JoinGroupResponseMember> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new JoinGroupResponseMember(version);
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Metadata = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupResponseMember is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The group member ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				private set 
				{
					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The group member ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupResponseMember WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private NullableString _groupInstanceId = new NullableString(null);
			/// <summary>
			/// <para>The unique identifier of the consumer instance provided by end user.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? GroupInstanceId 
			{
				get => _groupInstanceId;
				private set 
				{
					if (Version >= 5 == false &&
						value == null) 
						throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 5+");

					_groupInstanceId = value;
				}
			}

			/// <summary>
			/// <para>The unique identifier of the consumer instance provided by end user.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public JoinGroupResponseMember WithGroupInstanceId(String? groupInstanceId)
			{
				GroupInstanceId = groupInstanceId;
				return this;
			}

			private Bytes _metadata = Bytes.Default;
			/// <summary>
			/// <para>The group member metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Metadata 
			{
				get => _metadata;
				private set 
				{
					_metadata = value;
				}
			}

			/// <summary>
			/// <para>The group member metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupResponseMember WithMetadata(Bytes metadata)
			{
				Metadata = metadata;
				return this;
			}
		}
	}

	public class LeaderAndIsrRequest : Message, IRespond<LeaderAndIsrResponse>
	{
		public LeaderAndIsrRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"LeaderAndIsrRequest does not support version {version}. Valid versions are: 0-7");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(4);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_controllerId.GetSize(IsFlexibleVersion) +
			(Version >= 7 ? 
				_isKRaftController.GetSize(IsFlexibleVersion):
				0) +
			_controllerEpoch.GetSize(IsFlexibleVersion) +
			(Version >= 2 ? 
				_brokerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_type.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 1 ? 
				_ungroupedPartitionStatesCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 2 ? 
				_topicStatesCollection.GetSize(IsFlexibleVersion):
				0) +
			_liveLeadersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<LeaderAndIsrRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaderAndIsrRequest(version);
			instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.IsKRaftController = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.Type = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 1) 
				instance.UngroupedPartitionStatesCollection = await Array<LeaderAndIsrPartitionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.TopicStatesCollection = await Array<LeaderAndIsrTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.LiveLeadersCollection = await Array<LeaderAndIsrLiveLeader>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrLiveLeader.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _controllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _isKRaftController.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _controllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _type.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 1)
				await _ungroupedPartitionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _topicStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _liveLeadersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The current controller ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			private set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The current controller ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Boolean _isKRaftController = new Boolean(false);
		/// <summary>
		/// <para>If KRaft controller id is used during migration. See KIP-866</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IsKRaftController 
		{
			get => _isKRaftController;
			private set 
			{
				if (Version >= 7 == false)
					throw new UnsupportedVersionException($"IsKRaftController does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");

				_isKRaftController = value;
			}
		}

		/// <summary>
		/// <para>If KRaft controller id is used during migration. See KIP-866</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: false</para>
		/// </summary>
		public LeaderAndIsrRequest WithIsKRaftController(Boolean isKRaftController)
		{
			IsKRaftController = isKRaftController;
			return this;
		}

		private Int32 _controllerEpoch = Int32.Default;
		/// <summary>
		/// <para>The current controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerEpoch 
		{
			get => _controllerEpoch;
			private set 
			{
				_controllerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithControllerEpoch(Int32 controllerEpoch)
		{
			ControllerEpoch = controllerEpoch;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The current broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public LeaderAndIsrRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Int8 _type = Int8.Default;
		/// <summary>
		/// <para>The type that indicates whether all topics are included in the request</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public Int8 Type 
		{
			get => _type;
			private set 
			{
				if (Version >= 5 == false)
					throw new UnsupportedVersionException($"Type does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

				_type = value;
			}
		}

		/// <summary>
		/// <para>The type that indicates whether all topics are included in the request</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public LeaderAndIsrRequest WithType(Int8 type)
		{
			Type = type;
			return this;
		}

		private Array<LeaderAndIsrPartitionState> _ungroupedPartitionStatesCollection = Array.Empty<LeaderAndIsrPartitionState>();
		/// <summary>
		/// <para>The state of each partition, in a v0 or v1 message.</para>
		/// <para>Versions: 0-1</para>
		/// </summary>
		public Array<LeaderAndIsrPartitionState> UngroupedPartitionStatesCollection 
		{
			get => _ungroupedPartitionStatesCollection;
			private set 
			{
				if (Version >= 0 && Version <= 1 == false)
					throw new UnsupportedVersionException($"UngroupedPartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-1");

				_ungroupedPartitionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>The state of each partition, in a v0 or v1 message.</para>
		/// <para>Versions: 0-1</para>
		/// </summary>
		public LeaderAndIsrRequest WithUngroupedPartitionStatesCollection(Array<LeaderAndIsrPartitionState> ungroupedPartitionStatesCollection)
		{
			UngroupedPartitionStatesCollection = ungroupedPartitionStatesCollection;
			return this;
		}

		private Array<LeaderAndIsrTopicState> _topicStatesCollection = Array.Empty<LeaderAndIsrTopicState>();
		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Array<LeaderAndIsrTopicState> TopicStatesCollection 
		{
			get => _topicStatesCollection;
			private set 
			{
				if (Version >= 2 == false)
					throw new UnsupportedVersionException($"TopicStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

				_topicStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public LeaderAndIsrRequest WithTopicStatesCollection(params Func<LeaderAndIsrTopicState, LeaderAndIsrTopicState>[] createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(new LeaderAndIsrTopicState(Version)))
				.ToArray();
			return this;
		}

		public delegate LeaderAndIsrTopicState CreateLeaderAndIsrTopicState(LeaderAndIsrTopicState field);

		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public LeaderAndIsrRequest WithTopicStatesCollection(IEnumerable<CreateLeaderAndIsrTopicState> createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(new LeaderAndIsrTopicState(Version)))
				.ToArray();
			return this;
		}

		public class LeaderAndIsrTopicState : ISerialize
		{
			internal LeaderAndIsrTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 2 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 2 ? 
					_partitionStatesCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<LeaderAndIsrTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrTopicState(version);
				if (instance.Version >= 2) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 2) 
					instance.PartitionStatesCollection = await Array<LeaderAndIsrPartitionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrTopicState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 2)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _partitionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					if (Version >= 2 == false)
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public LeaderAndIsrTopicState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrTopicState WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<LeaderAndIsrPartitionState> _partitionStatesCollection = Array.Empty<LeaderAndIsrPartitionState>();
			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public Array<LeaderAndIsrPartitionState> PartitionStatesCollection 
			{
				get => _partitionStatesCollection;
				private set 
				{
					if (Version >= 2 == false)
						throw new UnsupportedVersionException($"PartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

					_partitionStatesCollection = value;
				}
			}

			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public LeaderAndIsrTopicState WithPartitionStatesCollection(Array<LeaderAndIsrPartitionState> partitionStatesCollection)
			{
				PartitionStatesCollection = partitionStatesCollection;
				return this;
			}
		}

		private Array<LeaderAndIsrLiveLeader> _liveLeadersCollection = Array.Empty<LeaderAndIsrLiveLeader>();
		/// <summary>
		/// <para>The current live leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<LeaderAndIsrLiveLeader> LiveLeadersCollection 
		{
			get => _liveLeadersCollection;
			private set 
			{
				_liveLeadersCollection = value;
			}
		}

		/// <summary>
		/// <para>The current live leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithLiveLeadersCollection(params Func<LeaderAndIsrLiveLeader, LeaderAndIsrLiveLeader>[] createFields)
		{
			LiveLeadersCollection = createFields
				.Select(createField => createField(new LeaderAndIsrLiveLeader(Version)))
				.ToArray();
			return this;
		}

		public delegate LeaderAndIsrLiveLeader CreateLeaderAndIsrLiveLeader(LeaderAndIsrLiveLeader field);

		/// <summary>
		/// <para>The current live leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithLiveLeadersCollection(IEnumerable<CreateLeaderAndIsrLiveLeader> createFields)
		{
			LiveLeadersCollection = createFields
				.Select(createField => createField(new LeaderAndIsrLiveLeader(Version)))
				.ToArray();
			return this;
		}

		public class LeaderAndIsrLiveLeader : ISerialize
		{
			internal LeaderAndIsrLiveLeader(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_brokerId.GetSize(IsFlexibleVersion) +
				_hostName.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<LeaderAndIsrLiveLeader> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrLiveLeader(version);
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.HostName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrLiveLeader is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _hostName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _brokerId = Int32.Default;
			/// <summary>
			/// <para>The leader's broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 BrokerId 
			{
				get => _brokerId;
				private set 
				{
					_brokerId = value;
				}
			}

			/// <summary>
			/// <para>The leader's broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrLiveLeader WithBrokerId(Int32 brokerId)
			{
				BrokerId = brokerId;
				return this;
			}

			private String _hostName = String.Default;
			/// <summary>
			/// <para>The leader's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String HostName 
			{
				get => _hostName;
				private set 
				{
					_hostName = value;
				}
			}

			/// <summary>
			/// <para>The leader's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrLiveLeader WithHostName(String hostName)
			{
				HostName = hostName;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The leader's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The leader's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrLiveLeader WithPort(Int32 port)
			{
				Port = port;
				return this;
			}
		}

		public class LeaderAndIsrPartitionState : ISerialize
		{
			internal LeaderAndIsrPartitionState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 1 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				_controllerEpoch.GetSize(IsFlexibleVersion) +
				_leader.GetSize(IsFlexibleVersion) +
				_leaderEpoch.GetSize(IsFlexibleVersion) +
				_isrCollection.GetSize(IsFlexibleVersion) +
				_partitionEpoch.GetSize(IsFlexibleVersion) +
				_replicasCollection.GetSize(IsFlexibleVersion) +
				(Version >= 3 ? 
					_addingReplicasCollection.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_removingReplicasCollection.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 ? 
					_isNew.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 6 ? 
					_leaderRecoveryState.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<LeaderAndIsrPartitionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrPartitionState(version);
				if (instance.Version >= 0 && instance.Version <= 1) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Leader = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.IsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.PartitionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.AddingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.RemovingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.IsNew = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 6) 
					instance.LeaderRecoveryState = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrPartitionState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 1)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _controllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _leader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _isrCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _replicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _addingReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _removingReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _isNew.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 6)
					await _leaderRecoveryState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.  This is only present in v0 or v1.</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.  This is only present in v0 or v1.</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int32 _controllerEpoch = Int32.Default;
			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ControllerEpoch 
			{
				get => _controllerEpoch;
				private set 
				{
					_controllerEpoch = value;
				}
			}

			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithControllerEpoch(Int32 controllerEpoch)
			{
				ControllerEpoch = controllerEpoch;
				return this;
			}

			private Int32 _leader = Int32.Default;
			/// <summary>
			/// <para>The broker ID of the leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Leader 
			{
				get => _leader;
				private set 
				{
					_leader = value;
				}
			}

			/// <summary>
			/// <para>The broker ID of the leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithLeader(Int32 leader)
			{
				Leader = leader;
				return this;
			}

			private Int32 _leaderEpoch = Int32.Default;
			/// <summary>
			/// <para>The leader epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 LeaderEpoch 
			{
				get => _leaderEpoch;
				private set 
				{
					_leaderEpoch = value;
				}
			}

			/// <summary>
			/// <para>The leader epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithLeaderEpoch(Int32 leaderEpoch)
			{
				LeaderEpoch = leaderEpoch;
				return this;
			}

			private Array<Int32> _isrCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The in-sync replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> IsrCollection 
			{
				get => _isrCollection;
				private set 
				{
					_isrCollection = value;
				}
			}

			/// <summary>
			/// <para>The in-sync replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithIsrCollection(Array<Int32> isrCollection)
			{
				IsrCollection = isrCollection;
				return this;
			}

			private Int32 _partitionEpoch = Int32.Default;
			/// <summary>
			/// <para>The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionEpoch 
			{
				get => _partitionEpoch;
				private set 
				{
					_partitionEpoch = value;
				}
			}

			/// <summary>
			/// <para>The current epoch for the partition. The epoch is a monotonically increasing value which is incremented after every partition change. (Since the LeaderAndIsr request is only used by the legacy controller, this corresponds to the zkVersion)</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithPartitionEpoch(Int32 partitionEpoch)
			{
				PartitionEpoch = partitionEpoch;
				return this;
			}

			private Array<Int32> _replicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> ReplicasCollection 
			{
				get => _replicasCollection;
				private set 
				{
					_replicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithReplicasCollection(Array<Int32> replicasCollection)
			{
				ReplicasCollection = replicasCollection;
				return this;
			}

			private Array<Int32> _addingReplicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replica IDs that we are adding this partition to, or null if no replicas are being added.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Array<Int32> AddingReplicasCollection 
			{
				get => _addingReplicasCollection;
				private set 
				{
					_addingReplicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replica IDs that we are adding this partition to, or null if no replicas are being added.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithAddingReplicasCollection(Array<Int32> addingReplicasCollection)
			{
				AddingReplicasCollection = addingReplicasCollection;
				return this;
			}

			private Array<Int32> _removingReplicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replica IDs that we are removing this partition from, or null if no replicas are being removed.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Array<Int32> RemovingReplicasCollection 
			{
				get => _removingReplicasCollection;
				private set 
				{
					_removingReplicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replica IDs that we are removing this partition from, or null if no replicas are being removed.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithRemovingReplicasCollection(Array<Int32> removingReplicasCollection)
			{
				RemovingReplicasCollection = removingReplicasCollection;
				return this;
			}

			private Boolean _isNew = new Boolean(false);
			/// <summary>
			/// <para>Whether the replica should have existed on the broker or not.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public Boolean IsNew 
			{
				get => _isNew;
				private set 
				{
					_isNew = value;
				}
			}

			/// <summary>
			/// <para>Whether the replica should have existed on the broker or not.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithIsNew(Boolean isNew)
			{
				IsNew = isNew;
				return this;
			}

			private Int8 _leaderRecoveryState = new Int8(0);
			/// <summary>
			/// <para>1 if the partition is recovering from an unclean leader election; 0 otherwise.</para>
			/// <para>Versions: 6+</para>
			/// <para>Default: 0</para>
			/// </summary>
			public Int8 LeaderRecoveryState 
			{
				get => _leaderRecoveryState;
				private set 
				{
					if (Version >= 6 == false)
						throw new UnsupportedVersionException($"LeaderRecoveryState does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");

					_leaderRecoveryState = value;
				}
			}

			/// <summary>
			/// <para>1 if the partition is recovering from an unclean leader election; 0 otherwise.</para>
			/// <para>Versions: 6+</para>
			/// <para>Default: 0</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithLeaderRecoveryState(Int8 leaderRecoveryState)
			{
				LeaderRecoveryState = leaderRecoveryState;
				return this;
			}
		}

		public LeaderAndIsrResponse Respond()
			=> new LeaderAndIsrResponse(Version);
	}

	public class LeaderAndIsrResponse : Message
	{
		public LeaderAndIsrResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"LeaderAndIsrResponse does not support version {version}. Valid versions are: 0-7");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(4);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			(Version >= 0 && Version <= 4 ? 
				_partitionErrorsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_topicsCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<LeaderAndIsrResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaderAndIsrResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 4) 
				instance.PartitionErrorsCollection = await Array<LeaderAndIsrPartitionError>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrPartitionError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.TopicsCollection = await Map<Uuid, LeaderAndIsrTopicError>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrTopicError.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.TopicId, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 4)
				await _partitionErrorsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<LeaderAndIsrPartitionError> _partitionErrorsCollection = Array.Empty<LeaderAndIsrPartitionError>();
		/// <summary>
		/// <para>Each partition in v0 to v4 message.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public Array<LeaderAndIsrPartitionError> PartitionErrorsCollection 
		{
			get => _partitionErrorsCollection;
			private set 
			{
				if (Version >= 0 && Version <= 4 == false)
					throw new UnsupportedVersionException($"PartitionErrorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-4");

				_partitionErrorsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each partition in v0 to v4 message.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public LeaderAndIsrResponse WithPartitionErrorsCollection(Array<LeaderAndIsrPartitionError> partitionErrorsCollection)
		{
			PartitionErrorsCollection = partitionErrorsCollection;
			return this;
		}

		private Map<Uuid, LeaderAndIsrTopicError> _topicsCollection = Map<Uuid, LeaderAndIsrTopicError>.Default;
		/// <summary>
		/// <para>Each topic</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public Map<Uuid, LeaderAndIsrTopicError> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				if (Version >= 5 == false)
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public LeaderAndIsrResponse WithTopicsCollection(params Func<LeaderAndIsrTopicError, LeaderAndIsrTopicError>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new LeaderAndIsrTopicError(Version)))
				.ToDictionary(field => field.TopicId);
			return this;
		}

		public delegate LeaderAndIsrTopicError CreateLeaderAndIsrTopicError(LeaderAndIsrTopicError field);

		/// <summary>
		/// <para>Each topic</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public LeaderAndIsrResponse WithTopicsCollection(IEnumerable<CreateLeaderAndIsrTopicError> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new LeaderAndIsrTopicError(Version)))
				.ToDictionary(field => field.TopicId);
			return this;
		}

		public class LeaderAndIsrTopicError : ISerialize
		{
			internal LeaderAndIsrTopicError(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 5 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_partitionErrorsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<LeaderAndIsrTopicError> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrTopicError(version);
				if (instance.Version >= 5) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.PartitionErrorsCollection = await Array<LeaderAndIsrPartitionError>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrPartitionError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrTopicError is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 5)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _partitionErrorsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					if (Version >= 5 == false)
						throw new UnsupportedVersionException($"TopicId does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrTopicError WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<LeaderAndIsrPartitionError> _partitionErrorsCollection = Array.Empty<LeaderAndIsrPartitionError>();
			/// <summary>
			/// <para>Each partition.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Array<LeaderAndIsrPartitionError> PartitionErrorsCollection 
			{
				get => _partitionErrorsCollection;
				private set 
				{
					if (Version >= 5 == false)
						throw new UnsupportedVersionException($"PartitionErrorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

					_partitionErrorsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrTopicError WithPartitionErrorsCollection(Array<LeaderAndIsrPartitionError> partitionErrorsCollection)
			{
				PartitionErrorsCollection = partitionErrorsCollection;
				return this;
			}
		}

		public class LeaderAndIsrPartitionError : ISerialize
		{
			internal LeaderAndIsrPartitionError(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 4 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<LeaderAndIsrPartitionError> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrPartitionError(version);
				if (instance.Version >= 0 && instance.Version <= 4) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrPartitionError is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 4)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public LeaderAndIsrPartitionError WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionError WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The partition error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The partition error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionError WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class LeaveGroupRequest : Message, IRespond<LeaveGroupResponse>
	{
		public LeaveGroupRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"LeaveGroupRequest does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(13);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			(Version >= 0 && Version <= 2 ? 
				_memberId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_membersCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<LeaveGroupRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaveGroupRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 2) 
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.MembersCollection = await Array<MemberIdentity>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MemberIdentity.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaveGroupRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 2)
				await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _membersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The ID of the group to leave.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the group to leave.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaveGroupRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID to remove from the group.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				if (Version >= 0 && Version <= 2 == false)
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-2");

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID to remove from the group.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public LeaveGroupRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Array<MemberIdentity> _membersCollection = Array.Empty<MemberIdentity>();
		/// <summary>
		/// <para>List of leaving member identities.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Array<MemberIdentity> MembersCollection 
		{
			get => _membersCollection;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"MembersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_membersCollection = value;
			}
		}

		/// <summary>
		/// <para>List of leaving member identities.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public LeaveGroupRequest WithMembersCollection(params Func<MemberIdentity, MemberIdentity>[] createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(new MemberIdentity(Version)))
				.ToArray();
			return this;
		}

		public delegate MemberIdentity CreateMemberIdentity(MemberIdentity field);

		/// <summary>
		/// <para>List of leaving member identities.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public LeaveGroupRequest WithMembersCollection(IEnumerable<CreateMemberIdentity> createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(new MemberIdentity(Version)))
				.ToArray();
			return this;
		}

		public class MemberIdentity : ISerialize
		{
			internal MemberIdentity(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 3 ? 
					_memberId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_groupInstanceId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_reason.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<MemberIdentity> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MemberIdentity(version);
				if (instance.Version >= 3) 
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.Reason = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MemberIdentity is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 3)
					await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _reason.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberIdentity WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private NullableString _groupInstanceId = new NullableString(null);
			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? GroupInstanceId 
			{
				get => _groupInstanceId;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					if (Version >= 3 == false &&
						value == null) 
						throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");

					_groupInstanceId = value;
				}
			}

			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: null</para>
			/// </summary>
			public MemberIdentity WithGroupInstanceId(String? groupInstanceId)
			{
				GroupInstanceId = groupInstanceId;
				return this;
			}

			private NullableString _reason = new NullableString(null);
			/// <summary>
			/// <para>The reason why the member left the group.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Reason 
			{
				get => _reason;
				private set 
				{
					if (Version >= 5 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Reason does not support null for version {Version}. Supported versions for null value: 5+");

					_reason = value;
				}
			}

			/// <summary>
			/// <para>The reason why the member left the group.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public MemberIdentity WithReason(String? reason)
			{
				Reason = reason;
				return this;
			}
		}

		public LeaveGroupResponse Respond()
			=> new LeaveGroupResponse(Version);
	}

	public class LeaveGroupResponse : Message
	{
		public LeaveGroupResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"LeaveGroupResponse does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(13);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_membersCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<LeaveGroupResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaveGroupResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.MembersCollection = await Array<MemberResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MemberResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaveGroupResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _membersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public LeaveGroupResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaveGroupResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<MemberResponse> _membersCollection = Array.Empty<MemberResponse>();
		/// <summary>
		/// <para>List of leaving member responses.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Array<MemberResponse> MembersCollection 
		{
			get => _membersCollection;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"MembersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_membersCollection = value;
			}
		}

		/// <summary>
		/// <para>List of leaving member responses.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public LeaveGroupResponse WithMembersCollection(params Func<MemberResponse, MemberResponse>[] createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(new MemberResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate MemberResponse CreateMemberResponse(MemberResponse field);

		/// <summary>
		/// <para>List of leaving member responses.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public LeaveGroupResponse WithMembersCollection(IEnumerable<CreateMemberResponse> createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(new MemberResponse(Version)))
				.ToArray();
			return this;
		}

		public class MemberResponse : ISerialize
		{
			internal MemberResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 3 ? 
					_memberId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_groupInstanceId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_errorCode.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<MemberResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MemberResponse(version);
				if (instance.Version >= 3) 
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MemberResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 3)
					await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberResponse WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private NullableString _groupInstanceId = NullableString.Default;
			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String? GroupInstanceId 
			{
				get => _groupInstanceId;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					if (Version >= 3 == false &&
						value == null) 
						throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");

					_groupInstanceId = value;
				}
			}

			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberResponse WithGroupInstanceId(String? groupInstanceId)
			{
				GroupInstanceId = groupInstanceId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberResponse WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class ListClientMetricsResourcesRequest : Message, IRespond<ListClientMetricsResourcesResponse>
	{
		public ListClientMetricsResourcesRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListClientMetricsResourcesRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(74);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
		 +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListClientMetricsResourcesRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListClientMetricsResourcesRequest(version);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListClientMetricsResourcesRequest is unknown");
					}
				}
			}

			return await new ValueTask<ListClientMetricsResourcesRequest>(instance);
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await Task.CompletedTask;
			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		public ListClientMetricsResourcesResponse Respond()
			=> new ListClientMetricsResourcesResponse(Version);
	}

	public class ListClientMetricsResourcesResponse : Message
	{
		public ListClientMetricsResourcesResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListClientMetricsResourcesResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(74);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_clientMetricsResourcesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListClientMetricsResourcesResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListClientMetricsResourcesResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ClientMetricsResourcesCollection = await Array<ClientMetricsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ClientMetricsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListClientMetricsResourcesResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _clientMetricsResourcesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListClientMetricsResourcesResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListClientMetricsResourcesResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<ClientMetricsResource> _clientMetricsResourcesCollection = Array.Empty<ClientMetricsResource>();
		/// <summary>
		/// <para>Each client metrics resource in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ClientMetricsResource> ClientMetricsResourcesCollection 
		{
			get => _clientMetricsResourcesCollection;
			private set 
			{
				_clientMetricsResourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each client metrics resource in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListClientMetricsResourcesResponse WithClientMetricsResourcesCollection(params Func<ClientMetricsResource, ClientMetricsResource>[] createFields)
		{
			ClientMetricsResourcesCollection = createFields
				.Select(createField => createField(new ClientMetricsResource(Version)))
				.ToArray();
			return this;
		}

		public delegate ClientMetricsResource CreateClientMetricsResource(ClientMetricsResource field);

		/// <summary>
		/// <para>Each client metrics resource in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListClientMetricsResourcesResponse WithClientMetricsResourcesCollection(IEnumerable<CreateClientMetricsResource> createFields)
		{
			ClientMetricsResourcesCollection = createFields
				.Select(createField => createField(new ClientMetricsResource(Version)))
				.ToArray();
			return this;
		}

		public class ClientMetricsResource : ISerialize
		{
			internal ClientMetricsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ClientMetricsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ClientMetricsResource(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ClientMetricsResource is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ClientMetricsResource WithName(String name)
			{
				Name = name;
				return this;
			}
		}
	}

	public class ListGroupsRequest : Message, IRespond<ListGroupsResponse>
	{
		public ListGroupsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListGroupsRequest does not support version {version}. Valid versions are: 0-6");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(16);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 4 ? 
				_statesFilterCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_typesFilterCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListGroupsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListGroupsRequest(version);
			if (instance.Version >= 4) 
				instance.StatesFilterCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.TypesFilterCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListGroupsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 4)
				await _statesFilterCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _typesFilterCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _statesFilterCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The states of the groups we want to list. If empty, all groups are returned with their state.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Array<String> StatesFilterCollection 
		{
			get => _statesFilterCollection;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"StatesFilterCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_statesFilterCollection = value;
			}
		}

		/// <summary>
		/// <para>The states of the groups we want to list. If empty, all groups are returned with their state.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public ListGroupsRequest WithStatesFilterCollection(Array<String> statesFilterCollection)
		{
			StatesFilterCollection = statesFilterCollection;
			return this;
		}

		private Array<String> _typesFilterCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The types of the groups we want to list. If empty, all groups are returned with their type.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public Array<String> TypesFilterCollection 
		{
			get => _typesFilterCollection;
			private set 
			{
				if (Version >= 5 == false)
					throw new UnsupportedVersionException($"TypesFilterCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

				_typesFilterCollection = value;
			}
		}

		/// <summary>
		/// <para>The types of the groups we want to list. If empty, all groups are returned with their type.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public ListGroupsRequest WithTypesFilterCollection(Array<String> typesFilterCollection)
		{
			TypesFilterCollection = typesFilterCollection;
			return this;
		}

		public ListGroupsResponse Respond()
			=> new ListGroupsResponse(Version);
	}

	public class ListGroupsResponse : Message
	{
		public ListGroupsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListGroupsResponse does not support version {version}. Valid versions are: 0-6");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(16);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_groupsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListGroupsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListGroupsResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GroupsCollection = await Array<ListedGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListedGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListGroupsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ListGroupsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListGroupsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<ListedGroup> _groupsCollection = Array.Empty<ListedGroup>();
		/// <summary>
		/// <para>Each group in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ListedGroup> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each group in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListGroupsResponse WithGroupsCollection(params Func<ListedGroup, ListedGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new ListedGroup(Version)))
				.ToArray();
			return this;
		}

		public delegate ListedGroup CreateListedGroup(ListedGroup field);

		/// <summary>
		/// <para>Each group in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListGroupsResponse WithGroupsCollection(IEnumerable<CreateListedGroup> createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new ListedGroup(Version)))
				.ToArray();
			return this;
		}

		public class ListedGroup : ISerialize
		{
			internal ListedGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_groupId.GetSize(IsFlexibleVersion) +
				_protocolType.GetSize(IsFlexibleVersion) +
				(Version >= 4 ? 
					_groupState.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_groupType.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ListedGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListedGroup(version);
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProtocolType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.GroupState = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.GroupType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListedGroup is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _protocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _groupState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _groupType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListedGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private String _protocolType = String.Default;
			/// <summary>
			/// <para>The group protocol type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ProtocolType 
			{
				get => _protocolType;
				private set 
				{
					_protocolType = value;
				}
			}

			/// <summary>
			/// <para>The group protocol type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListedGroup WithProtocolType(String protocolType)
			{
				ProtocolType = protocolType;
				return this;
			}

			private String _groupState = String.Default;
			/// <summary>
			/// <para>The group state name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String GroupState 
			{
				get => _groupState;
				private set 
				{
					_groupState = value;
				}
			}

			/// <summary>
			/// <para>The group state name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public ListedGroup WithGroupState(String groupState)
			{
				GroupState = groupState;
				return this;
			}

			private String _groupType = String.Default;
			/// <summary>
			/// <para>The group type name.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public String GroupType 
			{
				get => _groupType;
				private set 
				{
					_groupType = value;
				}
			}

			/// <summary>
			/// <para>The group type name.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public ListedGroup WithGroupType(String groupType)
			{
				GroupType = groupType;
				return this;
			}
		}
	}

	public class ListOffsetsRequest : Message, IRespond<ListOffsetsResponse>
	{
		public ListOffsetsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListOffsetsRequest does not support version {version}. Valid versions are: 0-8");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(2);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_replicaId.GetSize(IsFlexibleVersion) +
			(Version >= 2 ? 
				_isolationLevel.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListOffsetsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListOffsetsRequest(version);
			instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.IsolationLevel = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<ListOffsetsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _replicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _isolationLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _replicaId = Int32.Default;
		/// <summary>
		/// <para>The broker ID of the requester, or -1 if this request is being made by a normal consumer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			private set 
			{
				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the requester, or -1 if this request is being made by a normal consumer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Int8 _isolationLevel = Int8.Default;
		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int8 IsolationLevel 
		{
			get => _isolationLevel;
			private set 
			{
				if (Version >= 2 == false)
					throw new UnsupportedVersionException($"IsolationLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");

				_isolationLevel = value;
			}
		}

		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public ListOffsetsRequest WithIsolationLevel(Int8 isolationLevel)
		{
			IsolationLevel = isolationLevel;
			return this;
		}

		private Array<ListOffsetsTopic> _topicsCollection = Array.Empty<ListOffsetsTopic>();
		/// <summary>
		/// <para>Each topic in the request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ListOffsetsTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsRequest WithTopicsCollection(params Func<ListOffsetsTopic, ListOffsetsTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ListOffsetsTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate ListOffsetsTopic CreateListOffsetsTopic(ListOffsetsTopic field);

		/// <summary>
		/// <para>Each topic in the request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsRequest WithTopicsCollection(IEnumerable<CreateListOffsetsTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ListOffsetsTopic(Version)))
				.ToArray();
			return this;
		}

		public class ListOffsetsTopic : ISerialize
		{
			internal ListOffsetsTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ListOffsetsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListOffsetsTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<ListOffsetsPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<ListOffsetsPartition> _partitionsCollection = Array.Empty<ListOffsetsPartition>();
			/// <summary>
			/// <para>Each partition in the request.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<ListOffsetsPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the request.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopic WithPartitionsCollection(params Func<ListOffsetsPartition, ListOffsetsPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ListOffsetsPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate ListOffsetsPartition CreateListOffsetsPartition(ListOffsetsPartition field);

			/// <summary>
			/// <para>Each partition in the request.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopic WithPartitionsCollection(IEnumerable<CreateListOffsetsPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ListOffsetsPartition(Version)))
					.ToArray();
				return this;
			}

			public class ListOffsetsPartition : ISerialize
			{
				internal ListOffsetsPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 6;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					(Version >= 4 ? 
						_currentLeaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					_timestamp.GetSize(IsFlexibleVersion) +
					(Version >= 0 && Version <= 0 ? 
						_maxNumOffsets.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<ListOffsetsPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ListOffsetsPartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 4) 
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Timestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 0) 
						instance.MaxNumOffsets = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 4)
						await _currentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _timestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 0)
						await _maxNumOffsets.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _currentLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The current leader epoch.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					private set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current leader epoch.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartition WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private Int64 _timestamp = Int64.Default;
				/// <summary>
				/// <para>The current timestamp.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Timestamp 
				{
					get => _timestamp;
					private set 
					{
						_timestamp = value;
					}
				}

				/// <summary>
				/// <para>The current timestamp.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartition WithTimestamp(Int64 timestamp)
				{
					Timestamp = timestamp;
					return this;
				}

				private Int32 _maxNumOffsets = new Int32(1);
				/// <summary>
				/// <para>The maximum number of offsets to report.</para>
				/// <para>Versions: 0</para>
				/// <para>Default: 1</para>
				/// </summary>
				public Int32 MaxNumOffsets 
				{
					get => _maxNumOffsets;
					private set 
					{
						if (Version >= 0 && Version <= 0 == false)
							throw new UnsupportedVersionException($"MaxNumOffsets does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

						_maxNumOffsets = value;
					}
				}

				/// <summary>
				/// <para>The maximum number of offsets to report.</para>
				/// <para>Versions: 0</para>
				/// <para>Default: 1</para>
				/// </summary>
				public ListOffsetsPartition WithMaxNumOffsets(Int32 maxNumOffsets)
				{
					MaxNumOffsets = maxNumOffsets;
					return this;
				}
			}
		}

		public ListOffsetsResponse Respond()
			=> new ListOffsetsResponse(Version);
	}

	public class ListOffsetsResponse : Message
	{
		public ListOffsetsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListOffsetsResponse does not support version {version}. Valid versions are: 0-8");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(2);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 2 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListOffsetsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListOffsetsResponse(version);
			if (instance.Version >= 2) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<ListOffsetsTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 2)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public ListOffsetsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<ListOffsetsTopicResponse> _topicsCollection = Array.Empty<ListOffsetsTopicResponse>();
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ListOffsetsTopicResponse> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsResponse WithTopicsCollection(params Func<ListOffsetsTopicResponse, ListOffsetsTopicResponse>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ListOffsetsTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate ListOffsetsTopicResponse CreateListOffsetsTopicResponse(ListOffsetsTopicResponse field);

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsResponse WithTopicsCollection(IEnumerable<CreateListOffsetsTopicResponse> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ListOffsetsTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public class ListOffsetsTopicResponse : ISerialize
		{
			internal ListOffsetsTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ListOffsetsTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListOffsetsTopicResponse(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<ListOffsetsPartitionResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsPartitionResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopicResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<ListOffsetsPartitionResponse> _partitionsCollection = Array.Empty<ListOffsetsPartitionResponse>();
			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<ListOffsetsPartitionResponse> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopicResponse WithPartitionsCollection(params Func<ListOffsetsPartitionResponse, ListOffsetsPartitionResponse>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ListOffsetsPartitionResponse(Version)))
					.ToArray();
				return this;
			}

			public delegate ListOffsetsPartitionResponse CreateListOffsetsPartitionResponse(ListOffsetsPartitionResponse field);

			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopicResponse WithPartitionsCollection(IEnumerable<CreateListOffsetsPartitionResponse> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new ListOffsetsPartitionResponse(Version)))
					.ToArray();
				return this;
			}

			public class ListOffsetsPartitionResponse : ISerialize
			{
				internal ListOffsetsPartitionResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 6;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(Version >= 0 && Version <= 0 ? 
						_oldStyleOffsetsCollection.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 ? 
						_timestamp.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 ? 
						_offset.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 4 ? 
						_leaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<ListOffsetsPartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ListOffsetsPartitionResponse(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 0) 
						instance.OldStyleOffsetsCollection = await Array<Int64>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.Timestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.Offset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 4) 
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsPartitionResponse is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 0)
						await _oldStyleOffsetsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _timestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _offset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 4)
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Array<Int64> _oldStyleOffsetsCollection = Array.Empty<Int64>();
				/// <summary>
				/// <para>The result offsets.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public Array<Int64> OldStyleOffsetsCollection 
				{
					get => _oldStyleOffsetsCollection;
					private set 
					{
						if (Version >= 0 && Version <= 0 == false)
							throw new UnsupportedVersionException($"OldStyleOffsetsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

						_oldStyleOffsetsCollection = value;
					}
				}

				/// <summary>
				/// <para>The result offsets.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithOldStyleOffsetsCollection(Array<Int64> oldStyleOffsetsCollection)
				{
					OldStyleOffsetsCollection = oldStyleOffsetsCollection;
					return this;
				}

				private Int64 _timestamp = new Int64(-1);
				/// <summary>
				/// <para>The timestamp associated with the returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 Timestamp 
				{
					get => _timestamp;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"Timestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_timestamp = value;
					}
				}

				/// <summary>
				/// <para>The timestamp associated with the returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithTimestamp(Int64 timestamp)
				{
					Timestamp = timestamp;
					return this;
				}

				private Int64 _offset = new Int64(-1);
				/// <summary>
				/// <para>The returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 Offset 
				{
					get => _offset;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"Offset does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_offset = value;
					}
				}

				/// <summary>
				/// <para>The returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithOffset(Int64 offset)
				{
					Offset = offset;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						if (Version >= 4 == false)
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}
	}

	public class ListPartitionReassignmentsRequest : Message, IRespond<ListPartitionReassignmentsResponse>
	{
		public ListPartitionReassignmentsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListPartitionReassignmentsRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(46);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_timeoutMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListPartitionReassignmentsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListPartitionReassignmentsRequest(version);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await NullableArray<ListPartitionReassignmentsTopics>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListPartitionReassignmentsTopics.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListPartitionReassignmentsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public ListPartitionReassignmentsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private NullableArray<ListPartitionReassignmentsTopics> _topicsCollection = new NullableArray<ListPartitionReassignmentsTopics>(null);
		/// <summary>
		/// <para>The topics to list partition reassignments for, or null to list everything.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Array<ListPartitionReassignmentsTopics>? TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to list partition reassignments for, or null to list everything.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ListPartitionReassignmentsRequest WithTopicsCollection(params Func<ListPartitionReassignmentsTopics, ListPartitionReassignmentsTopics>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ListPartitionReassignmentsTopics(Version)))
				.ToArray();
			return this;
		}

		public delegate ListPartitionReassignmentsTopics CreateListPartitionReassignmentsTopics(ListPartitionReassignmentsTopics field);

		/// <summary>
		/// <para>The topics to list partition reassignments for, or null to list everything.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ListPartitionReassignmentsRequest WithTopicsCollection(IEnumerable<CreateListPartitionReassignmentsTopics> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ListPartitionReassignmentsTopics(Version)))
				.ToArray();
			return this;
		}

		public class ListPartitionReassignmentsTopics : ISerialize
		{
			internal ListPartitionReassignmentsTopics(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionIndexesCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ListPartitionReassignmentsTopics> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListPartitionReassignmentsTopics(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListPartitionReassignmentsTopics is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndexesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListPartitionReassignmentsTopics WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<Int32> _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions to list partition reassignments for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				private set 
				{
					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to list partition reassignments for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListPartitionReassignmentsTopics WithPartitionIndexesCollection(Array<Int32> partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		public ListPartitionReassignmentsResponse Respond()
			=> new ListPartitionReassignmentsResponse(Version);
	}

	public class ListPartitionReassignmentsResponse : Message
	{
		public ListPartitionReassignmentsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListPartitionReassignmentsResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(46);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListPartitionReassignmentsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListPartitionReassignmentsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<OngoingTopicReassignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OngoingTopicReassignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListPartitionReassignmentsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<OngoingTopicReassignment> _topicsCollection = Array.Empty<OngoingTopicReassignment>();
		/// <summary>
		/// <para>The ongoing reassignments for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<OngoingTopicReassignment> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The ongoing reassignments for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithTopicsCollection(params Func<OngoingTopicReassignment, OngoingTopicReassignment>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OngoingTopicReassignment(Version)))
				.ToArray();
			return this;
		}

		public delegate OngoingTopicReassignment CreateOngoingTopicReassignment(OngoingTopicReassignment field);

		/// <summary>
		/// <para>The ongoing reassignments for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithTopicsCollection(IEnumerable<CreateOngoingTopicReassignment> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OngoingTopicReassignment(Version)))
				.ToArray();
			return this;
		}

		public class OngoingTopicReassignment : ISerialize
		{
			internal OngoingTopicReassignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OngoingTopicReassignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OngoingTopicReassignment(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<OngoingPartitionReassignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OngoingPartitionReassignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OngoingTopicReassignment is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OngoingTopicReassignment WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<OngoingPartitionReassignment> _partitionsCollection = Array.Empty<OngoingPartitionReassignment>();
			/// <summary>
			/// <para>The ongoing reassignments for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<OngoingPartitionReassignment> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The ongoing reassignments for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OngoingTopicReassignment WithPartitionsCollection(params Func<OngoingPartitionReassignment, OngoingPartitionReassignment>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OngoingPartitionReassignment(Version)))
					.ToArray();
				return this;
			}

			public delegate OngoingPartitionReassignment CreateOngoingPartitionReassignment(OngoingPartitionReassignment field);

			/// <summary>
			/// <para>The ongoing reassignments for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OngoingTopicReassignment WithPartitionsCollection(IEnumerable<CreateOngoingPartitionReassignment> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OngoingPartitionReassignment(Version)))
					.ToArray();
				return this;
			}

			public class OngoingPartitionReassignment : ISerialize
			{
				internal OngoingPartitionReassignment(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_replicasCollection.GetSize(IsFlexibleVersion) +
					_addingReplicasCollection.GetSize(IsFlexibleVersion) +
					_removingReplicasCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OngoingPartitionReassignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OngoingPartitionReassignment(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.AddingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.RemovingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OngoingPartitionReassignment is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _replicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _addingReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _removingReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The index of the partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The index of the partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Array<Int32> _replicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The current replica set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> ReplicasCollection 
				{
					get => _replicasCollection;
					private set 
					{
						_replicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The current replica set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithReplicasCollection(Array<Int32> replicasCollection)
				{
					ReplicasCollection = replicasCollection;
					return this;
				}

				private Array<Int32> _addingReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of replicas we are currently adding.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> AddingReplicasCollection 
				{
					get => _addingReplicasCollection;
					private set 
					{
						_addingReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of replicas we are currently adding.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithAddingReplicasCollection(Array<Int32> addingReplicasCollection)
				{
					AddingReplicasCollection = addingReplicasCollection;
					return this;
				}

				private Array<Int32> _removingReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of replicas we are currently removing.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> RemovingReplicasCollection 
				{
					get => _removingReplicasCollection;
					private set 
					{
						_removingReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of replicas we are currently removing.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithRemovingReplicasCollection(Array<Int32> removingReplicasCollection)
				{
					RemovingReplicasCollection = removingReplicasCollection;
					return this;
				}
			}
		}
	}

	public class ListTransactionsRequest : Message, IRespond<ListTransactionsResponse>
	{
		public ListTransactionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListTransactionsRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(66);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_stateFiltersCollection.GetSize(IsFlexibleVersion) +
			_producerIdFiltersCollection.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_durationFilter.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListTransactionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListTransactionsRequest(version);
			instance.StateFiltersCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.ProducerIdFiltersCollection = await Array<Int64>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.DurationFilter = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListTransactionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _stateFiltersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerIdFiltersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _durationFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _stateFiltersCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The transaction states to filter by: if empty, all transactions are returned; if non-empty, then only transactions matching one of the filtered states will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> StateFiltersCollection 
		{
			get => _stateFiltersCollection;
			private set 
			{
				_stateFiltersCollection = value;
			}
		}

		/// <summary>
		/// <para>The transaction states to filter by: if empty, all transactions are returned; if non-empty, then only transactions matching one of the filtered states will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsRequest WithStateFiltersCollection(Array<String> stateFiltersCollection)
		{
			StateFiltersCollection = stateFiltersCollection;
			return this;
		}

		private Array<Int64> _producerIdFiltersCollection = Array.Empty<Int64>();
		/// <summary>
		/// <para>The producerIds to filter by: if empty, all transactions will be returned; if non-empty, only transactions which match one of the filtered producerIds will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<Int64> ProducerIdFiltersCollection 
		{
			get => _producerIdFiltersCollection;
			private set 
			{
				_producerIdFiltersCollection = value;
			}
		}

		/// <summary>
		/// <para>The producerIds to filter by: if empty, all transactions will be returned; if non-empty, only transactions which match one of the filtered producerIds will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsRequest WithProducerIdFiltersCollection(Array<Int64> producerIdFiltersCollection)
		{
			ProducerIdFiltersCollection = producerIdFiltersCollection;
			return this;
		}

		private Int64 _durationFilter = new Int64(-1);
		/// <summary>
		/// <para>Duration (in millis) to filter by: if < 0, all transactions will be returned; otherwise, only transactions running longer than this duration will be returned</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 DurationFilter 
		{
			get => _durationFilter;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"DurationFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_durationFilter = value;
			}
		}

		/// <summary>
		/// <para>Duration (in millis) to filter by: if < 0, all transactions will be returned; otherwise, only transactions running longer than this duration will be returned</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ListTransactionsRequest WithDurationFilter(Int64 durationFilter)
		{
			DurationFilter = durationFilter;
			return this;
		}

		public ListTransactionsResponse Respond()
			=> new ListTransactionsResponse(Version);
	}

	public class ListTransactionsResponse : Message
	{
		public ListTransactionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ListTransactionsResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(66);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_unknownStateFiltersCollection.GetSize(IsFlexibleVersion) +
			_transactionStatesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ListTransactionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListTransactionsResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.UnknownStateFiltersCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.TransactionStatesCollection = await Array<TransactionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TransactionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListTransactionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _unknownStateFiltersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _transactionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<String> _unknownStateFiltersCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Set of state filters provided in the request which were unknown to the transaction coordinator</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> UnknownStateFiltersCollection 
		{
			get => _unknownStateFiltersCollection;
			private set 
			{
				_unknownStateFiltersCollection = value;
			}
		}

		/// <summary>
		/// <para>Set of state filters provided in the request which were unknown to the transaction coordinator</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithUnknownStateFiltersCollection(Array<String> unknownStateFiltersCollection)
		{
			UnknownStateFiltersCollection = unknownStateFiltersCollection;
			return this;
		}

		private Array<TransactionState> _transactionStatesCollection = Array.Empty<TransactionState>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TransactionState> TransactionStatesCollection 
		{
			get => _transactionStatesCollection;
			private set 
			{
				_transactionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithTransactionStatesCollection(params Func<TransactionState, TransactionState>[] createFields)
		{
			TransactionStatesCollection = createFields
				.Select(createField => createField(new TransactionState(Version)))
				.ToArray();
			return this;
		}

		public delegate TransactionState CreateTransactionState(TransactionState field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithTransactionStatesCollection(IEnumerable<CreateTransactionState> createFields)
		{
			TransactionStatesCollection = createFields
				.Select(createField => createField(new TransactionState(Version)))
				.ToArray();
			return this;
		}

		public class TransactionState : ISerialize
		{
			internal TransactionState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_transactionalId.GetSize(IsFlexibleVersion) +
				_producerId.GetSize(IsFlexibleVersion) +
				_transactionState.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TransactionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TransactionState(version);
				instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TransactionState_ = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TransactionState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _transactionState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _transactionalId = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionalId 
			{
				get => _transactionalId;
				private set 
				{
					_transactionalId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionalId(String transactionalId)
			{
				TransactionalId = transactionalId;
				return this;
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				private set 
				{
					_producerId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private String _transactionState = String.Default;
			/// <summary>
			/// <para>The current transaction state of the producer</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionState_ 
			{
				get => _transactionState;
				private set 
				{
					_transactionState = value;
				}
			}

			/// <summary>
			/// <para>The current transaction state of the producer</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionState_(String transactionState)
			{
				TransactionState_ = transactionState;
				return this;
			}
		}
	}

	public class MetadataRequest : Message, IRespond<MetadataResponse>
	{
		public MetadataRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"MetadataRequest does not support version {version}. Valid versions are: 0-12");

			Version = version;
			IsFlexibleVersion = version >= 9;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(3);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(12);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(Version >= 4 ? 
				_allowAutoTopicCreation.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 8 && Version <= 10 ? 
				_includeClusterAuthorizedOperations.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 8 ? 
				_includeTopicAuthorizedOperations.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<MetadataRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new MetadataRequest(version);
			instance.TopicsCollection = await NullableArray<MetadataRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.AllowAutoTopicCreation = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8 && instance.Version <= 10) 
				instance.IncludeClusterAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8) 
				instance.IncludeTopicAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _allowAutoTopicCreation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8 && Version <= 10)
				await _includeClusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8)
				await _includeTopicAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableArray<MetadataRequestTopic> _topicsCollection = Array.Empty<MetadataRequestTopic>();
		/// <summary>
		/// <para>The topics to fetch metadata for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<MetadataRequestTopic>? TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				if (Version >= 1 == false &&
					value == null) 
					throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 1+");

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch metadata for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataRequest WithTopicsCollection(params Func<MetadataRequestTopic, MetadataRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new MetadataRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate MetadataRequestTopic CreateMetadataRequestTopic(MetadataRequestTopic field);

		/// <summary>
		/// <para>The topics to fetch metadata for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataRequest WithTopicsCollection(IEnumerable<CreateMetadataRequestTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new MetadataRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public class MetadataRequestTopic : ISerialize
		{
			internal MetadataRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 9;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 10 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				_name.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<MetadataRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MetadataRequestTopic(version);
				if (instance.Version >= 10) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 10)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public MetadataRequestTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private NullableString _name = NullableString.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 10 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 10+");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataRequestTopic WithName(String? name)
			{
				Name = name;
				return this;
			}
		}

		private Boolean _allowAutoTopicCreation = new Boolean(true);
		/// <summary>
		/// <para>If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: true</para>
		/// </summary>
		public Boolean AllowAutoTopicCreation 
		{
			get => _allowAutoTopicCreation;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"AllowAutoTopicCreation does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_allowAutoTopicCreation = value;
			}
		}

		/// <summary>
		/// <para>If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: true</para>
		/// </summary>
		public MetadataRequest WithAllowAutoTopicCreation(Boolean allowAutoTopicCreation)
		{
			AllowAutoTopicCreation = allowAutoTopicCreation;
			return this;
		}

		private Boolean _includeClusterAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 8-10</para>
		/// </summary>
		public Boolean IncludeClusterAuthorizedOperations 
		{
			get => _includeClusterAuthorizedOperations;
			private set 
			{
				if (Version >= 8 && Version <= 10 == false)
					throw new UnsupportedVersionException($"IncludeClusterAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8-10");

				_includeClusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 8-10</para>
		/// </summary>
		public MetadataRequest WithIncludeClusterAuthorizedOperations(Boolean includeClusterAuthorizedOperations)
		{
			IncludeClusterAuthorizedOperations = includeClusterAuthorizedOperations;
			return this;
		}

		private Boolean _includeTopicAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include topic authorized operations.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public Boolean IncludeTopicAuthorizedOperations 
		{
			get => _includeTopicAuthorizedOperations;
			private set 
			{
				if (Version >= 8 == false)
					throw new UnsupportedVersionException($"IncludeTopicAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

				_includeTopicAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include topic authorized operations.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public MetadataRequest WithIncludeTopicAuthorizedOperations(Boolean includeTopicAuthorizedOperations)
		{
			IncludeTopicAuthorizedOperations = includeTopicAuthorizedOperations;
			return this;
		}

		public MetadataResponse Respond()
			=> new MetadataResponse(Version);
	}

	public class MetadataResponse : Message
	{
		public MetadataResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"MetadataResponse does not support version {version}. Valid versions are: 0-12");

			Version = version;
			IsFlexibleVersion = version >= 9;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(3);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(12);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_brokersCollection.GetSize(IsFlexibleVersion) +
			(Version >= 2 ? 
				_clusterId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 1 ? 
				_controllerId.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(Version >= 8 && Version <= 10 ? 
				_clusterAuthorizedOperations.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<MetadataResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new MetadataResponse(version);
			if (instance.Version >= 3) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.BrokersCollection = await Map<Int32, MetadataResponseBroker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataResponseBroker.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.NodeId, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<NullableString, MetadataResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8 && instance.Version <= 10) 
				instance.ClusterAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _brokersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2)
				await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _controllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8 && Version <= 10)
				await _clusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public MetadataResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<Int32, MetadataResponseBroker> _brokersCollection = Map<Int32, MetadataResponseBroker>.Default;
		/// <summary>
		/// <para>A list of brokers present in the cluster.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int32, MetadataResponseBroker> BrokersCollection 
		{
			get => _brokersCollection;
			private set 
			{
				_brokersCollection = value;
			}
		}

		/// <summary>
		/// <para>A list of brokers present in the cluster.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataResponse WithBrokersCollection(params Func<MetadataResponseBroker, MetadataResponseBroker>[] createFields)
		{
			BrokersCollection = createFields
				.Select(createField => createField(new MetadataResponseBroker(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public delegate MetadataResponseBroker CreateMetadataResponseBroker(MetadataResponseBroker field);

		/// <summary>
		/// <para>A list of brokers present in the cluster.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataResponse WithBrokersCollection(IEnumerable<CreateMetadataResponseBroker> createFields)
		{
			BrokersCollection = createFields
				.Select(createField => createField(new MetadataResponseBroker(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public class MetadataResponseBroker : ISerialize
		{
			internal MetadataResponseBroker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 9;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_nodeId.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				(Version >= 1 ? 
					_rack.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<MetadataResponseBroker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MetadataResponseBroker(version);
				instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponseBroker is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseBroker WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseBroker WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseBroker WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private NullableString _rack = new NullableString(null);
			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					if (Version >= 1 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 1+");

					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: null</para>
			/// </summary>
			public MetadataResponseBroker WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}

		private NullableString _clusterId = new NullableString(null);
		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			private set 
			{
				if (Version >= 2 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 2+");

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: null</para>
		/// </summary>
		public MetadataResponse WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _controllerId = new Int32(-1);
		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			private set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public MetadataResponse WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Map<NullableString, MetadataResponseTopic> _topicsCollection = Map<NullableString, MetadataResponseTopic>.Default;
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<NullableString, MetadataResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataResponse WithTopicsCollection(params Func<MetadataResponseTopic, MetadataResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new MetadataResponseTopic(Version)))
				.ToDictionary(field => (NullableString)field.Name);
			return this;
		}

		public delegate MetadataResponseTopic CreateMetadataResponseTopic(MetadataResponseTopic field);

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataResponse WithTopicsCollection(IEnumerable<CreateMetadataResponseTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new MetadataResponseTopic(Version)))
				.ToDictionary(field => (NullableString)field.Name);
			return this;
		}

		public class MetadataResponseTopic : ISerialize
		{
			internal MetadataResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 9;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_name.GetSize(IsFlexibleVersion) +
				(Version >= 10 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 ? 
					_isInternal.GetSize(IsFlexibleVersion):
					0) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(Version >= 8 ? 
					_topicAuthorizedOperations.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<MetadataResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MetadataResponseTopic(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 10) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.IsInternal = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<MetadataResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 8) 
					instance.TopicAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 10)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _isInternal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 8)
					await _topicAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The topic error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The topic error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _name = NullableString.Default;
			/// <summary>
			/// <para>The topic name. Null for non-existing topics queried by ID. This is never null when ErrorCode is zero. One of Name and TopicId is always populated.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 12 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 12+");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name. Null for non-existing topics queried by ID. This is never null when ErrorCode is zero. One of Name and TopicId is always populated.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id. Zero for non-existing topics queried by name. This is never zero when ErrorCode is zero. One of Name and TopicId is always populated.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id. Zero for non-existing topics queried by name. This is never zero when ErrorCode is zero. One of Name and TopicId is always populated.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public MetadataResponseTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Boolean _isInternal = new Boolean(false);
			/// <summary>
			/// <para>True if the topic is internal.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public Boolean IsInternal 
			{
				get => _isInternal;
				private set 
				{
					_isInternal = value;
				}
			}

			/// <summary>
			/// <para>True if the topic is internal.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public MetadataResponseTopic WithIsInternal(Boolean isInternal)
			{
				IsInternal = isInternal;
				return this;
			}

			private Array<MetadataResponsePartition> _partitionsCollection = Array.Empty<MetadataResponsePartition>();
			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<MetadataResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithPartitionsCollection(params Func<MetadataResponsePartition, MetadataResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new MetadataResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate MetadataResponsePartition CreateMetadataResponsePartition(MetadataResponsePartition field);

			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithPartitionsCollection(IEnumerable<CreateMetadataResponsePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new MetadataResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public class MetadataResponsePartition : ISerialize
			{
				internal MetadataResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 9;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_errorCode.GetSize(IsFlexibleVersion) +
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					(Version >= 7 ? 
						_leaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					_replicaNodesCollection.GetSize(IsFlexibleVersion) +
					_isrNodesCollection.GetSize(IsFlexibleVersion) +
					(Version >= 5 ? 
						_offlineReplicasCollection.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<MetadataResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new MetadataResponsePartition(version);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 7) 
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ReplicaNodesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.IsrNodesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.OfflineReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 7)
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _replicaNodesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _isrNodesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _offlineReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the leader broker.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the leader broker.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 7+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 7+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public MetadataResponsePartition WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Array<Int32> _replicaNodesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of all nodes that host this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> ReplicaNodesCollection 
				{
					get => _replicaNodesCollection;
					private set 
					{
						_replicaNodesCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of all nodes that host this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithReplicaNodesCollection(Array<Int32> replicaNodesCollection)
				{
					ReplicaNodesCollection = replicaNodesCollection;
					return this;
				}

				private Array<Int32> _isrNodesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of nodes that are in sync with the leader for this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> IsrNodesCollection 
				{
					get => _isrNodesCollection;
					private set 
					{
						_isrNodesCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of nodes that are in sync with the leader for this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithIsrNodesCollection(Array<Int32> isrNodesCollection)
				{
					IsrNodesCollection = isrNodesCollection;
					return this;
				}

				private Array<Int32> _offlineReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of offline replicas of this partition.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public Array<Int32> OfflineReplicasCollection 
				{
					get => _offlineReplicasCollection;
					private set 
					{
						_offlineReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of offline replicas of this partition.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public MetadataResponsePartition WithOfflineReplicasCollection(Array<Int32> offlineReplicasCollection)
				{
					OfflineReplicasCollection = offlineReplicasCollection;
					return this;
				}
			}

			private Int32 _topicAuthorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this topic.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 TopicAuthorizedOperations 
			{
				get => _topicAuthorizedOperations;
				private set 
				{
					if (Version >= 8 == false)
						throw new UnsupportedVersionException($"TopicAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

					_topicAuthorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this topic.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public MetadataResponseTopic WithTopicAuthorizedOperations(Int32 topicAuthorizedOperations)
			{
				TopicAuthorizedOperations = topicAuthorizedOperations;
				return this;
			}
		}

		private Int32 _clusterAuthorizedOperations = new Int32(-2147483648);
		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 8-10</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public Int32 ClusterAuthorizedOperations 
		{
			get => _clusterAuthorizedOperations;
			private set 
			{
				if (Version >= 8 && Version <= 10 == false)
					throw new UnsupportedVersionException($"ClusterAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8-10");

				_clusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 8-10</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public MetadataResponse WithClusterAuthorizedOperations(Int32 clusterAuthorizedOperations)
		{
			ClusterAuthorizedOperations = clusterAuthorizedOperations;
			return this;
		}
	}

	public class OffsetCommitRequest : Message, IRespond<OffsetCommitResponse>
	{
		public OffsetCommitRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetCommitRequest does not support version {version}. Valid versions are: 0-9");

			Version = version;
			IsFlexibleVersion = version >= 8;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(8);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_generationIdOrMemberEpoch.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 1 ? 
				_memberId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 7 ? 
				_groupInstanceId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 2 && Version <= 4 ? 
				_retentionTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetCommitRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetCommitRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.GenerationIdOrMemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2 && instance.Version <= 4) 
				instance.RetentionTimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<OffsetCommitRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _generationIdOrMemberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2 && Version <= 4)
				await _retentionTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _generationIdOrMemberEpoch = new Int32(-1);
		/// <summary>
		/// <para>The generation of the group if using the classic group protocol or the member epoch if using the consumer protocol.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationIdOrMemberEpoch 
		{
			get => _generationIdOrMemberEpoch;
			private set 
			{
				_generationIdOrMemberEpoch = value;
			}
		}

		/// <summary>
		/// <para>The generation of the group if using the classic group protocol or the member epoch if using the consumer protocol.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public OffsetCommitRequest WithGenerationIdOrMemberEpoch(Int32 generationIdOrMemberEpoch)
		{
			GenerationIdOrMemberEpoch = generationIdOrMemberEpoch;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public OffsetCommitRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private NullableString _groupInstanceId = new NullableString(null);
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			private set 
			{
				if (Version >= 7 == false)
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");

				if (Version >= 7 == false &&
					value == null) 
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 7+");

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public OffsetCommitRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private Int64 _retentionTimeMs = new Int64(-1);
		/// <summary>
		/// <para>The time period in ms to retain the offset.</para>
		/// <para>Versions: 2-4</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 RetentionTimeMs 
		{
			get => _retentionTimeMs;
			private set 
			{
				_retentionTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The time period in ms to retain the offset.</para>
		/// <para>Versions: 2-4</para>
		/// <para>Default: -1</para>
		/// </summary>
		public OffsetCommitRequest WithRetentionTimeMs(Int64 retentionTimeMs)
		{
			RetentionTimeMs = retentionTimeMs;
			return this;
		}

		private Array<OffsetCommitRequestTopic> _topicsCollection = Array.Empty<OffsetCommitRequestTopic>();
		/// <summary>
		/// <para>The topics to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<OffsetCommitRequestTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitRequest WithTopicsCollection(params Func<OffsetCommitRequestTopic, OffsetCommitRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetCommitRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate OffsetCommitRequestTopic CreateOffsetCommitRequestTopic(OffsetCommitRequestTopic field);

		/// <summary>
		/// <para>The topics to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitRequest WithTopicsCollection(IEnumerable<CreateOffsetCommitRequestTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetCommitRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public class OffsetCommitRequestTopic : ISerialize
		{
			internal OffsetCommitRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 8;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetCommitRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetCommitRequestTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<OffsetCommitRequestPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitRequestPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<OffsetCommitRequestPartition> _partitionsCollection = Array.Empty<OffsetCommitRequestPartition>();
			/// <summary>
			/// <para>Each partition to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<OffsetCommitRequestPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitRequestTopic WithPartitionsCollection(params Func<OffsetCommitRequestPartition, OffsetCommitRequestPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetCommitRequestPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetCommitRequestPartition CreateOffsetCommitRequestPartition(OffsetCommitRequestPartition field);

			/// <summary>
			/// <para>Each partition to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitRequestTopic WithPartitionsCollection(IEnumerable<CreateOffsetCommitRequestPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetCommitRequestPartition(Version)))
					.ToArray();
				return this;
			}

			public class OffsetCommitRequestPartition : ISerialize
			{
				internal OffsetCommitRequestPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 8;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_committedOffset.GetSize(IsFlexibleVersion) +
					(Version >= 6 ? 
						_committedLeaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 && Version <= 1 ? 
						_commitTimestamp.GetSize(IsFlexibleVersion):
						0) +
					_committedMetadata.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetCommitRequestPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetCommitRequestPartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 6) 
						instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1 && instance.Version <= 1) 
						instance.CommitTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CommittedMetadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitRequestPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _committedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 6)
						await _committedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1 && Version <= 1)
						await _commitTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _committedMetadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitRequestPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _committedOffset = Int64.Default;
				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 CommittedOffset 
				{
					get => _committedOffset;
					private set 
					{
						_committedOffset = value;
					}
				}

				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommittedOffset(Int64 committedOffset)
				{
					CommittedOffset = committedOffset;
					return this;
				}

				private Int32 _committedLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 6+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CommittedLeaderEpoch 
				{
					get => _committedLeaderEpoch;
					private set 
					{
						_committedLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 6+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
				{
					CommittedLeaderEpoch = committedLeaderEpoch;
					return this;
				}

				private Int64 _commitTimestamp = new Int64(-1);
				/// <summary>
				/// <para>The timestamp of the commit.</para>
				/// <para>Versions: 1</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 CommitTimestamp 
				{
					get => _commitTimestamp;
					private set 
					{
						if (Version >= 1 && Version <= 1 == false)
							throw new UnsupportedVersionException($"CommitTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 1");

						_commitTimestamp = value;
					}
				}

				/// <summary>
				/// <para>The timestamp of the commit.</para>
				/// <para>Versions: 1</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommitTimestamp(Int64 commitTimestamp)
				{
					CommitTimestamp = commitTimestamp;
					return this;
				}

				private NullableString _committedMetadata = NullableString.Default;
				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? CommittedMetadata 
				{
					get => _committedMetadata;
					private set 
					{
						_committedMetadata = value;
					}
				}

				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommittedMetadata(String? committedMetadata)
				{
					CommittedMetadata = committedMetadata;
					return this;
				}
			}
		}

		public OffsetCommitResponse Respond()
			=> new OffsetCommitResponse(Version);
	}

	public class OffsetCommitResponse : Message
	{
		public OffsetCommitResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetCommitResponse does not support version {version}. Valid versions are: 0-9");

			Version = version;
			IsFlexibleVersion = version >= 8;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(8);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetCommitResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetCommitResponse(version);
			if (instance.Version >= 3) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<OffsetCommitResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public OffsetCommitResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<OffsetCommitResponseTopic> _topicsCollection = Array.Empty<OffsetCommitResponseTopic>();
		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<OffsetCommitResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitResponse WithTopicsCollection(params Func<OffsetCommitResponseTopic, OffsetCommitResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetCommitResponseTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate OffsetCommitResponseTopic CreateOffsetCommitResponseTopic(OffsetCommitResponseTopic field);

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitResponse WithTopicsCollection(IEnumerable<CreateOffsetCommitResponseTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetCommitResponseTopic(Version)))
				.ToArray();
			return this;
		}

		public class OffsetCommitResponseTopic : ISerialize
		{
			internal OffsetCommitResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 8;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetCommitResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetCommitResponseTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<OffsetCommitResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<OffsetCommitResponsePartition> _partitionsCollection = Array.Empty<OffsetCommitResponsePartition>();
			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<OffsetCommitResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitResponseTopic WithPartitionsCollection(params Func<OffsetCommitResponsePartition, OffsetCommitResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetCommitResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetCommitResponsePartition CreateOffsetCommitResponsePartition(OffsetCommitResponsePartition field);

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitResponseTopic WithPartitionsCollection(IEnumerable<CreateOffsetCommitResponsePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetCommitResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public class OffsetCommitResponsePartition : ISerialize
			{
				internal OffsetCommitResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 8;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetCommitResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetCommitResponsePartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class OffsetDeleteRequest : Message, IRespond<OffsetDeleteResponse>
	{
		public OffsetDeleteRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetDeleteRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(47);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetDeleteRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetDeleteRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<String, OffsetDeleteRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Map<String, OffsetDeleteRequestTopic> _topicsCollection = Map<String, OffsetDeleteRequestTopic>.Default;
		/// <summary>
		/// <para>The topics to delete offsets for</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, OffsetDeleteRequestTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to delete offsets for</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteRequest WithTopicsCollection(params Func<OffsetDeleteRequestTopic, OffsetDeleteRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetDeleteRequestTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate OffsetDeleteRequestTopic CreateOffsetDeleteRequestTopic(OffsetDeleteRequestTopic field);

		/// <summary>
		/// <para>The topics to delete offsets for</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteRequest WithTopicsCollection(IEnumerable<CreateOffsetDeleteRequestTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetDeleteRequestTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class OffsetDeleteRequestTopic : ISerialize
		{
			internal OffsetDeleteRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetDeleteRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetDeleteRequestTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<OffsetDeleteRequestPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteRequestPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<OffsetDeleteRequestPartition> _partitionsCollection = Array.Empty<OffsetDeleteRequestPartition>();
			/// <summary>
			/// <para>Each partition to delete offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<OffsetDeleteRequestPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to delete offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteRequestTopic WithPartitionsCollection(params Func<OffsetDeleteRequestPartition, OffsetDeleteRequestPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetDeleteRequestPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetDeleteRequestPartition CreateOffsetDeleteRequestPartition(OffsetDeleteRequestPartition field);

			/// <summary>
			/// <para>Each partition to delete offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteRequestTopic WithPartitionsCollection(IEnumerable<CreateOffsetDeleteRequestPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetDeleteRequestPartition(Version)))
					.ToArray();
				return this;
			}

			public class OffsetDeleteRequestPartition : ISerialize
			{
				internal OffsetDeleteRequestPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = false;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetDeleteRequestPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetDeleteRequestPartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteRequestPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetDeleteRequestPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}
			}
		}

		public OffsetDeleteResponse Respond()
			=> new OffsetDeleteResponse(Version);
	}

	public class OffsetDeleteResponse : Message
	{
		public OffsetDeleteResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetDeleteResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(47);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetDeleteResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetDeleteResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<String, OffsetDeleteResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<String, OffsetDeleteResponseTopic> _topicsCollection = Map<String, OffsetDeleteResponseTopic>.Default;
		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, OffsetDeleteResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithTopicsCollection(params Func<OffsetDeleteResponseTopic, OffsetDeleteResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetDeleteResponseTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate OffsetDeleteResponseTopic CreateOffsetDeleteResponseTopic(OffsetDeleteResponseTopic field);

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithTopicsCollection(IEnumerable<CreateOffsetDeleteResponseTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetDeleteResponseTopic(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class OffsetDeleteResponseTopic : ISerialize
		{
			internal OffsetDeleteResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetDeleteResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetDeleteResponseTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Map<Int32, OffsetDeleteResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.PartitionIndex, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Map<Int32, OffsetDeleteResponsePartition> _partitionsCollection = Map<Int32, OffsetDeleteResponsePartition>.Default;
			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<Int32, OffsetDeleteResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteResponseTopic WithPartitionsCollection(params Func<OffsetDeleteResponsePartition, OffsetDeleteResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetDeleteResponsePartition(Version)))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			public delegate OffsetDeleteResponsePartition CreateOffsetDeleteResponsePartition(OffsetDeleteResponsePartition field);

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteResponseTopic WithPartitionsCollection(IEnumerable<CreateOffsetDeleteResponsePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetDeleteResponsePartition(Version)))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			public class OffsetDeleteResponsePartition : ISerialize
			{
				internal OffsetDeleteResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = false;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetDeleteResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetDeleteResponsePartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetDeleteResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetDeleteResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class OffsetFetchRequest : Message, IRespond<OffsetFetchResponse>
	{
		public OffsetFetchRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetFetchRequest does not support version {version}. Valid versions are: 0-9");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(9);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 0 && Version <= 7 ? 
				_groupId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 7 ? 
				_topicsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 8 ? 
				_groupsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 7 ? 
				_requireStable.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetFetchRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetFetchRequest(version);
			if (instance.Version >= 0 && instance.Version <= 7) 
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 7) 
				instance.TopicsCollection = await NullableArray<OffsetFetchRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8) 
				instance.GroupsCollection = await Array<OffsetFetchRequestGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchRequestGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 7) 
				instance.RequireStable = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 0 && Version <= 7)
				await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 7)
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8)
				await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 7)
				await _requireStable.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group to fetch offsets for.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				if (Version >= 0 && Version <= 7 == false)
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group to fetch offsets for.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private NullableArray<OffsetFetchRequestTopic> _topicsCollection = Array.Empty<OffsetFetchRequestTopic>();
		/// <summary>
		/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public Array<OffsetFetchRequestTopic>? TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				if (Version >= 0 && Version <= 7 == false)
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

				if (Version >= 2 && Version <= 7 == false &&
					value == null) 
					throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 2-7");

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchRequest WithTopicsCollection(params Func<OffsetFetchRequestTopic, OffsetFetchRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetFetchRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate OffsetFetchRequestTopic CreateOffsetFetchRequestTopic(OffsetFetchRequestTopic field);

		/// <summary>
		/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchRequest WithTopicsCollection(IEnumerable<CreateOffsetFetchRequestTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetFetchRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public class OffsetFetchRequestTopic : ISerialize
		{
			internal OffsetFetchRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 7 ? 
					_name.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 0 && Version <= 7 ? 
					_partitionIndexesCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetFetchRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchRequestTopic(version);
				if (instance.Version >= 0 && instance.Version <= 7) 
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 0 && instance.Version <= 7) 
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 7)
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 0 && Version <= 7)
					await _partitionIndexesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 0 && Version <= 7 == false)
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<Int32> _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes we would like to fetch offsets for.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public Array<Int32> PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				private set 
				{
					if (Version >= 0 && Version <= 7 == false)
						throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes we would like to fetch offsets for.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchRequestTopic WithPartitionIndexesCollection(Array<Int32> partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		private Array<OffsetFetchRequestGroup> _groupsCollection = Array.Empty<OffsetFetchRequestGroup>();
		/// <summary>
		/// <para>Each group we would like to fetch offsets for</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public Array<OffsetFetchRequestGroup> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				if (Version >= 8 == false)
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each group we would like to fetch offsets for</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchRequest WithGroupsCollection(params Func<OffsetFetchRequestGroup, OffsetFetchRequestGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new OffsetFetchRequestGroup(Version)))
				.ToArray();
			return this;
		}

		public delegate OffsetFetchRequestGroup CreateOffsetFetchRequestGroup(OffsetFetchRequestGroup field);

		/// <summary>
		/// <para>Each group we would like to fetch offsets for</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchRequest WithGroupsCollection(IEnumerable<CreateOffsetFetchRequestGroup> createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new OffsetFetchRequestGroup(Version)))
				.ToArray();
			return this;
		}

		public class OffsetFetchRequestGroup : ISerialize
		{
			internal OffsetFetchRequestGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 8 ? 
					_groupId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 9 ? 
					_memberId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 9 ? 
					_memberEpoch.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 8 ? 
					_topicsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetFetchRequestGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchRequestGroup(version);
				if (instance.Version >= 8) 
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 9) 
					instance.MemberId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 9) 
					instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 8) 
					instance.TopicsCollection = await NullableArray<OffsetFetchRequestTopics>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchRequestTopics.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequestGroup is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 8)
					await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 9)
					await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 9)
					await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 8)
					await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					if (Version >= 8 == false)
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchRequestGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private NullableString _memberId = new NullableString(null);
			/// <summary>
			/// <para>The member ID assigned by the group coordinator if using the new consumer protocol (KIP-848).</para>
			/// <para>Versions: 9+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? MemberId 
			{
				get => _memberId;
				private set 
				{
					if (Version >= 9 == false &&
						value == null) 
						throw new UnsupportedVersionException($"MemberId does not support null for version {Version}. Supported versions for null value: 9+");

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The member ID assigned by the group coordinator if using the new consumer protocol (KIP-848).</para>
			/// <para>Versions: 9+</para>
			/// <para>Default: null</para>
			/// </summary>
			public OffsetFetchRequestGroup WithMemberId(String? memberId)
			{
				MemberId = memberId;
				return this;
			}

			private Int32 _memberEpoch = new Int32(-1);
			/// <summary>
			/// <para>The member epoch if using the new consumer protocol (KIP-848).</para>
			/// <para>Versions: 9+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int32 MemberEpoch 
			{
				get => _memberEpoch;
				private set 
				{
					_memberEpoch = value;
				}
			}

			/// <summary>
			/// <para>The member epoch if using the new consumer protocol (KIP-848).</para>
			/// <para>Versions: 9+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public OffsetFetchRequestGroup WithMemberEpoch(Int32 memberEpoch)
			{
				MemberEpoch = memberEpoch;
				return this;
			}

			private NullableArray<OffsetFetchRequestTopics> _topicsCollection = Array.Empty<OffsetFetchRequestTopics>();
			/// <summary>
			/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public Array<OffsetFetchRequestTopics>? TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					if (Version >= 8 == false)
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

					if (Version >= 8 == false &&
						value == null) 
						throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 8+");

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchRequestGroup WithTopicsCollection(params Func<OffsetFetchRequestTopics, OffsetFetchRequestTopics>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new OffsetFetchRequestTopics(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetFetchRequestTopics CreateOffsetFetchRequestTopics(OffsetFetchRequestTopics field);

			/// <summary>
			/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchRequestGroup WithTopicsCollection(IEnumerable<CreateOffsetFetchRequestTopics> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new OffsetFetchRequestTopics(Version)))
					.ToArray();
				return this;
			}

			public class OffsetFetchRequestTopics : ISerialize
			{
				internal OffsetFetchRequestTopics(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 6;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 8 ? 
						_name.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 8 ? 
						_partitionIndexesCollection.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetFetchRequestTopics> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetFetchRequestTopics(version);
					if (instance.Version >= 8) 
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 8) 
						instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequestTopics is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 8)
						await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 8)
						await _partitionIndexesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						if (Version >= 8 == false)
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchRequestTopics WithName(String name)
				{
					Name = name;
					return this;
				}

				private Array<Int32> _partitionIndexesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The partition indexes we would like to fetch offsets for.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public Array<Int32> PartitionIndexesCollection 
				{
					get => _partitionIndexesCollection;
					private set 
					{
						if (Version >= 8 == false)
							throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

						_partitionIndexesCollection = value;
					}
				}

				/// <summary>
				/// <para>The partition indexes we would like to fetch offsets for.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchRequestTopics WithPartitionIndexesCollection(Array<Int32> partitionIndexesCollection)
				{
					PartitionIndexesCollection = partitionIndexesCollection;
					return this;
				}
			}
		}

		private Boolean _requireStable = new Boolean(false);
		/// <summary>
		/// <para>Whether broker should hold on returning unstable offsets but set a retriable error code for the partitions.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean RequireStable 
		{
			get => _requireStable;
			private set 
			{
				if (Version >= 7 == false)
					throw new UnsupportedVersionException($"RequireStable does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");

				_requireStable = value;
			}
		}

		/// <summary>
		/// <para>Whether broker should hold on returning unstable offsets but set a retriable error code for the partitions.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: false</para>
		/// </summary>
		public OffsetFetchRequest WithRequireStable(Boolean requireStable)
		{
			RequireStable = requireStable;
			return this;
		}

		public OffsetFetchResponse Respond()
			=> new OffsetFetchResponse(Version);
	}

	public class OffsetFetchResponse : Message
	{
		public OffsetFetchResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetFetchResponse does not support version {version}. Valid versions are: 0-9");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(9);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 7 ? 
				_topicsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 2 && Version <= 7 ? 
				_errorCode.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 8 ? 
				_groupsCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetFetchResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetFetchResponse(version);
			if (instance.Version >= 3) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 7) 
				instance.TopicsCollection = await Array<OffsetFetchResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2 && instance.Version <= 7) 
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8) 
				instance.GroupsCollection = await Array<OffsetFetchResponseGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponseGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 7)
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 2 && Version <= 7)
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8)
				await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public OffsetFetchResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<OffsetFetchResponseTopic> _topicsCollection = Array.Empty<OffsetFetchResponseTopic>();
		/// <summary>
		/// <para>The responses per topic.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public Array<OffsetFetchResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				if (Version >= 0 && Version <= 7 == false)
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses per topic.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchResponse WithTopicsCollection(params Func<OffsetFetchResponseTopic, OffsetFetchResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetFetchResponseTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate OffsetFetchResponseTopic CreateOffsetFetchResponseTopic(OffsetFetchResponseTopic field);

		/// <summary>
		/// <para>The responses per topic.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchResponse WithTopicsCollection(IEnumerable<CreateOffsetFetchResponseTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetFetchResponseTopic(Version)))
				.ToArray();
			return this;
		}

		public class OffsetFetchResponseTopic : ISerialize
		{
			internal OffsetFetchResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 7 ? 
					_name.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 0 && Version <= 7 ? 
					_partitionsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetFetchResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchResponseTopic(version);
				if (instance.Version >= 0 && instance.Version <= 7) 
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 0 && instance.Version <= 7) 
					instance.PartitionsCollection = await Array<OffsetFetchResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 7)
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 0 && Version <= 7)
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 0 && Version <= 7 == false)
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<OffsetFetchResponsePartition> _partitionsCollection = Array.Empty<OffsetFetchResponsePartition>();
			/// <summary>
			/// <para>The responses per partition</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public Array<OffsetFetchResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					if (Version >= 0 && Version <= 7 == false)
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses per partition</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchResponseTopic WithPartitionsCollection(params Func<OffsetFetchResponsePartition, OffsetFetchResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetFetchResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetFetchResponsePartition CreateOffsetFetchResponsePartition(OffsetFetchResponsePartition field);

			/// <summary>
			/// <para>The responses per partition</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchResponseTopic WithPartitionsCollection(IEnumerable<CreateOffsetFetchResponsePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetFetchResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public class OffsetFetchResponsePartition : ISerialize
			{
				internal OffsetFetchResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 6;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 0 && Version <= 7 ? 
						_partitionIndex.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 0 && Version <= 7 ? 
						_committedOffset.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 && Version <= 7 ? 
						_committedLeaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 0 && Version <= 7 ? 
						_metadata.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 0 && Version <= 7 ? 
						_errorCode.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetFetchResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetFetchResponsePartition(version);
					if (instance.Version >= 0 && instance.Version <= 7) 
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 7) 
						instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5 && instance.Version <= 7) 
						instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 7) 
						instance.Metadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 0 && instance.Version <= 7) 
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 0 && Version <= 7)
						await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 7)
						await _committedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5 && Version <= 7)
						await _committedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 7)
						await _metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 0 && Version <= 7)
						await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						if (Version >= 0 && Version <= 7 == false)
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _committedOffset = Int64.Default;
				/// <summary>
				/// <para>The committed message offset.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public Int64 CommittedOffset 
				{
					get => _committedOffset;
					private set 
					{
						if (Version >= 0 && Version <= 7 == false)
							throw new UnsupportedVersionException($"CommittedOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

						_committedOffset = value;
					}
				}

				/// <summary>
				/// <para>The committed message offset.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithCommittedOffset(Int64 committedOffset)
				{
					CommittedOffset = committedOffset;
					return this;
				}

				private Int32 _committedLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 5-7</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CommittedLeaderEpoch 
				{
					get => _committedLeaderEpoch;
					private set 
					{
						_committedLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 5-7</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetFetchResponsePartition WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
				{
					CommittedLeaderEpoch = committedLeaderEpoch;
					return this;
				}

				private NullableString _metadata = NullableString.Default;
				/// <summary>
				/// <para>The partition metadata.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public String? Metadata 
				{
					get => _metadata;
					private set 
					{
						if (Version >= 0 && Version <= 7 == false)
							throw new UnsupportedVersionException($"Metadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

						if (Version >= 0 && Version <= 7 == false &&
							value == null) 
							throw new UnsupportedVersionException($"Metadata does not support null for version {Version}. Supported versions for null value: 0-7");

						_metadata = value;
					}
				}

				/// <summary>
				/// <para>The partition metadata.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithMetadata(String? metadata)
				{
					Metadata = metadata;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						if (Version >= 0 && Version <= 7 == false)
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}

		private Int16 _errorCode = new Int16(0);
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 2-7</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 2-7</para>
		/// <para>Default: 0</para>
		/// </summary>
		public OffsetFetchResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<OffsetFetchResponseGroup> _groupsCollection = Array.Empty<OffsetFetchResponseGroup>();
		/// <summary>
		/// <para>The responses per group id.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public Array<OffsetFetchResponseGroup> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				if (Version >= 8 == false)
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses per group id.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchResponse WithGroupsCollection(params Func<OffsetFetchResponseGroup, OffsetFetchResponseGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new OffsetFetchResponseGroup(Version)))
				.ToArray();
			return this;
		}

		public delegate OffsetFetchResponseGroup CreateOffsetFetchResponseGroup(OffsetFetchResponseGroup field);

		/// <summary>
		/// <para>The responses per group id.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchResponse WithGroupsCollection(IEnumerable<CreateOffsetFetchResponseGroup> createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new OffsetFetchResponseGroup(Version)))
				.ToArray();
			return this;
		}

		public class OffsetFetchResponseGroup : ISerialize
		{
			internal OffsetFetchResponseGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 8 ? 
					_groupId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 8 ? 
					_topicsCollection.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 8 ? 
					_errorCode.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetFetchResponseGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchResponseGroup(version);
				if (instance.Version >= 8) 
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 8) 
					instance.TopicsCollection = await Array<OffsetFetchResponseTopics>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponseTopics.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 8) 
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponseGroup is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 8)
					await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 8)
					await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 8)
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					if (Version >= 8 == false)
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchResponseGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private Array<OffsetFetchResponseTopics> _topicsCollection = Array.Empty<OffsetFetchResponseTopics>();
			/// <summary>
			/// <para>The responses per topic.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public Array<OffsetFetchResponseTopics> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					if (Version >= 8 == false)
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses per topic.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchResponseGroup WithTopicsCollection(params Func<OffsetFetchResponseTopics, OffsetFetchResponseTopics>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new OffsetFetchResponseTopics(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetFetchResponseTopics CreateOffsetFetchResponseTopics(OffsetFetchResponseTopics field);

			/// <summary>
			/// <para>The responses per topic.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchResponseGroup WithTopicsCollection(IEnumerable<CreateOffsetFetchResponseTopics> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new OffsetFetchResponseTopics(Version)))
					.ToArray();
				return this;
			}

			public class OffsetFetchResponseTopics : ISerialize
			{
				internal OffsetFetchResponseTopics(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 6;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 8 ? 
						_name.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 8 ? 
						_partitionsCollection.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetFetchResponseTopics> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetFetchResponseTopics(version);
					if (instance.Version >= 8) 
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 8) 
						instance.PartitionsCollection = await Array<OffsetFetchResponsePartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponsePartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponseTopics is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 8)
						await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 8)
						await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						if (Version >= 8 == false)
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchResponseTopics WithName(String name)
				{
					Name = name;
					return this;
				}

				private Array<OffsetFetchResponsePartitions> _partitionsCollection = Array.Empty<OffsetFetchResponsePartitions>();
				/// <summary>
				/// <para>The responses per partition</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public Array<OffsetFetchResponsePartitions> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						if (Version >= 8 == false)
							throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The responses per partition</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchResponseTopics WithPartitionsCollection(params Func<OffsetFetchResponsePartitions, OffsetFetchResponsePartitions>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new OffsetFetchResponsePartitions(Version)))
						.ToArray();
					return this;
				}

				public delegate OffsetFetchResponsePartitions CreateOffsetFetchResponsePartitions(OffsetFetchResponsePartitions field);

				/// <summary>
				/// <para>The responses per partition</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchResponseTopics WithPartitionsCollection(IEnumerable<CreateOffsetFetchResponsePartitions> createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new OffsetFetchResponsePartitions(Version)))
						.ToArray();
					return this;
				}

				public class OffsetFetchResponsePartitions : ISerialize
				{
					internal OffsetFetchResponsePartitions(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 6;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 8 ? 
							_partitionIndex.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 8 ? 
							_committedOffset.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 8 ? 
							_committedLeaderEpoch.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 8 ? 
							_metadata.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 8 ? 
							_errorCode.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<OffsetFetchResponsePartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new OffsetFetchResponsePartitions(version);
						if (instance.Version >= 8) 
							instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 8) 
							instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 8) 
							instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 8) 
							instance.Metadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 8) 
							instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponsePartitions is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 8)
							await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 8)
							await _committedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 8)
							await _committedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 8)
							await _metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 8)
							await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						private set 
						{
							if (Version >= 8 == false)
								throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int64 _committedOffset = Int64.Default;
					/// <summary>
					/// <para>The committed message offset.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int64 CommittedOffset 
					{
						get => _committedOffset;
						private set 
						{
							if (Version >= 8 == false)
								throw new UnsupportedVersionException($"CommittedOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

							_committedOffset = value;
						}
					}

					/// <summary>
					/// <para>The committed message offset.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithCommittedOffset(Int64 committedOffset)
					{
						CommittedOffset = committedOffset;
						return this;
					}

					private Int32 _committedLeaderEpoch = new Int32(-1);
					/// <summary>
					/// <para>The leader epoch.</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 CommittedLeaderEpoch 
					{
						get => _committedLeaderEpoch;
						private set 
						{
							_committedLeaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The leader epoch.</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
					{
						CommittedLeaderEpoch = committedLeaderEpoch;
						return this;
					}

					private NullableString _metadata = NullableString.Default;
					/// <summary>
					/// <para>The partition metadata.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public String? Metadata 
					{
						get => _metadata;
						private set 
						{
							if (Version >= 8 == false)
								throw new UnsupportedVersionException($"Metadata does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

							if (Version >= 8 == false &&
								value == null) 
								throw new UnsupportedVersionException($"Metadata does not support null for version {Version}. Supported versions for null value: 8+");

							_metadata = value;
						}
					}

					/// <summary>
					/// <para>The partition metadata.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithMetadata(String? metadata)
					{
						Metadata = metadata;
						return this;
					}

					private Int16 _errorCode = Int16.Default;
					/// <summary>
					/// <para>The partition-level error code, or 0 if there was no error.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int16 ErrorCode 
					{
						get => _errorCode;
						private set 
						{
							if (Version >= 8 == false)
								throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

							_errorCode = value;
						}
					}

					/// <summary>
					/// <para>The partition-level error code, or 0 if there was no error.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithErrorCode(Int16 errorCode)
					{
						ErrorCode = errorCode;
						return this;
					}
				}
			}

			private Int16 _errorCode = new Int16(0);
			/// <summary>
			/// <para>The group-level error code, or 0 if there was no error.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: 0</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					if (Version >= 8 == false)
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The group-level error code, or 0 if there was no error.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: 0</para>
			/// </summary>
			public OffsetFetchResponseGroup WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class OffsetForLeaderEpochRequest : Message, IRespond<OffsetForLeaderEpochResponse>
	{
		public OffsetForLeaderEpochRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetForLeaderEpochRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(23);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_replicaId.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetForLeaderEpochRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetForLeaderEpochRequest(version);
			if (instance.Version >= 3) 
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<String, OffsetForLeaderTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetForLeaderTopic.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderEpochRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _replicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _replicaId = new Int32(-2);
		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -2</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			private set 
			{
				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -2</para>
		/// </summary>
		public OffsetForLeaderEpochRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Map<String, OffsetForLeaderTopic> _topicsCollection = Map<String, OffsetForLeaderTopic>.Default;
		/// <summary>
		/// <para>Each topic to get offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, OffsetForLeaderTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic to get offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetForLeaderEpochRequest WithTopicsCollection(params Func<OffsetForLeaderTopic, OffsetForLeaderTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetForLeaderTopic(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public delegate OffsetForLeaderTopic CreateOffsetForLeaderTopic(OffsetForLeaderTopic field);

		/// <summary>
		/// <para>Each topic to get offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetForLeaderEpochRequest WithTopicsCollection(IEnumerable<CreateOffsetForLeaderTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetForLeaderTopic(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public class OffsetForLeaderTopic : ISerialize
		{
			internal OffsetForLeaderTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topic.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetForLeaderTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetForLeaderTopic(version);
				instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<OffsetForLeaderPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetForLeaderPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<OffsetForLeaderPartition> _partitionsCollection = Array.Empty<OffsetForLeaderPartition>();
			/// <summary>
			/// <para>Each partition to get offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<OffsetForLeaderPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to get offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopic WithPartitionsCollection(params Func<OffsetForLeaderPartition, OffsetForLeaderPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetForLeaderPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate OffsetForLeaderPartition CreateOffsetForLeaderPartition(OffsetForLeaderPartition field);

			/// <summary>
			/// <para>Each partition to get offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopic WithPartitionsCollection(IEnumerable<CreateOffsetForLeaderPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new OffsetForLeaderPartition(Version)))
					.ToArray();
				return this;
			}

			public class OffsetForLeaderPartition : ISerialize
			{
				internal OffsetForLeaderPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 4;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					(Version >= 2 ? 
						_currentLeaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<OffsetForLeaderPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetForLeaderPartition(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 2) 
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 2)
						await _currentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetForLeaderPartition WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _currentLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					private set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetForLeaderPartition WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The epoch to look up an offset for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch to look up an offset for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetForLeaderPartition WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}

		public OffsetForLeaderEpochResponse Respond()
			=> new OffsetForLeaderEpochResponse(Version);
	}

	public class OffsetForLeaderEpochResponse : Message
	{
		public OffsetForLeaderEpochResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"OffsetForLeaderEpochResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(23);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 2 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<OffsetForLeaderEpochResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetForLeaderEpochResponse(version);
			if (instance.Version >= 2) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Map<String, OffsetForLeaderTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetForLeaderTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderEpochResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 2)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public OffsetForLeaderEpochResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Map<String, OffsetForLeaderTopicResult> _topicsCollection = Map<String, OffsetForLeaderTopicResult>.Default;
		/// <summary>
		/// <para>Each topic we fetched offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, OffsetForLeaderTopicResult> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic we fetched offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetForLeaderEpochResponse WithTopicsCollection(params Func<OffsetForLeaderTopicResult, OffsetForLeaderTopicResult>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetForLeaderTopicResult(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public delegate OffsetForLeaderTopicResult CreateOffsetForLeaderTopicResult(OffsetForLeaderTopicResult field);

		/// <summary>
		/// <para>Each topic we fetched offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetForLeaderEpochResponse WithTopicsCollection(IEnumerable<CreateOffsetForLeaderTopicResult> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new OffsetForLeaderTopicResult(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public class OffsetForLeaderTopicResult : ISerialize
		{
			internal OffsetForLeaderTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topic.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<OffsetForLeaderTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetForLeaderTopicResult(version);
				instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<EpochEndOffset>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EpochEndOffset.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopicResult WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<EpochEndOffset> _partitionsCollection = Array.Empty<EpochEndOffset>();
			/// <summary>
			/// <para>Each partition in the topic we fetched offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<EpochEndOffset> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the topic we fetched offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopicResult WithPartitionsCollection(params Func<EpochEndOffset, EpochEndOffset>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new EpochEndOffset(Version)))
					.ToArray();
				return this;
			}

			public delegate EpochEndOffset CreateEpochEndOffset(EpochEndOffset field);

			/// <summary>
			/// <para>Each partition in the topic we fetched offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopicResult WithPartitionsCollection(IEnumerable<CreateEpochEndOffset> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new EpochEndOffset(Version)))
					.ToArray();
				return this;
			}

			public class EpochEndOffset : ISerialize
			{
				internal EpochEndOffset(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 4;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_errorCode.GetSize(IsFlexibleVersion) +
					_partition.GetSize(IsFlexibleVersion) +
					(Version >= 1 ? 
						_leaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					_endOffset.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<EpochEndOffset> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EpochEndOffset(version);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EpochEndOffset is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _endOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code 0, or if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code 0, or if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EpochEndOffset WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EpochEndOffset WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of the partition.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the partition.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public EpochEndOffset WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int64 _endOffset = new Int64(-1);
				/// <summary>
				/// <para>The end offset of the epoch.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 EndOffset 
				{
					get => _endOffset;
					private set 
					{
						_endOffset = value;
					}
				}

				/// <summary>
				/// <para>The end offset of the epoch.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public EpochEndOffset WithEndOffset(Int64 endOffset)
				{
					EndOffset = endOffset;
					return this;
				}
			}
		}
	}

	public class ProduceRequest : Message, IRespond<ProduceResponse>
	{
		public ProduceRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ProduceRequest does not support version {version}. Valid versions are: 0-11");

			Version = version;
			IsFlexibleVersion = version >= 9;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(11);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 3 ? 
				_transactionalId.GetSize(IsFlexibleVersion):
				0) +
			_acks.GetSize(IsFlexibleVersion) +
			_timeoutMs.GetSize(IsFlexibleVersion) +
			_topicDataCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ProduceRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ProduceRequest(version);
			if (instance.Version >= 3) 
				instance.TransactionalId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Acks = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicDataCollection = await Map<String, TopicProduceData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicProduceData.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ProduceRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 3)
				await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _acks.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicDataCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _transactionalId = new NullableString(null);
		/// <summary>
		/// <para>The transactional ID, or null if the producer is not transactional.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? TransactionalId 
		{
			get => _transactionalId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"TransactionalId does not support null for version {Version}. Supported versions for null value: 3+");

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional ID, or null if the producer is not transactional.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ProduceRequest WithTransactionalId(String? transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int16 _acks = Int16.Default;
		/// <summary>
		/// <para>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Acks 
		{
			get => _acks;
			private set 
			{
				_acks = value;
			}
		}

		/// <summary>
		/// <para>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithAcks(Int16 acks)
		{
			Acks = acks;
			return this;
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>The timeout to await a response in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The timeout to await a response in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Map<String, TopicProduceData> _topicDataCollection = Map<String, TopicProduceData>.Default;
		/// <summary>
		/// <para>Each topic to produce to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, TopicProduceData> TopicDataCollection 
		{
			get => _topicDataCollection;
			private set 
			{
				_topicDataCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic to produce to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithTopicDataCollection(params Func<TopicProduceData, TopicProduceData>[] createFields)
		{
			TopicDataCollection = createFields
				.Select(createField => createField(new TopicProduceData(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate TopicProduceData CreateTopicProduceData(TopicProduceData field);

		/// <summary>
		/// <para>Each topic to produce to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithTopicDataCollection(IEnumerable<CreateTopicProduceData> createFields)
		{
			TopicDataCollection = createFields
				.Select(createField => createField(new TopicProduceData(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class TopicProduceData : ISerialize
		{
			internal TopicProduceData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 9;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionDataCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicProduceData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicProduceData(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionDataCollection = await Array<PartitionProduceData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionProduceData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicProduceData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionDataCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceData WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<PartitionProduceData> _partitionDataCollection = Array.Empty<PartitionProduceData>();
			/// <summary>
			/// <para>Each partition to produce to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionProduceData> PartitionDataCollection 
			{
				get => _partitionDataCollection;
				private set 
				{
					_partitionDataCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to produce to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceData WithPartitionDataCollection(params Func<PartitionProduceData, PartitionProduceData>[] createFields)
			{
				PartitionDataCollection = createFields
					.Select(createField => createField(new PartitionProduceData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionProduceData CreatePartitionProduceData(PartitionProduceData field);

			/// <summary>
			/// <para>Each partition to produce to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceData WithPartitionDataCollection(IEnumerable<CreatePartitionProduceData> createFields)
			{
				PartitionDataCollection = createFields
					.Select(createField => createField(new PartitionProduceData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionProduceData : ISerialize
			{
				internal PartitionProduceData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 9;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_index.GetSize(IsFlexibleVersion) +
					_records.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionProduceData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionProduceData(version);
					instance.Index = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Records = await NullableRecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionProduceData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _index.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _records.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _index = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Index 
				{
					get => _index;
					private set 
					{
						_index = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceData WithIndex(Int32 index)
				{
					Index = index;
					return this;
				}

				private NullableRecordBatch _records = NullableRecordBatch.Default;
				/// <summary>
				/// <para>The record data to be produced.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public RecordBatch? Records 
				{
					get => _records;
					private set 
					{
						_records = value;
					}
				}

				/// <summary>
				/// <para>The record data to be produced.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceData WithRecords(RecordBatch? records)
				{
					Records = records;
					return this;
				}
			}
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class ProduceResponse : Message
	{
		public ProduceResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ProduceResponse does not support version {version}. Valid versions are: 0-11");

			Version = version;
			IsFlexibleVersion = version >= 9;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(11);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (Version >= 10 && _nodeEndpointsCollectionIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _nodeEndpointsCollection
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
			_responsesCollection.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ProduceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ProduceResponse(version);
			instance.ResponsesCollection = await Map<String, TopicProduceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicProduceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version >= 10) 
								instance.NodeEndpointsCollection = await Map<Int32, NodeEndpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => NodeEndpoint.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.NodeId, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field NodeEndpointsCollection is not supported for version {instance.Version}");
							{
								var size = instance._nodeEndpointsCollection.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field NodeEndpointsCollection read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ProduceResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Map<String, TopicProduceResponse> _responsesCollection = Map<String, TopicProduceResponse>.Default;
		/// <summary>
		/// <para>Each produce response</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, TopicProduceResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each produce response</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceResponse WithResponsesCollection(params Func<TopicProduceResponse, TopicProduceResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new TopicProduceResponse(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate TopicProduceResponse CreateTopicProduceResponse(TopicProduceResponse field);

		/// <summary>
		/// <para>Each produce response</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceResponse WithResponsesCollection(IEnumerable<CreateTopicProduceResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new TopicProduceResponse(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class TopicProduceResponse : ISerialize
		{
			internal TopicProduceResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 9;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionResponsesCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicProduceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicProduceResponse(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionResponsesCollection = await Array<PartitionProduceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionProduceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicProduceResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionResponsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<PartitionProduceResponse> _partitionResponsesCollection = Array.Empty<PartitionProduceResponse>();
			/// <summary>
			/// <para>Each partition that we produced to within the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionProduceResponse> PartitionResponsesCollection 
			{
				get => _partitionResponsesCollection;
				private set 
				{
					_partitionResponsesCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition that we produced to within the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceResponse WithPartitionResponsesCollection(params Func<PartitionProduceResponse, PartitionProduceResponse>[] createFields)
			{
				PartitionResponsesCollection = createFields
					.Select(createField => createField(new PartitionProduceResponse(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionProduceResponse CreatePartitionProduceResponse(PartitionProduceResponse field);

			/// <summary>
			/// <para>Each partition that we produced to within the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceResponse WithPartitionResponsesCollection(IEnumerable<CreatePartitionProduceResponse> createFields)
			{
				PartitionResponsesCollection = createFields
					.Select(createField => createField(new PartitionProduceResponse(Version)))
					.ToArray();
				return this;
			}

			public class PartitionProduceResponse : ISerialize
			{
				internal PartitionProduceResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 9;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					var tags = new List<Tags.TaggedField>();
					if (Version >= 10 && _currentLeaderIsSet) 
						tags.Add(new Tags.TaggedField
						{
							Tag = 0,
							Field = _currentLeader
						});
					return new Tags.TagSection(tags.ToArray());
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_index.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_baseOffset.GetSize(IsFlexibleVersion) +
					(Version >= 2 ? 
						_logAppendTimeMs.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 5 ? 
						_logStartOffset.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 8 ? 
						_recordErrorsCollection.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 8 ? 
						_errorMessage.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionProduceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionProduceResponse(version);
					instance.Index = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.BaseOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 2) 
						instance.LogAppendTimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 5) 
						instance.LogStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 8) 
						instance.RecordErrorsCollection = await Array<BatchIndexAndErrorMessage>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => BatchIndexAndErrorMessage.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 8) 
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								case 0:
									if (instance.Version >= 10) 
										instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									else
										throw new InvalidOperationException($"Field CurrentLeader is not supported for version {instance.Version}");
									{
										var size = instance._currentLeader.GetSize(true);
										if (size != tag.Length)
											throw new CorruptMessageException($"Tagged field CurrentLeader read length {tag.Length} but had actual length of {size}");
									}
									break;
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionProduceResponse is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _index.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _baseOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 2)
						await _logAppendTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 5)
						await _logStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 8)
						await _recordErrorsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 8)
						await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _index = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Index 
				{
					get => _index;
					private set 
					{
						_index = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceResponse WithIndex(Int32 index)
				{
					Index = index;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int64 _baseOffset = Int64.Default;
				/// <summary>
				/// <para>The base offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 BaseOffset 
				{
					get => _baseOffset;
					private set 
					{
						_baseOffset = value;
					}
				}

				/// <summary>
				/// <para>The base offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceResponse WithBaseOffset(Int64 baseOffset)
				{
					BaseOffset = baseOffset;
					return this;
				}

				private Int64 _logAppendTimeMs = new Int64(-1);
				/// <summary>
				/// <para>The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1.  If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogAppendTimeMs 
				{
					get => _logAppendTimeMs;
					private set 
					{
						_logAppendTimeMs = value;
					}
				}

				/// <summary>
				/// <para>The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1.  If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionProduceResponse WithLogAppendTimeMs(Int64 logAppendTimeMs)
				{
					LogAppendTimeMs = logAppendTimeMs;
					return this;
				}

				private Int64 _logStartOffset = new Int64(-1);
				/// <summary>
				/// <para>The log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogStartOffset 
				{
					get => _logStartOffset;
					private set 
					{
						_logStartOffset = value;
					}
				}

				/// <summary>
				/// <para>The log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionProduceResponse WithLogStartOffset(Int64 logStartOffset)
				{
					LogStartOffset = logStartOffset;
					return this;
				}

				private Array<BatchIndexAndErrorMessage> _recordErrorsCollection = Array.Empty<BatchIndexAndErrorMessage>();
				/// <summary>
				/// <para>The batch indices of records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public Array<BatchIndexAndErrorMessage> RecordErrorsCollection 
				{
					get => _recordErrorsCollection;
					private set 
					{
						_recordErrorsCollection = value;
					}
				}

				/// <summary>
				/// <para>The batch indices of records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public PartitionProduceResponse WithRecordErrorsCollection(params Func<BatchIndexAndErrorMessage, BatchIndexAndErrorMessage>[] createFields)
				{
					RecordErrorsCollection = createFields
						.Select(createField => createField(new BatchIndexAndErrorMessage(Version)))
						.ToArray();
					return this;
				}

				public delegate BatchIndexAndErrorMessage CreateBatchIndexAndErrorMessage(BatchIndexAndErrorMessage field);

				/// <summary>
				/// <para>The batch indices of records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public PartitionProduceResponse WithRecordErrorsCollection(IEnumerable<CreateBatchIndexAndErrorMessage> createFields)
				{
					RecordErrorsCollection = createFields
						.Select(createField => createField(new BatchIndexAndErrorMessage(Version)))
						.ToArray();
					return this;
				}

				public class BatchIndexAndErrorMessage : ISerialize
				{
					internal BatchIndexAndErrorMessage(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 9;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 8 ? 
							_batchIndex.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 8 ? 
							_batchIndexErrorMessage.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<BatchIndexAndErrorMessage> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new BatchIndexAndErrorMessage(version);
						if (instance.Version >= 8) 
							instance.BatchIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 8) 
							instance.BatchIndexErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for BatchIndexAndErrorMessage is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 8)
							await _batchIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 8)
							await _batchIndexErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _batchIndex = Int32.Default;
					/// <summary>
					/// <para>The batch index of the record that cause the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int32 BatchIndex 
					{
						get => _batchIndex;
						private set 
						{
							if (Version >= 8 == false)
								throw new UnsupportedVersionException($"BatchIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

							_batchIndex = value;
						}
					}

					/// <summary>
					/// <para>The batch index of the record that cause the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public BatchIndexAndErrorMessage WithBatchIndex(Int32 batchIndex)
					{
						BatchIndex = batchIndex;
						return this;
					}

					private NullableString _batchIndexErrorMessage = new NullableString(null);
					/// <summary>
					/// <para>The error message of the record that caused the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: null</para>
					/// </summary>
					public String? BatchIndexErrorMessage 
					{
						get => _batchIndexErrorMessage;
						private set 
						{
							if (Version >= 8 == false)
								throw new UnsupportedVersionException($"BatchIndexErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

							if (Version >= 8 == false &&
								value == null) 
								throw new UnsupportedVersionException($"BatchIndexErrorMessage does not support null for version {Version}. Supported versions for null value: 8+");

							_batchIndexErrorMessage = value;
						}
					}

					/// <summary>
					/// <para>The error message of the record that caused the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: null</para>
					/// </summary>
					public BatchIndexAndErrorMessage WithBatchIndexErrorMessage(String? batchIndexErrorMessage)
					{
						BatchIndexErrorMessage = batchIndexErrorMessage;
						return this;
					}
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The global error message summarizing the common root cause of the records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						if (Version >= 8 == false &&
							value == null) 
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 8+");

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The global error message summarizing the common root cause of the records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionProduceResponse WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private bool _currentLeaderIsSet;
				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 10+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					private set 
					{
						if (Version >= 10 == false)
							throw new UnsupportedVersionException($"CurrentLeader does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

						_currentLeader = value;
						_currentLeaderIsSet = true;
					}
				}

				/// <summary>
				/// <para>Versions: 10+</para>
				/// </summary>
				public PartitionProduceResponse WithCurrentLeader(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(new LeaderIdAndEpoch(Version));
					return this;
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 9;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						(Version >= 10 ? 
							_leaderId.GetSize(IsFlexibleVersion):
							0) +
						(Version >= 10 ? 
							_leaderEpoch.GetSize(IsFlexibleVersion):
							0) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						if (instance.Version >= 10) 
							instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (instance.Version >= 10) 
							instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version >= 10)
							await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						if (Version >= 10)
							await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _leaderId = new Int32(-1);
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 10+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						private set 
						{
							if (Version >= 10 == false)
								throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 10+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = new Int32(-1);
					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 10+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						private set 
						{
							if (Version >= 10 == false)
								throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 10+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}
			}
		}

		private Int32 _throttleTimeMs = new Int32(0);
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public ProduceResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private bool _nodeEndpointsCollectionIsSet;
		private Map<Int32, NodeEndpoint> _nodeEndpointsCollection = Map<Int32, NodeEndpoint>.Default;
		/// <summary>
		/// <para>Endpoints for all current-leaders enumerated in PartitionProduceResponses, with errors NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 10+</para>
		/// </summary>
		public Map<Int32, NodeEndpoint> NodeEndpointsCollection 
		{
			get => _nodeEndpointsCollection;
			private set 
			{
				if (Version >= 10 == false)
					throw new UnsupportedVersionException($"NodeEndpointsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

				_nodeEndpointsCollection = value;
				_nodeEndpointsCollectionIsSet = true;
			}
		}

		/// <summary>
		/// <para>Endpoints for all current-leaders enumerated in PartitionProduceResponses, with errors NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 10+</para>
		/// </summary>
		public ProduceResponse WithNodeEndpointsCollection(params Func<NodeEndpoint, NodeEndpoint>[] createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public delegate NodeEndpoint CreateNodeEndpoint(NodeEndpoint field);

		/// <summary>
		/// <para>Endpoints for all current-leaders enumerated in PartitionProduceResponses, with errors NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 10+</para>
		/// </summary>
		public ProduceResponse WithNodeEndpointsCollection(IEnumerable<CreateNodeEndpoint> createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public class NodeEndpoint : ISerialize
		{
			internal NodeEndpoint(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 9;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 10 ? 
					_nodeId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 10 ? 
					_host.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 10 ? 
					_port.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 10 ? 
					_rack.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<NodeEndpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new NodeEndpoint(version);
				if (instance.Version >= 10) 
					instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 10) 
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 10) 
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 10) 
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for NodeEndpoint is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 10)
					await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 10)
					await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 10)
					await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 10)
					await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					if (Version >= 10 == false)
						throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public NodeEndpoint WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					if (Version >= 10 == false)
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

					_host = value;
				}
			}

			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public NodeEndpoint WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					if (Version >= 10 == false)
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

					_port = value;
				}
			}

			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public NodeEndpoint WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private NullableString _rack = new NullableString(null);
			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 10+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					if (Version >= 10 == false)
						throw new UnsupportedVersionException($"Rack does not support version {Version} and has been defined as not ignorable. Supported versions: 10+");

					if (Version >= 10 == false &&
						value == null) 
						throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 10+");

					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 10+</para>
			/// <para>Default: null</para>
			/// </summary>
			public NodeEndpoint WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}
	}

	public class PushTelemetryRequest : Message, IRespond<PushTelemetryResponse>
	{
		public PushTelemetryRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"PushTelemetryRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(72);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clientInstanceId.GetSize(IsFlexibleVersion) +
			_subscriptionId.GetSize(IsFlexibleVersion) +
			_terminating.GetSize(IsFlexibleVersion) +
			_compressionType.GetSize(IsFlexibleVersion) +
			_metrics.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<PushTelemetryRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new PushTelemetryRequest(version);
			instance.ClientInstanceId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.SubscriptionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Terminating = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.CompressionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Metrics = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for PushTelemetryRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clientInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _subscriptionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _terminating.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _compressionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _metrics.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Uuid _clientInstanceId = Uuid.Default;
		/// <summary>
		/// <para>Unique id for this client instance.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid ClientInstanceId 
		{
			get => _clientInstanceId;
			private set 
			{
				_clientInstanceId = value;
			}
		}

		/// <summary>
		/// <para>Unique id for this client instance.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryRequest WithClientInstanceId(Uuid clientInstanceId)
		{
			ClientInstanceId = clientInstanceId;
			return this;
		}

		private Int32 _subscriptionId = Int32.Default;
		/// <summary>
		/// <para>Unique identifier for the current subscription.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 SubscriptionId 
		{
			get => _subscriptionId;
			private set 
			{
				_subscriptionId = value;
			}
		}

		/// <summary>
		/// <para>Unique identifier for the current subscription.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryRequest WithSubscriptionId(Int32 subscriptionId)
		{
			SubscriptionId = subscriptionId;
			return this;
		}

		private Boolean _terminating = Boolean.Default;
		/// <summary>
		/// <para>Client is terminating the connection.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean Terminating 
		{
			get => _terminating;
			private set 
			{
				_terminating = value;
			}
		}

		/// <summary>
		/// <para>Client is terminating the connection.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryRequest WithTerminating(Boolean terminating)
		{
			Terminating = terminating;
			return this;
		}

		private Int8 _compressionType = Int8.Default;
		/// <summary>
		/// <para>Compression codec used to compress the metrics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 CompressionType 
		{
			get => _compressionType;
			private set 
			{
				_compressionType = value;
			}
		}

		/// <summary>
		/// <para>Compression codec used to compress the metrics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryRequest WithCompressionType(Int8 compressionType)
		{
			CompressionType = compressionType;
			return this;
		}

		private Bytes _metrics = Bytes.Default;
		/// <summary>
		/// <para>Metrics encoded in OpenTelemetry MetricsData v1 protobuf format.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Metrics 
		{
			get => _metrics;
			private set 
			{
				_metrics = value;
			}
		}

		/// <summary>
		/// <para>Metrics encoded in OpenTelemetry MetricsData v1 protobuf format.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryRequest WithMetrics(Bytes metrics)
		{
			Metrics = metrics;
			return this;
		}

		public PushTelemetryResponse Respond()
			=> new PushTelemetryResponse(Version);
	}

	public class PushTelemetryResponse : Message
	{
		public PushTelemetryResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"PushTelemetryResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(72);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<PushTelemetryResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new PushTelemetryResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for PushTelemetryResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public PushTelemetryResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class ReadShareGroupStateRequest : Message, IRespond<ReadShareGroupStateResponse>
	{
		public ReadShareGroupStateRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ReadShareGroupStateRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(84);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ReadShareGroupStateRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ReadShareGroupStateRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<ReadStateData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReadStateData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadShareGroupStateRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Array<ReadStateData> _topicsCollection = Array.Empty<ReadStateData>();
		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReadStateData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateRequest WithTopicsCollection(params Func<ReadStateData, ReadStateData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ReadStateData(Version)))
				.ToArray();
			return this;
		}

		public delegate ReadStateData CreateReadStateData(ReadStateData field);

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateRequest WithTopicsCollection(IEnumerable<CreateReadStateData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ReadStateData(Version)))
				.ToArray();
			return this;
		}

		public class ReadStateData : ISerialize
		{
			internal ReadStateData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReadStateData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReadStateData(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadStateData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}

		public ReadShareGroupStateResponse Respond()
			=> new ReadShareGroupStateResponse(Version);
	}

	public class ReadShareGroupStateResponse : Message
	{
		public ReadShareGroupStateResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ReadShareGroupStateResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(84);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ReadShareGroupStateResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ReadShareGroupStateResponse(version);
			instance.ResultsCollection = await Array<ReadStateResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReadStateResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadShareGroupStateResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<ReadStateResult> _resultsCollection = Array.Empty<ReadStateResult>();
		/// <summary>
		/// <para>The read results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReadStateResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The read results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateResponse WithResultsCollection(params Func<ReadStateResult, ReadStateResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new ReadStateResult(Version)))
				.ToArray();
			return this;
		}

		public delegate ReadStateResult CreateReadStateResult(ReadStateResult field);

		/// <summary>
		/// <para>The read results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateResponse WithResultsCollection(IEnumerable<CreateReadStateResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new ReadStateResult(Version)))
				.ToArray();
			return this;
		}

		public class ReadStateResult : ISerialize
		{
			internal ReadStateResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReadStateResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReadStateResult(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadStateResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionResult> _partitionsCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateResult WithPartitionsCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResult CreatePartitionResult(PartitionResult field);

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateResult WithPartitionsCollection(IEnumerable<CreatePartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					_stateEpoch.GetSize(IsFlexibleVersion) +
					_startOffset.GetSize(IsFlexibleVersion) +
					_stateBatchesCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StateEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StateBatchesCollection = await Array<StateBatch>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StateBatch.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _stateEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _startOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _stateBatchesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Int32 _stateEpoch = Int32.Default;
				/// <summary>
				/// <para>The state epoch for this share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 StateEpoch 
				{
					get => _stateEpoch;
					private set 
					{
						_stateEpoch = value;
					}
				}

				/// <summary>
				/// <para>The state epoch for this share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithStateEpoch(Int32 stateEpoch)
				{
					StateEpoch = stateEpoch;
					return this;
				}

				private Int64 _startOffset = Int64.Default;
				/// <summary>
				/// <para>The share-partition start offset, which can be -1 if it is not yet initialized.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 StartOffset 
				{
					get => _startOffset;
					private set 
					{
						_startOffset = value;
					}
				}

				/// <summary>
				/// <para>The share-partition start offset, which can be -1 if it is not yet initialized.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithStartOffset(Int64 startOffset)
				{
					StartOffset = startOffset;
					return this;
				}

				private Array<StateBatch> _stateBatchesCollection = Array.Empty<StateBatch>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<StateBatch> StateBatchesCollection 
				{
					get => _stateBatchesCollection;
					private set 
					{
						_stateBatchesCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithStateBatchesCollection(params Func<StateBatch, StateBatch>[] createFields)
				{
					StateBatchesCollection = createFields
						.Select(createField => createField(new StateBatch(Version)))
						.ToArray();
					return this;
				}

				public delegate StateBatch CreateStateBatch(StateBatch field);

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithStateBatchesCollection(IEnumerable<CreateStateBatch> createFields)
				{
					StateBatchesCollection = createFields
						.Select(createField => createField(new StateBatch(Version)))
						.ToArray();
					return this;
				}

				public class StateBatch : ISerialize
				{
					internal StateBatch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_firstOffset.GetSize(IsFlexibleVersion) +
						_lastOffset.GetSize(IsFlexibleVersion) +
						_deliveryState.GetSize(IsFlexibleVersion) +
						_deliveryCount.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<StateBatch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new StateBatch(version);
						instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.DeliveryState = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.DeliveryCount = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for StateBatch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _firstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _deliveryState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _deliveryCount.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>The base offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						private set 
						{
							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>The base offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}

					private Int64 _lastOffset = Int64.Default;
					/// <summary>
					/// <para>The last offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 LastOffset 
					{
						get => _lastOffset;
						private set 
						{
							_lastOffset = value;
						}
					}

					/// <summary>
					/// <para>The last offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithLastOffset(Int64 lastOffset)
					{
						LastOffset = lastOffset;
						return this;
					}

					private Int8 _deliveryState = Int8.Default;
					/// <summary>
					/// <para>The state - 0:Available,2:Acked,4:Archived.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int8 DeliveryState 
					{
						get => _deliveryState;
						private set 
						{
							_deliveryState = value;
						}
					}

					/// <summary>
					/// <para>The state - 0:Available,2:Acked,4:Archived.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithDeliveryState(Int8 deliveryState)
					{
						DeliveryState = deliveryState;
						return this;
					}

					private Int16 _deliveryCount = Int16.Default;
					/// <summary>
					/// <para>The delivery count.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int16 DeliveryCount 
					{
						get => _deliveryCount;
						private set 
						{
							_deliveryCount = value;
						}
					}

					/// <summary>
					/// <para>The delivery count.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithDeliveryCount(Int16 deliveryCount)
					{
						DeliveryCount = deliveryCount;
						return this;
					}
				}
			}
		}
	}

	public class ReadShareGroupStateSummaryRequest : Message, IRespond<ReadShareGroupStateSummaryResponse>
	{
		public ReadShareGroupStateSummaryRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ReadShareGroupStateSummaryRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(87);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ReadShareGroupStateSummaryRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ReadShareGroupStateSummaryRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<ReadStateSummaryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReadStateSummaryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadShareGroupStateSummaryRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateSummaryRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Array<ReadStateSummaryData> _topicsCollection = Array.Empty<ReadStateSummaryData>();
		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReadStateSummaryData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateSummaryRequest WithTopicsCollection(params Func<ReadStateSummaryData, ReadStateSummaryData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ReadStateSummaryData(Version)))
				.ToArray();
			return this;
		}

		public delegate ReadStateSummaryData CreateReadStateSummaryData(ReadStateSummaryData field);

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateSummaryRequest WithTopicsCollection(IEnumerable<CreateReadStateSummaryData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new ReadStateSummaryData(Version)))
				.ToArray();
			return this;
		}

		public class ReadStateSummaryData : ISerialize
		{
			internal ReadStateSummaryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReadStateSummaryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReadStateSummaryData(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadStateSummaryData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateSummaryData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateSummaryData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateSummaryData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}

		public ReadShareGroupStateSummaryResponse Respond()
			=> new ReadShareGroupStateSummaryResponse(Version);
	}

	public class ReadShareGroupStateSummaryResponse : Message
	{
		public ReadShareGroupStateSummaryResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ReadShareGroupStateSummaryResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(87);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ReadShareGroupStateSummaryResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ReadShareGroupStateSummaryResponse(version);
			instance.ResultsCollection = await Array<ReadStateSummaryResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReadStateSummaryResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadShareGroupStateSummaryResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<ReadStateSummaryResult> _resultsCollection = Array.Empty<ReadStateSummaryResult>();
		/// <summary>
		/// <para>The read results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ReadStateSummaryResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The read results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateSummaryResponse WithResultsCollection(params Func<ReadStateSummaryResult, ReadStateSummaryResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new ReadStateSummaryResult(Version)))
				.ToArray();
			return this;
		}

		public delegate ReadStateSummaryResult CreateReadStateSummaryResult(ReadStateSummaryResult field);

		/// <summary>
		/// <para>The read results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReadShareGroupStateSummaryResponse WithResultsCollection(IEnumerable<CreateReadStateSummaryResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new ReadStateSummaryResult(Version)))
				.ToArray();
			return this;
		}

		public class ReadStateSummaryResult : ISerialize
		{
			internal ReadStateSummaryResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ReadStateSummaryResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReadStateSummaryResult(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReadStateSummaryResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateSummaryResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionResult> _partitionsCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateSummaryResult WithPartitionsCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResult CreatePartitionResult(PartitionResult field);

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReadStateSummaryResult WithPartitionsCollection(IEnumerable<CreatePartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					_stateEpoch.GetSize(IsFlexibleVersion) +
					_startOffset.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StateEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _stateEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _startOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Int32 _stateEpoch = Int32.Default;
				/// <summary>
				/// <para>The state epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 StateEpoch 
				{
					get => _stateEpoch;
					private set 
					{
						_stateEpoch = value;
					}
				}

				/// <summary>
				/// <para>The state epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithStateEpoch(Int32 stateEpoch)
				{
					StateEpoch = stateEpoch;
					return this;
				}

				private Int64 _startOffset = Int64.Default;
				/// <summary>
				/// <para>The share-partition start offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 StartOffset 
				{
					get => _startOffset;
					private set 
					{
						_startOffset = value;
					}
				}

				/// <summary>
				/// <para>The share-partition start offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithStartOffset(Int64 startOffset)
				{
					StartOffset = startOffset;
					return this;
				}
			}
		}
	}

	public class RemoveRaftVoterRequest : Message, IRespond<RemoveRaftVoterResponse>
	{
		public RemoveRaftVoterRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"RemoveRaftVoterRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(81);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clusterId.GetSize(IsFlexibleVersion) +
			_voterId.GetSize(IsFlexibleVersion) +
			_voterDirectoryId.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<RemoveRaftVoterRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RemoveRaftVoterRequest(version);
			instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VoterId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VoterDirectoryId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RemoveRaftVoterRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _voterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _voterDirectoryId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RemoveRaftVoterRequest WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _voterId = Int32.Default;
		/// <summary>
		/// <para>The replica id of the voter getting removed from the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 VoterId 
		{
			get => _voterId;
			private set 
			{
				_voterId = value;
			}
		}

		/// <summary>
		/// <para>The replica id of the voter getting removed from the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RemoveRaftVoterRequest WithVoterId(Int32 voterId)
		{
			VoterId = voterId;
			return this;
		}

		private Uuid _voterDirectoryId = Uuid.Default;
		/// <summary>
		/// <para>The directory id of the voter getting removed from the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid VoterDirectoryId 
		{
			get => _voterDirectoryId;
			private set 
			{
				_voterDirectoryId = value;
			}
		}

		/// <summary>
		/// <para>The directory id of the voter getting removed from the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RemoveRaftVoterRequest WithVoterDirectoryId(Uuid voterDirectoryId)
		{
			VoterDirectoryId = voterDirectoryId;
			return this;
		}

		public RemoveRaftVoterResponse Respond()
			=> new RemoveRaftVoterResponse(Version);
	}

	public class RemoveRaftVoterResponse : Message
	{
		public RemoveRaftVoterResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"RemoveRaftVoterResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(81);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<RemoveRaftVoterResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RemoveRaftVoterResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RemoveRaftVoterResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RemoveRaftVoterResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RemoveRaftVoterResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RemoveRaftVoterResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}
	}

	public class RenewDelegationTokenRequest : Message, IRespond<RenewDelegationTokenResponse>
	{
		public RenewDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"RenewDelegationTokenRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(39);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_hmac.GetSize(IsFlexibleVersion) +
			_renewPeriodMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<RenewDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RenewDelegationTokenRequest(version);
			instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RenewPeriodMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RenewDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _renewPeriodMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Bytes _hmac = Bytes.Default;
		/// <summary>
		/// <para>The HMAC of the delegation token to be renewed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Hmac 
		{
			get => _hmac;
			private set 
			{
				_hmac = value;
			}
		}

		/// <summary>
		/// <para>The HMAC of the delegation token to be renewed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenRequest WithHmac(Bytes hmac)
		{
			Hmac = hmac;
			return this;
		}

		private Int64 _renewPeriodMs = Int64.Default;
		/// <summary>
		/// <para>The renewal time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 RenewPeriodMs 
		{
			get => _renewPeriodMs;
			private set 
			{
				_renewPeriodMs = value;
			}
		}

		/// <summary>
		/// <para>The renewal time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenRequest WithRenewPeriodMs(Int64 renewPeriodMs)
		{
			RenewPeriodMs = renewPeriodMs;
			return this;
		}

		public RenewDelegationTokenResponse Respond()
			=> new RenewDelegationTokenResponse(Version);
	}

	public class RenewDelegationTokenResponse : Message
	{
		public RenewDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"RenewDelegationTokenResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(39);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_expiryTimestampMs.GetSize(IsFlexibleVersion) +
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<RenewDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RenewDelegationTokenResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ExpiryTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RenewDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _expiryTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _expiryTimestampMs = Int64.Default;
		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimestampMs 
		{
			get => _expiryTimestampMs;
			private set 
			{
				_expiryTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenResponse WithExpiryTimestampMs(Int64 expiryTimestampMs)
		{
			ExpiryTimestampMs = expiryTimestampMs;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class SaslAuthenticateRequest : Message, IRespond<SaslAuthenticateResponse>
	{
		public SaslAuthenticateRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SaslAuthenticateRequest does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(36);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_authBytes.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<SaslAuthenticateRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslAuthenticateRequest(version);
			instance.AuthBytes = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslAuthenticateRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _authBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Bytes _authBytes = Bytes.Default;
		/// <summary>
		/// <para>The SASL authentication bytes from the client, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes AuthBytes 
		{
			get => _authBytes;
			private set 
			{
				_authBytes = value;
			}
		}

		/// <summary>
		/// <para>The SASL authentication bytes from the client, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateRequest WithAuthBytes(Bytes authBytes)
		{
			AuthBytes = authBytes;
			return this;
		}

		public SaslAuthenticateResponse Respond()
			=> new SaslAuthenticateResponse(Version);
	}

	public class SaslAuthenticateResponse : Message
	{
		public SaslAuthenticateResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SaslAuthenticateResponse does not support version {version}. Valid versions are: 0-2");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(36);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_authBytes.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_sessionLifetimeMs.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<SaslAuthenticateResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslAuthenticateResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.AuthBytes = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.SessionLifetimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslAuthenticateResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _authBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _sessionLifetimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Bytes _authBytes = Bytes.Default;
		/// <summary>
		/// <para>The SASL authentication bytes from the server, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes AuthBytes 
		{
			get => _authBytes;
			private set 
			{
				_authBytes = value;
			}
		}

		/// <summary>
		/// <para>The SASL authentication bytes from the server, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateResponse WithAuthBytes(Bytes authBytes)
		{
			AuthBytes = authBytes;
			return this;
		}

		private Int64 _sessionLifetimeMs = new Int64(0);
		/// <summary>
		/// <para>Number of milliseconds after which only re-authentication over the existing connection to create a new session can occur.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int64 SessionLifetimeMs 
		{
			get => _sessionLifetimeMs;
			private set 
			{
				_sessionLifetimeMs = value;
			}
		}

		/// <summary>
		/// <para>Number of milliseconds after which only re-authentication over the existing connection to create a new session can occur.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public SaslAuthenticateResponse WithSessionLifetimeMs(Int64 sessionLifetimeMs)
		{
			SessionLifetimeMs = sessionLifetimeMs;
			return this;
		}
	}

	public class SaslHandshakeRequest : Message, IRespond<SaslHandshakeResponse>
	{
		public SaslHandshakeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SaslHandshakeRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(17);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_mechanism.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<SaslHandshakeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslHandshakeRequest(version);
			instance.Mechanism = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslHandshakeRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _mechanism = String.Default;
		/// <summary>
		/// <para>The SASL mechanism chosen by the client.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Mechanism 
		{
			get => _mechanism;
			private set 
			{
				_mechanism = value;
			}
		}

		/// <summary>
		/// <para>The SASL mechanism chosen by the client.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslHandshakeRequest WithMechanism(String mechanism)
		{
			Mechanism = mechanism;
			return this;
		}

		public SaslHandshakeResponse Respond()
			=> new SaslHandshakeResponse(Version);
	}

	public class SaslHandshakeResponse : Message
	{
		public SaslHandshakeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SaslHandshakeResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = false;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(17);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_mechanismsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<SaslHandshakeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslHandshakeResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MechanismsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslHandshakeResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _mechanismsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslHandshakeResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<String> _mechanismsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The mechanisms enabled in the server.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> MechanismsCollection 
		{
			get => _mechanismsCollection;
			private set 
			{
				_mechanismsCollection = value;
			}
		}

		/// <summary>
		/// <para>The mechanisms enabled in the server.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslHandshakeResponse WithMechanismsCollection(Array<String> mechanismsCollection)
		{
			MechanismsCollection = mechanismsCollection;
			return this;
		}
	}

	public class ShareAcknowledgeRequest : Message, IRespond<ShareAcknowledgeResponse>
	{
		public ShareAcknowledgeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareAcknowledgeRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(79);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			_shareSessionEpoch.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareAcknowledgeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareAcknowledgeRequest(version);
			instance.GroupId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ShareSessionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<AcknowledgeTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AcknowledgeTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareAcknowledgeRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _shareSessionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _groupId = new NullableString(null);
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareAcknowledgeRequest WithGroupId(String? groupId)
		{
			GroupId = groupId;
			return this;
		}

		private NullableString _memberId = NullableString.Default;
		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeRequest WithMemberId(String? memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Int32 _shareSessionEpoch = Int32.Default;
		/// <summary>
		/// <para>The current share session epoch: 0 to open a share session; -1 to close it; otherwise increments for consecutive requests.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ShareSessionEpoch 
		{
			get => _shareSessionEpoch;
			private set 
			{
				_shareSessionEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current share session epoch: 0 to open a share session; -1 to close it; otherwise increments for consecutive requests.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeRequest WithShareSessionEpoch(Int32 shareSessionEpoch)
		{
			ShareSessionEpoch = shareSessionEpoch;
			return this;
		}

		private Array<AcknowledgeTopic> _topicsCollection = Array.Empty<AcknowledgeTopic>();
		/// <summary>
		/// <para>The topics containing records to acknowledge.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<AcknowledgeTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics containing records to acknowledge.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeRequest WithTopicsCollection(params Func<AcknowledgeTopic, AcknowledgeTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new AcknowledgeTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate AcknowledgeTopic CreateAcknowledgeTopic(AcknowledgeTopic field);

		/// <summary>
		/// <para>The topics containing records to acknowledge.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeRequest WithTopicsCollection(IEnumerable<CreateAcknowledgeTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new AcknowledgeTopic(Version)))
				.ToArray();
			return this;
		}

		public class AcknowledgeTopic : ISerialize
		{
			internal AcknowledgeTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<AcknowledgeTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AcknowledgeTopic(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<AcknowledgePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AcknowledgePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AcknowledgeTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AcknowledgeTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<AcknowledgePartition> _partitionsCollection = Array.Empty<AcknowledgePartition>();
			/// <summary>
			/// <para>The partitions containing records to acknowledge.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<AcknowledgePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions containing records to acknowledge.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AcknowledgeTopic WithPartitionsCollection(params Func<AcknowledgePartition, AcknowledgePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new AcknowledgePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate AcknowledgePartition CreateAcknowledgePartition(AcknowledgePartition field);

			/// <summary>
			/// <para>The partitions containing records to acknowledge.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AcknowledgeTopic WithPartitionsCollection(IEnumerable<CreateAcknowledgePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new AcknowledgePartition(Version)))
					.ToArray();
				return this;
			}

			public class AcknowledgePartition : ISerialize
			{
				internal AcknowledgePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_acknowledgementBatchesCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<AcknowledgePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AcknowledgePartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.AcknowledgementBatchesCollection = await Array<AcknowledgementBatch>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AcknowledgementBatch.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AcknowledgePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _acknowledgementBatchesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AcknowledgePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Array<AcknowledgementBatch> _acknowledgementBatchesCollection = Array.Empty<AcknowledgementBatch>();
				/// <summary>
				/// <para>Record batches to acknowledge.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<AcknowledgementBatch> AcknowledgementBatchesCollection 
				{
					get => _acknowledgementBatchesCollection;
					private set 
					{
						_acknowledgementBatchesCollection = value;
					}
				}

				/// <summary>
				/// <para>Record batches to acknowledge.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AcknowledgePartition WithAcknowledgementBatchesCollection(params Func<AcknowledgementBatch, AcknowledgementBatch>[] createFields)
				{
					AcknowledgementBatchesCollection = createFields
						.Select(createField => createField(new AcknowledgementBatch(Version)))
						.ToArray();
					return this;
				}

				public delegate AcknowledgementBatch CreateAcknowledgementBatch(AcknowledgementBatch field);

				/// <summary>
				/// <para>Record batches to acknowledge.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AcknowledgePartition WithAcknowledgementBatchesCollection(IEnumerable<CreateAcknowledgementBatch> createFields)
				{
					AcknowledgementBatchesCollection = createFields
						.Select(createField => createField(new AcknowledgementBatch(Version)))
						.ToArray();
					return this;
				}

				public class AcknowledgementBatch : ISerialize
				{
					internal AcknowledgementBatch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_firstOffset.GetSize(IsFlexibleVersion) +
						_lastOffset.GetSize(IsFlexibleVersion) +
						_acknowledgeTypesCollection.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<AcknowledgementBatch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new AcknowledgementBatch(version);
						instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.AcknowledgeTypesCollection = await Array<Int8>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for AcknowledgementBatch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _firstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _acknowledgeTypesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>First offset of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						private set 
						{
							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>First offset of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcknowledgementBatch WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}

					private Int64 _lastOffset = Int64.Default;
					/// <summary>
					/// <para>Last offset (inclusive) of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 LastOffset 
					{
						get => _lastOffset;
						private set 
						{
							_lastOffset = value;
						}
					}

					/// <summary>
					/// <para>Last offset (inclusive) of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcknowledgementBatch WithLastOffset(Int64 lastOffset)
					{
						LastOffset = lastOffset;
						return this;
					}

					private Array<Int8> _acknowledgeTypesCollection = Array.Empty<Int8>();
					/// <summary>
					/// <para>Array of acknowledge types - 0:Gap,1:Accept,2:Release,3:Reject.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Array<Int8> AcknowledgeTypesCollection 
					{
						get => _acknowledgeTypesCollection;
						private set 
						{
							_acknowledgeTypesCollection = value;
						}
					}

					/// <summary>
					/// <para>Array of acknowledge types - 0:Gap,1:Accept,2:Release,3:Reject.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcknowledgementBatch WithAcknowledgeTypesCollection(Array<Int8> acknowledgeTypesCollection)
					{
						AcknowledgeTypesCollection = acknowledgeTypesCollection;
						return this;
					}
				}
			}
		}

		public ShareAcknowledgeResponse Respond()
			=> new ShareAcknowledgeResponse(Version);
	}

	public class ShareAcknowledgeResponse : Message
	{
		public ShareAcknowledgeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareAcknowledgeResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(79);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			_nodeEndpointsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareAcknowledgeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareAcknowledgeResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Array<ShareAcknowledgeTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ShareAcknowledgeTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.NodeEndpointsCollection = await Map<Int32, NodeEndpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => NodeEndpoint.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.NodeId, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareAcknowledgeResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _nodeEndpointsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = new NullableString(null);
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareAcknowledgeResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<ShareAcknowledgeTopicResponse> _responsesCollection = Array.Empty<ShareAcknowledgeTopicResponse>();
		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ShareAcknowledgeTopicResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeResponse WithResponsesCollection(params Func<ShareAcknowledgeTopicResponse, ShareAcknowledgeTopicResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new ShareAcknowledgeTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate ShareAcknowledgeTopicResponse CreateShareAcknowledgeTopicResponse(ShareAcknowledgeTopicResponse field);

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeResponse WithResponsesCollection(IEnumerable<CreateShareAcknowledgeTopicResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new ShareAcknowledgeTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public class ShareAcknowledgeTopicResponse : ISerialize
		{
			internal ShareAcknowledgeTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ShareAcknowledgeTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ShareAcknowledgeTopicResponse(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareAcknowledgeTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ShareAcknowledgeTopicResponse WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ShareAcknowledgeTopicResponse WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ShareAcknowledgeTopicResponse WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					_currentLeader.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _currentLeader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionData WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					private set 
					{
						_currentLeader = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCurrentLeader(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(new LeaderIdAndEpoch(Version));
					return this;
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_leaderId.GetSize(IsFlexibleVersion) +
						_leaderEpoch.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _leaderId = Int32.Default;
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						private set 
						{
							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = Int32.Default;
					/// <summary>
					/// <para>The latest known leader epoch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						private set 
						{
							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}
			}
		}

		private Map<Int32, NodeEndpoint> _nodeEndpointsCollection = Map<Int32, NodeEndpoint>.Default;
		/// <summary>
		/// <para>Endpoints for all current leaders enumerated in PartitionData with error NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int32, NodeEndpoint> NodeEndpointsCollection 
		{
			get => _nodeEndpointsCollection;
			private set 
			{
				_nodeEndpointsCollection = value;
			}
		}

		/// <summary>
		/// <para>Endpoints for all current leaders enumerated in PartitionData with error NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeResponse WithNodeEndpointsCollection(params Func<NodeEndpoint, NodeEndpoint>[] createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public delegate NodeEndpoint CreateNodeEndpoint(NodeEndpoint field);

		/// <summary>
		/// <para>Endpoints for all current leaders enumerated in PartitionData with error NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareAcknowledgeResponse WithNodeEndpointsCollection(IEnumerable<CreateNodeEndpoint> createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public class NodeEndpoint : ISerialize
		{
			internal NodeEndpoint(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_nodeId.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				_rack.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<NodeEndpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new NodeEndpoint(version);
				instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for NodeEndpoint is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public NodeEndpoint WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public NodeEndpoint WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public NodeEndpoint WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private NullableString _rack = new NullableString(null);
			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public NodeEndpoint WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}
	}

	public class ShareFetchRequest : Message, IRespond<ShareFetchResponse>
	{
		public ShareFetchRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareFetchRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(78);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			_shareSessionEpoch.GetSize(IsFlexibleVersion) +
			_maxWaitMs.GetSize(IsFlexibleVersion) +
			_minBytes.GetSize(IsFlexibleVersion) +
			_maxBytes.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_forgottenTopicsDataCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareFetchRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareFetchRequest(version);
			instance.GroupId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ShareSessionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MaxWaitMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MinBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<FetchTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.ForgottenTopicsDataCollection = await Array<ForgottenTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ForgottenTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareFetchRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _shareSessionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _maxWaitMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _minBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _maxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _forgottenTopicsDataCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _groupId = new NullableString(null);
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareFetchRequest WithGroupId(String? groupId)
		{
			GroupId = groupId;
			return this;
		}

		private NullableString _memberId = NullableString.Default;
		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithMemberId(String? memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Int32 _shareSessionEpoch = Int32.Default;
		/// <summary>
		/// <para>The current share session epoch: 0 to open a share session; -1 to close it; otherwise increments for consecutive requests.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ShareSessionEpoch 
		{
			get => _shareSessionEpoch;
			private set 
			{
				_shareSessionEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current share session epoch: 0 to open a share session; -1 to close it; otherwise increments for consecutive requests.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithShareSessionEpoch(Int32 shareSessionEpoch)
		{
			ShareSessionEpoch = shareSessionEpoch;
			return this;
		}

		private Int32 _maxWaitMs = Int32.Default;
		/// <summary>
		/// <para>The maximum time in milliseconds to wait for the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MaxWaitMs 
		{
			get => _maxWaitMs;
			private set 
			{
				_maxWaitMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum time in milliseconds to wait for the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithMaxWaitMs(Int32 maxWaitMs)
		{
			MaxWaitMs = maxWaitMs;
			return this;
		}

		private Int32 _minBytes = Int32.Default;
		/// <summary>
		/// <para>The minimum bytes to accumulate in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MinBytes 
		{
			get => _minBytes;
			private set 
			{
				_minBytes = value;
			}
		}

		/// <summary>
		/// <para>The minimum bytes to accumulate in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithMinBytes(Int32 minBytes)
		{
			MinBytes = minBytes;
			return this;
		}

		private Int32 _maxBytes = new Int32(0x7fffffff);
		/// <summary>
		/// <para>The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public Int32 MaxBytes 
		{
			get => _maxBytes;
			private set 
			{
				_maxBytes = value;
			}
		}

		/// <summary>
		/// <para>The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public ShareFetchRequest WithMaxBytes(Int32 maxBytes)
		{
			MaxBytes = maxBytes;
			return this;
		}

		private Array<FetchTopic> _topicsCollection = Array.Empty<FetchTopic>();
		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<FetchTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithTopicsCollection(params Func<FetchTopic, FetchTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new FetchTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate FetchTopic CreateFetchTopic(FetchTopic field);

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithTopicsCollection(IEnumerable<CreateFetchTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new FetchTopic(Version)))
				.ToArray();
			return this;
		}

		public class FetchTopic : ISerialize
		{
			internal FetchTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<FetchTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FetchTopic(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<FetchPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<FetchPartition> _partitionsCollection = Array.Empty<FetchPartition>();
			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<FetchPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchTopic WithPartitionsCollection(params Func<FetchPartition, FetchPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new FetchPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate FetchPartition CreateFetchPartition(FetchPartition field);

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchTopic WithPartitionsCollection(IEnumerable<CreateFetchPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new FetchPartition(Version)))
					.ToArray();
				return this;
			}

			public class FetchPartition : ISerialize
			{
				internal FetchPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_partitionMaxBytes.GetSize(IsFlexibleVersion) +
					_acknowledgementBatchesCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<FetchPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new FetchPartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionMaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.AcknowledgementBatchesCollection = await Array<AcknowledgementBatch>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AcknowledgementBatch.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionMaxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _acknowledgementBatchesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _partitionMaxBytes = Int32.Default;
				/// <summary>
				/// <para>The maximum bytes to fetch from this partition. 0 when only acknowledgement with no fetching is required. See KIP-74 for cases where this limit may not be honored.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionMaxBytes 
				{
					get => _partitionMaxBytes;
					private set 
					{
						_partitionMaxBytes = value;
					}
				}

				/// <summary>
				/// <para>The maximum bytes to fetch from this partition. 0 when only acknowledgement with no fetching is required. See KIP-74 for cases where this limit may not be honored.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithPartitionMaxBytes(Int32 partitionMaxBytes)
				{
					PartitionMaxBytes = partitionMaxBytes;
					return this;
				}

				private Array<AcknowledgementBatch> _acknowledgementBatchesCollection = Array.Empty<AcknowledgementBatch>();
				/// <summary>
				/// <para>Record batches to acknowledge.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<AcknowledgementBatch> AcknowledgementBatchesCollection 
				{
					get => _acknowledgementBatchesCollection;
					private set 
					{
						_acknowledgementBatchesCollection = value;
					}
				}

				/// <summary>
				/// <para>Record batches to acknowledge.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithAcknowledgementBatchesCollection(params Func<AcknowledgementBatch, AcknowledgementBatch>[] createFields)
				{
					AcknowledgementBatchesCollection = createFields
						.Select(createField => createField(new AcknowledgementBatch(Version)))
						.ToArray();
					return this;
				}

				public delegate AcknowledgementBatch CreateAcknowledgementBatch(AcknowledgementBatch field);

				/// <summary>
				/// <para>Record batches to acknowledge.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithAcknowledgementBatchesCollection(IEnumerable<CreateAcknowledgementBatch> createFields)
				{
					AcknowledgementBatchesCollection = createFields
						.Select(createField => createField(new AcknowledgementBatch(Version)))
						.ToArray();
					return this;
				}

				public class AcknowledgementBatch : ISerialize
				{
					internal AcknowledgementBatch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_firstOffset.GetSize(IsFlexibleVersion) +
						_lastOffset.GetSize(IsFlexibleVersion) +
						_acknowledgeTypesCollection.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<AcknowledgementBatch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new AcknowledgementBatch(version);
						instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.AcknowledgeTypesCollection = await Array<Int8>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for AcknowledgementBatch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _firstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _acknowledgeTypesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>First offset of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						private set 
						{
							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>First offset of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcknowledgementBatch WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}

					private Int64 _lastOffset = Int64.Default;
					/// <summary>
					/// <para>Last offset (inclusive) of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 LastOffset 
					{
						get => _lastOffset;
						private set 
						{
							_lastOffset = value;
						}
					}

					/// <summary>
					/// <para>Last offset (inclusive) of batch of records to acknowledge.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcknowledgementBatch WithLastOffset(Int64 lastOffset)
					{
						LastOffset = lastOffset;
						return this;
					}

					private Array<Int8> _acknowledgeTypesCollection = Array.Empty<Int8>();
					/// <summary>
					/// <para>Array of acknowledge types - 0:Gap,1:Accept,2:Release,3:Reject.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Array<Int8> AcknowledgeTypesCollection 
					{
						get => _acknowledgeTypesCollection;
						private set 
						{
							_acknowledgeTypesCollection = value;
						}
					}

					/// <summary>
					/// <para>Array of acknowledge types - 0:Gap,1:Accept,2:Release,3:Reject.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcknowledgementBatch WithAcknowledgeTypesCollection(Array<Int8> acknowledgeTypesCollection)
					{
						AcknowledgeTypesCollection = acknowledgeTypesCollection;
						return this;
					}
				}
			}
		}

		private Array<ForgottenTopic> _forgottenTopicsDataCollection = Array.Empty<ForgottenTopic>();
		/// <summary>
		/// <para>The partitions to remove from this share session.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ForgottenTopic> ForgottenTopicsDataCollection 
		{
			get => _forgottenTopicsDataCollection;
			private set 
			{
				_forgottenTopicsDataCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions to remove from this share session.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithForgottenTopicsDataCollection(params Func<ForgottenTopic, ForgottenTopic>[] createFields)
		{
			ForgottenTopicsDataCollection = createFields
				.Select(createField => createField(new ForgottenTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate ForgottenTopic CreateForgottenTopic(ForgottenTopic field);

		/// <summary>
		/// <para>The partitions to remove from this share session.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchRequest WithForgottenTopicsDataCollection(IEnumerable<CreateForgottenTopic> createFields)
		{
			ForgottenTopicsDataCollection = createFields
				.Select(createField => createField(new ForgottenTopic(Version)))
				.ToArray();
			return this;
		}

		public class ForgottenTopic : ISerialize
		{
			internal ForgottenTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ForgottenTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ForgottenTopic(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ForgottenTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ForgottenTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions indexes to forget.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions indexes to forget.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ForgottenTopic WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public ShareFetchResponse Respond()
			=> new ShareFetchResponse(Version);
	}

	public class ShareFetchResponse : Message
	{
		public ShareFetchResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareFetchResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(78);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_responsesCollection.GetSize(IsFlexibleVersion) +
			_nodeEndpointsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareFetchResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareFetchResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResponsesCollection = await Array<ShareFetchableTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ShareFetchableTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.NodeEndpointsCollection = await Map<Int32, NodeEndpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => NodeEndpoint.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.NodeId, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareFetchResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _responsesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _nodeEndpointsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = new NullableString(null);
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareFetchResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Array<ShareFetchableTopicResponse> _responsesCollection = Array.Empty<ShareFetchableTopicResponse>();
		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<ShareFetchableTopicResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			private set 
			{
				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchResponse WithResponsesCollection(params Func<ShareFetchableTopicResponse, ShareFetchableTopicResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new ShareFetchableTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public delegate ShareFetchableTopicResponse CreateShareFetchableTopicResponse(ShareFetchableTopicResponse field);

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchResponse WithResponsesCollection(IEnumerable<CreateShareFetchableTopicResponse> createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(new ShareFetchableTopicResponse(Version)))
				.ToArray();
			return this;
		}

		public class ShareFetchableTopicResponse : ISerialize
		{
			internal ShareFetchableTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<ShareFetchableTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ShareFetchableTopicResponse(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareFetchableTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ShareFetchableTopicResponse WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ShareFetchableTopicResponse WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ShareFetchableTopicResponse WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					_acknowledgeErrorCode.GetSize(IsFlexibleVersion) +
					_acknowledgeErrorMessage.GetSize(IsFlexibleVersion) +
					_currentLeader.GetSize(IsFlexibleVersion) +
					_records.GetSize(IsFlexibleVersion) +
					_acquiredRecordsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.AcknowledgeErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.AcknowledgeErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
					instance.Records = await NullableRecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.AcquiredRecordsCollection = await Array<AcquiredRecords>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AcquiredRecords.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _acknowledgeErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _acknowledgeErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _currentLeader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _records.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _acquiredRecordsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The fetch error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The fetch error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The fetch error message, or null if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The fetch error message, or null if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionData WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Int16 _acknowledgeErrorCode = Int16.Default;
				/// <summary>
				/// <para>The acknowledge error code, or 0 if there was no acknowledge error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 AcknowledgeErrorCode 
				{
					get => _acknowledgeErrorCode;
					private set 
					{
						_acknowledgeErrorCode = value;
					}
				}

				/// <summary>
				/// <para>The acknowledge error code, or 0 if there was no acknowledge error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithAcknowledgeErrorCode(Int16 acknowledgeErrorCode)
				{
					AcknowledgeErrorCode = acknowledgeErrorCode;
					return this;
				}

				private NullableString _acknowledgeErrorMessage = new NullableString(null);
				/// <summary>
				/// <para>The acknowledge error message, or null if there was no acknowledge error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? AcknowledgeErrorMessage 
				{
					get => _acknowledgeErrorMessage;
					private set 
					{
						_acknowledgeErrorMessage = value;
					}
				}

				/// <summary>
				/// <para>The acknowledge error message, or null if there was no acknowledge error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionData WithAcknowledgeErrorMessage(String? acknowledgeErrorMessage)
				{
					AcknowledgeErrorMessage = acknowledgeErrorMessage;
					return this;
				}

				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					private set 
					{
						_currentLeader = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCurrentLeader(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(new LeaderIdAndEpoch(Version));
					return this;
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_leaderId.GetSize(IsFlexibleVersion) +
						_leaderEpoch.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _leaderId = Int32.Default;
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						private set 
						{
							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = Int32.Default;
					/// <summary>
					/// <para>The latest known leader epoch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						private set 
						{
							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}

				private NullableRecordBatch _records = NullableRecordBatch.Default;
				/// <summary>
				/// <para>The record data.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public RecordBatch? Records 
				{
					get => _records;
					private set 
					{
						_records = value;
					}
				}

				/// <summary>
				/// <para>The record data.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithRecords(RecordBatch? records)
				{
					Records = records;
					return this;
				}

				private Array<AcquiredRecords> _acquiredRecordsCollection = Array.Empty<AcquiredRecords>();
				/// <summary>
				/// <para>The acquired records.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<AcquiredRecords> AcquiredRecordsCollection 
				{
					get => _acquiredRecordsCollection;
					private set 
					{
						_acquiredRecordsCollection = value;
					}
				}

				/// <summary>
				/// <para>The acquired records.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithAcquiredRecordsCollection(params Func<AcquiredRecords, AcquiredRecords>[] createFields)
				{
					AcquiredRecordsCollection = createFields
						.Select(createField => createField(new AcquiredRecords(Version)))
						.ToArray();
					return this;
				}

				public delegate AcquiredRecords CreateAcquiredRecords(AcquiredRecords field);

				/// <summary>
				/// <para>The acquired records.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithAcquiredRecordsCollection(IEnumerable<CreateAcquiredRecords> createFields)
				{
					AcquiredRecordsCollection = createFields
						.Select(createField => createField(new AcquiredRecords(Version)))
						.ToArray();
					return this;
				}

				public class AcquiredRecords : ISerialize
				{
					internal AcquiredRecords(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_firstOffset.GetSize(IsFlexibleVersion) +
						_lastOffset.GetSize(IsFlexibleVersion) +
						_deliveryCount.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<AcquiredRecords> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new AcquiredRecords(version);
						instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.DeliveryCount = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for AcquiredRecords is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _firstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _deliveryCount.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>The earliest offset in this batch of acquired records.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						private set 
						{
							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>The earliest offset in this batch of acquired records.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcquiredRecords WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}

					private Int64 _lastOffset = Int64.Default;
					/// <summary>
					/// <para>The last offset of this batch of acquired records.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 LastOffset 
					{
						get => _lastOffset;
						private set 
						{
							_lastOffset = value;
						}
					}

					/// <summary>
					/// <para>The last offset of this batch of acquired records.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcquiredRecords WithLastOffset(Int64 lastOffset)
					{
						LastOffset = lastOffset;
						return this;
					}

					private Int16 _deliveryCount = Int16.Default;
					/// <summary>
					/// <para>The delivery count of this batch of acquired records.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int16 DeliveryCount 
					{
						get => _deliveryCount;
						private set 
						{
							_deliveryCount = value;
						}
					}

					/// <summary>
					/// <para>The delivery count of this batch of acquired records.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public AcquiredRecords WithDeliveryCount(Int16 deliveryCount)
					{
						DeliveryCount = deliveryCount;
						return this;
					}
				}
			}
		}

		private Map<Int32, NodeEndpoint> _nodeEndpointsCollection = Map<Int32, NodeEndpoint>.Default;
		/// <summary>
		/// <para>Endpoints for all current leaders enumerated in PartitionData with error NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<Int32, NodeEndpoint> NodeEndpointsCollection 
		{
			get => _nodeEndpointsCollection;
			private set 
			{
				_nodeEndpointsCollection = value;
			}
		}

		/// <summary>
		/// <para>Endpoints for all current leaders enumerated in PartitionData with error NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchResponse WithNodeEndpointsCollection(params Func<NodeEndpoint, NodeEndpoint>[] createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public delegate NodeEndpoint CreateNodeEndpoint(NodeEndpoint field);

		/// <summary>
		/// <para>Endpoints for all current leaders enumerated in PartitionData with error NOT_LEADER_OR_FOLLOWER.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareFetchResponse WithNodeEndpointsCollection(IEnumerable<CreateNodeEndpoint> createFields)
		{
			NodeEndpointsCollection = createFields
				.Select(createField => createField(new NodeEndpoint(Version)))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		public class NodeEndpoint : ISerialize
		{
			internal NodeEndpoint(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_nodeId.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				_rack.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<NodeEndpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new NodeEndpoint(version);
				instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for NodeEndpoint is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _nodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				private set 
				{
					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the associated node.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public NodeEndpoint WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The node's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public NodeEndpoint WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The node's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public NodeEndpoint WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private NullableString _rack = new NullableString(null);
			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the node, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public NodeEndpoint WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}
	}

	public class ShareGroupDescribeRequest : Message, IRespond<ShareGroupDescribeResponse>
	{
		public ShareGroupDescribeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareGroupDescribeRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(77);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupIdsCollection.GetSize(IsFlexibleVersion) +
			_includeAuthorizedOperations.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareGroupDescribeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareGroupDescribeRequest(version);
			instance.GroupIdsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.IncludeAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareGroupDescribeRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupIdsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _includeAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<String> _groupIdsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The ids of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> GroupIdsCollection 
		{
			get => _groupIdsCollection;
			private set 
			{
				_groupIdsCollection = value;
			}
		}

		/// <summary>
		/// <para>The ids of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupDescribeRequest WithGroupIdsCollection(Array<String> groupIdsCollection)
		{
			GroupIdsCollection = groupIdsCollection;
			return this;
		}

		private Boolean _includeAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean IncludeAuthorizedOperations 
		{
			get => _includeAuthorizedOperations;
			private set 
			{
				_includeAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupDescribeRequest WithIncludeAuthorizedOperations(Boolean includeAuthorizedOperations)
		{
			IncludeAuthorizedOperations = includeAuthorizedOperations;
			return this;
		}

		public ShareGroupDescribeResponse Respond()
			=> new ShareGroupDescribeResponse(Version);
	}

	public class ShareGroupDescribeResponse : Message
	{
		public ShareGroupDescribeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareGroupDescribeResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(77);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_groupsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareGroupDescribeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareGroupDescribeResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GroupsCollection = await Array<DescribedGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareGroupDescribeResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _groupsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupDescribeResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<DescribedGroup> _groupsCollection = Array.Empty<DescribedGroup>();
		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<DescribedGroup> GroupsCollection 
		{
			get => _groupsCollection;
			private set 
			{
				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupDescribeResponse WithGroupsCollection(params Func<DescribedGroup, DescribedGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new DescribedGroup(Version)))
				.ToArray();
			return this;
		}

		public delegate DescribedGroup CreateDescribedGroup(DescribedGroup field);

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupDescribeResponse WithGroupsCollection(IEnumerable<CreateDescribedGroup> createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(new DescribedGroup(Version)))
				.ToArray();
			return this;
		}

		public class DescribedGroup : ISerialize
		{
			internal DescribedGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				_groupId.GetSize(IsFlexibleVersion) +
				_groupState.GetSize(IsFlexibleVersion) +
				_groupEpoch.GetSize(IsFlexibleVersion) +
				_assignmentEpoch.GetSize(IsFlexibleVersion) +
				_assignorName.GetSize(IsFlexibleVersion) +
				_membersCollection.GetSize(IsFlexibleVersion) +
				_authorizedOperations.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<DescribedGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribedGroup(version);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupState = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.GroupEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AssignmentEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.AssignorName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MembersCollection = await Array<Member>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Member.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.AuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedGroup is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _groupEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignmentEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignorName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _membersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _authorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = new NullableString(null);
			/// <summary>
			/// <para>The top-level error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The top-level error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DescribedGroup WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				private set 
				{
					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private String _groupState = String.Default;
			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupState 
			{
				get => _groupState;
				private set 
				{
					_groupState = value;
				}
			}

			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupState(String groupState)
			{
				GroupState = groupState;
				return this;
			}

			private Int32 _groupEpoch = Int32.Default;
			/// <summary>
			/// <para>The group epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 GroupEpoch 
			{
				get => _groupEpoch;
				private set 
				{
					_groupEpoch = value;
				}
			}

			/// <summary>
			/// <para>The group epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupEpoch(Int32 groupEpoch)
			{
				GroupEpoch = groupEpoch;
				return this;
			}

			private Int32 _assignmentEpoch = Int32.Default;
			/// <summary>
			/// <para>The assignment epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 AssignmentEpoch 
			{
				get => _assignmentEpoch;
				private set 
				{
					_assignmentEpoch = value;
				}
			}

			/// <summary>
			/// <para>The assignment epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithAssignmentEpoch(Int32 assignmentEpoch)
			{
				AssignmentEpoch = assignmentEpoch;
				return this;
			}

			private String _assignorName = String.Default;
			/// <summary>
			/// <para>The selected assignor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String AssignorName 
			{
				get => _assignorName;
				private set 
				{
					_assignorName = value;
				}
			}

			/// <summary>
			/// <para>The selected assignor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithAssignorName(String assignorName)
			{
				AssignorName = assignorName;
				return this;
			}

			private Array<Member> _membersCollection = Array.Empty<Member>();
			/// <summary>
			/// <para>The members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Member> MembersCollection 
			{
				get => _membersCollection;
				private set 
				{
					_membersCollection = value;
				}
			}

			/// <summary>
			/// <para>The members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(params Func<Member, Member>[] createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(new Member(Version)))
					.ToArray();
				return this;
			}

			public delegate Member CreateMember(Member field);

			/// <summary>
			/// <para>The members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(IEnumerable<CreateMember> createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(new Member(Version)))
					.ToArray();
				return this;
			}

			public class Member : ISerialize
			{
				internal Member(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_memberId.GetSize(IsFlexibleVersion) +
					_rackId.GetSize(IsFlexibleVersion) +
					_memberEpoch.GetSize(IsFlexibleVersion) +
					_clientId.GetSize(IsFlexibleVersion) +
					_clientHost.GetSize(IsFlexibleVersion) +
					_subscribedTopicNamesCollection.GetSize(IsFlexibleVersion) +
					_assignment.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<Member> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new Member(version);
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.RackId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ClientId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ClientHost = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.SubscribedTopicNamesCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					instance.Assignment_ = await Assignment.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for Member is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _rackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _clientId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _clientHost.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _subscribedTopicNamesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _memberId = String.Default;
				/// <summary>
				/// <para>The member ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String MemberId 
				{
					get => _memberId;
					private set 
					{
						_memberId = value;
					}
				}

				/// <summary>
				/// <para>The member ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithMemberId(String memberId)
				{
					MemberId = memberId;
					return this;
				}

				private NullableString _rackId = new NullableString(null);
				/// <summary>
				/// <para>The member rack ID.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? RackId 
				{
					get => _rackId;
					private set 
					{
						_rackId = value;
					}
				}

				/// <summary>
				/// <para>The member rack ID.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Member WithRackId(String? rackId)
				{
					RackId = rackId;
					return this;
				}

				private Int32 _memberEpoch = Int32.Default;
				/// <summary>
				/// <para>The current member epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 MemberEpoch 
				{
					get => _memberEpoch;
					private set 
					{
						_memberEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current member epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithMemberEpoch(Int32 memberEpoch)
				{
					MemberEpoch = memberEpoch;
					return this;
				}

				private String _clientId = String.Default;
				/// <summary>
				/// <para>The client ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientId 
				{
					get => _clientId;
					private set 
					{
						_clientId = value;
					}
				}

				/// <summary>
				/// <para>The client ID.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithClientId(String clientId)
				{
					ClientId = clientId;
					return this;
				}

				private String _clientHost = String.Default;
				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientHost 
				{
					get => _clientHost;
					private set 
					{
						_clientHost = value;
					}
				}

				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithClientHost(String clientHost)
				{
					ClientHost = clientHost;
					return this;
				}

				private Array<String> _subscribedTopicNamesCollection = Array.Empty<String>();
				/// <summary>
				/// <para>The subscribed topic names.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<String> SubscribedTopicNamesCollection 
				{
					get => _subscribedTopicNamesCollection;
					private set 
					{
						_subscribedTopicNamesCollection = value;
					}
				}

				/// <summary>
				/// <para>The subscribed topic names.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithSubscribedTopicNamesCollection(Array<String> subscribedTopicNamesCollection)
				{
					SubscribedTopicNamesCollection = subscribedTopicNamesCollection;
					return this;
				}

				private Assignment _assignment = default!;
				/// <summary>
				/// <para>The current assignment.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Assignment Assignment_ 
				{
					get => _assignment;
					private set 
					{
						_assignment = value;
					}
				}

				/// <summary>
				/// <para>The current assignment.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Member WithAssignment_(Assignment assignment)
				{
					Assignment_ = assignment;
					return this;
				}
			}

			private Int32 _authorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 AuthorizedOperations 
			{
				get => _authorizedOperations;
				private set 
				{
					_authorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public DescribedGroup WithAuthorizedOperations(Int32 authorizedOperations)
			{
				AuthorizedOperations = authorizedOperations;
				return this;
			}
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public class Assignment : ISerialize
		{
			internal Assignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicPartitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Assignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Assignment(version);
				instance.TopicPartitionsCollection = await Array<TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Assignment is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Array<TopicPartitions> _topicPartitionsCollection = Array.Empty<TopicPartitions>();
			/// <summary>
			/// <para>The assigned topic-partitions to the member.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TopicPartitions> TopicPartitionsCollection 
			{
				get => _topicPartitionsCollection;
				private set 
				{
					_topicPartitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The assigned topic-partitions to the member.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Assignment WithTopicPartitionsCollection(Array<TopicPartitions> topicPartitionsCollection)
			{
				TopicPartitionsCollection = topicPartitionsCollection;
				return this;
			}
		}
	}

	public class ShareGroupHeartbeatRequest : Message, IRespond<ShareGroupHeartbeatResponse>
	{
		public ShareGroupHeartbeatRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareGroupHeartbeatRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(76);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			_memberEpoch.GetSize(IsFlexibleVersion) +
			_rackId.GetSize(IsFlexibleVersion) +
			_subscribedTopicNamesCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareGroupHeartbeatRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareGroupHeartbeatRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.RackId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.SubscribedTopicNamesCollection = await NullableArray<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareGroupHeartbeatRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _rackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _subscribedTopicNamesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID generated by the coordinator. The member ID must be kept during the entire lifetime of the member.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID generated by the coordinator. The member ID must be kept during the entire lifetime of the member.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Int32 _memberEpoch = Int32.Default;
		/// <summary>
		/// <para>The current member epoch; 0 to join the group; -1 to leave the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MemberEpoch 
		{
			get => _memberEpoch;
			private set 
			{
				_memberEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current member epoch; 0 to join the group; -1 to leave the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatRequest WithMemberEpoch(Int32 memberEpoch)
		{
			MemberEpoch = memberEpoch;
			return this;
		}

		private NullableString _rackId = new NullableString(null);
		/// <summary>
		/// <para>null if not provided or if it didn't change since the last heartbeat; the rack ID of consumer otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? RackId 
		{
			get => _rackId;
			private set 
			{
				_rackId = value;
			}
		}

		/// <summary>
		/// <para>null if not provided or if it didn't change since the last heartbeat; the rack ID of consumer otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareGroupHeartbeatRequest WithRackId(String? rackId)
		{
			RackId = rackId;
			return this;
		}

		private NullableArray<String> _subscribedTopicNamesCollection = new NullableArray<String>(null);
		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the subscribed topic names otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Array<String>? SubscribedTopicNamesCollection 
		{
			get => _subscribedTopicNamesCollection;
			private set 
			{
				_subscribedTopicNamesCollection = value;
			}
		}

		/// <summary>
		/// <para>null if it didn't change since the last heartbeat; the subscribed topic names otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareGroupHeartbeatRequest WithSubscribedTopicNamesCollection(Array<String>? subscribedTopicNamesCollection)
		{
			SubscribedTopicNamesCollection = subscribedTopicNamesCollection;
			return this;
		}

		public ShareGroupHeartbeatResponse Respond()
			=> new ShareGroupHeartbeatResponse(Version);
	}

	public class ShareGroupHeartbeatResponse : Message
	{
		public ShareGroupHeartbeatResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ShareGroupHeartbeatResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(76);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			_memberEpoch.GetSize(IsFlexibleVersion) +
			_heartbeatIntervalMs.GetSize(IsFlexibleVersion) +
			_assignment.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<ShareGroupHeartbeatResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ShareGroupHeartbeatResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.HeartbeatIntervalMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Assignment_ = await Nullable<Assignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Assignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ShareGroupHeartbeatResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _heartbeatIntervalMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = new NullableString(null);
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private NullableString _memberId = new NullableString(null);
		/// <summary>
		/// <para>The member ID generated by the coordinator. Only provided when the member joins with MemberEpoch == 0.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID generated by the coordinator. Only provided when the member joins with MemberEpoch == 0.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithMemberId(String? memberId)
		{
			MemberId = memberId;
			return this;
		}

		private Int32 _memberEpoch = Int32.Default;
		/// <summary>
		/// <para>The member epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MemberEpoch 
		{
			get => _memberEpoch;
			private set 
			{
				_memberEpoch = value;
			}
		}

		/// <summary>
		/// <para>The member epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithMemberEpoch(Int32 memberEpoch)
		{
			MemberEpoch = memberEpoch;
			return this;
		}

		private Int32 _heartbeatIntervalMs = Int32.Default;
		/// <summary>
		/// <para>The heartbeat interval in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 HeartbeatIntervalMs 
		{
			get => _heartbeatIntervalMs;
			private set 
			{
				_heartbeatIntervalMs = value;
			}
		}

		/// <summary>
		/// <para>The heartbeat interval in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithHeartbeatIntervalMs(Int32 heartbeatIntervalMs)
		{
			HeartbeatIntervalMs = heartbeatIntervalMs;
			return this;
		}

		private Nullable<Assignment> _assignment = new Nullable<Assignment>(null);
		/// <summary>
		/// <para>null if not provided; the assignment otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Assignment? Assignment_ 
		{
			get => _assignment;
			private set 
			{
				_assignment = value;
			}
		}

		/// <summary>
		/// <para>null if not provided; the assignment otherwise.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ShareGroupHeartbeatResponse WithAssignment_(Func<Assignment?, Assignment?> createField)
		{
			Assignment_ = createField(new Assignment(Version));
			return this;
		}

		public class Assignment : ISerialize
		{
			internal Assignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicPartitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Assignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Assignment(version);
				instance.TopicPartitionsCollection = await Array<TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Assignment is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Array<TopicPartitions> _topicPartitionsCollection = Array.Empty<TopicPartitions>();
			/// <summary>
			/// <para>The partitions assigned to the member.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TopicPartitions> TopicPartitionsCollection 
			{
				get => _topicPartitionsCollection;
				private set 
				{
					_topicPartitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions assigned to the member.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Assignment WithTopicPartitionsCollection(Array<TopicPartitions> topicPartitionsCollection)
			{
				TopicPartitionsCollection = topicPartitionsCollection;
				return this;
			}
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}
	}

	public class StopReplicaRequest : Message, IRespond<StopReplicaResponse>
	{
		public StopReplicaRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"StopReplicaRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(5);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_controllerId.GetSize(IsFlexibleVersion) +
			(Version >= 4 ? 
				_isKRaftController.GetSize(IsFlexibleVersion):
				0) +
			_controllerEpoch.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_brokerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 2 ? 
				_deletePartitions.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 0 ? 
				_ungroupedPartitionsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 1 && Version <= 2 ? 
				_topicsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_topicStatesCollection.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<StopReplicaRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new StopReplicaRequest(version);
			instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 4) 
				instance.IsKRaftController = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 2) 
				instance.DeletePartitions = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 0) 
				instance.UngroupedPartitionsCollection = await Array<StopReplicaPartitionV0>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaPartitionV0.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1 && instance.Version <= 2) 
				instance.TopicsCollection = await Array<StopReplicaTopicV1>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaTopicV1.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.TopicStatesCollection = await Array<StopReplicaTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _controllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 4)
				await _isKRaftController.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _controllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 2)
				await _deletePartitions.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 0)
				await _ungroupedPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1 && Version <= 2)
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _topicStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			private set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Boolean _isKRaftController = new Boolean(false);
		/// <summary>
		/// <para>If KRaft controller id is used during migration. See KIP-866</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IsKRaftController 
		{
			get => _isKRaftController;
			private set 
			{
				if (Version >= 4 == false)
					throw new UnsupportedVersionException($"IsKRaftController does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");

				_isKRaftController = value;
			}
		}

		/// <summary>
		/// <para>If KRaft controller id is used during migration. See KIP-866</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: false</para>
		/// </summary>
		public StopReplicaRequest WithIsKRaftController(Boolean isKRaftController)
		{
			IsKRaftController = isKRaftController;
			return this;
		}

		private Int32 _controllerEpoch = Int32.Default;
		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerEpoch 
		{
			get => _controllerEpoch;
			private set 
			{
				_controllerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaRequest WithControllerEpoch(Int32 controllerEpoch)
		{
			ControllerEpoch = controllerEpoch;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public StopReplicaRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Boolean _deletePartitions = Boolean.Default;
		/// <summary>
		/// <para>Whether these partitions should be deleted.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public Boolean DeletePartitions 
		{
			get => _deletePartitions;
			private set 
			{
				if (Version >= 0 && Version <= 2 == false)
					throw new UnsupportedVersionException($"DeletePartitions does not support version {Version} and has been defined as not ignorable. Supported versions: 0-2");

				_deletePartitions = value;
			}
		}

		/// <summary>
		/// <para>Whether these partitions should be deleted.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public StopReplicaRequest WithDeletePartitions(Boolean deletePartitions)
		{
			DeletePartitions = deletePartitions;
			return this;
		}

		private Array<StopReplicaPartitionV0> _ungroupedPartitionsCollection = Array.Empty<StopReplicaPartitionV0>();
		/// <summary>
		/// <para>The partitions to stop.</para>
		/// <para>Versions: 0</para>
		/// </summary>
		public Array<StopReplicaPartitionV0> UngroupedPartitionsCollection 
		{
			get => _ungroupedPartitionsCollection;
			private set 
			{
				if (Version >= 0 && Version <= 0 == false)
					throw new UnsupportedVersionException($"UngroupedPartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

				_ungroupedPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions to stop.</para>
		/// <para>Versions: 0</para>
		/// </summary>
		public StopReplicaRequest WithUngroupedPartitionsCollection(params Func<StopReplicaPartitionV0, StopReplicaPartitionV0>[] createFields)
		{
			UngroupedPartitionsCollection = createFields
				.Select(createField => createField(new StopReplicaPartitionV0(Version)))
				.ToArray();
			return this;
		}

		public delegate StopReplicaPartitionV0 CreateStopReplicaPartitionV0(StopReplicaPartitionV0 field);

		/// <summary>
		/// <para>The partitions to stop.</para>
		/// <para>Versions: 0</para>
		/// </summary>
		public StopReplicaRequest WithUngroupedPartitionsCollection(IEnumerable<CreateStopReplicaPartitionV0> createFields)
		{
			UngroupedPartitionsCollection = createFields
				.Select(createField => createField(new StopReplicaPartitionV0(Version)))
				.ToArray();
			return this;
		}

		public class StopReplicaPartitionV0 : ISerialize
		{
			internal StopReplicaPartitionV0(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 0 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 0 && Version <= 0 ? 
					_partitionIndex.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<StopReplicaPartitionV0> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaPartitionV0(version);
				if (instance.Version >= 0 && instance.Version <= 0) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 0 && instance.Version <= 0) 
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaPartitionV0 is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 0)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 0 && Version <= 0)
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					if (Version >= 0 && Version <= 0 == false)
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public StopReplicaPartitionV0 WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					if (Version >= 0 && Version <= 0 == false)
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public StopReplicaPartitionV0 WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}
		}

		private Array<StopReplicaTopicV1> _topicsCollection = Array.Empty<StopReplicaTopicV1>();
		/// <summary>
		/// <para>The topics to stop.</para>
		/// <para>Versions: 1-2</para>
		/// </summary>
		public Array<StopReplicaTopicV1> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				if (Version >= 1 && Version <= 2 == false)
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1-2");

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to stop.</para>
		/// <para>Versions: 1-2</para>
		/// </summary>
		public StopReplicaRequest WithTopicsCollection(params Func<StopReplicaTopicV1, StopReplicaTopicV1>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new StopReplicaTopicV1(Version)))
				.ToArray();
			return this;
		}

		public delegate StopReplicaTopicV1 CreateStopReplicaTopicV1(StopReplicaTopicV1 field);

		/// <summary>
		/// <para>The topics to stop.</para>
		/// <para>Versions: 1-2</para>
		/// </summary>
		public StopReplicaRequest WithTopicsCollection(IEnumerable<CreateStopReplicaTopicV1> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new StopReplicaTopicV1(Version)))
				.ToArray();
			return this;
		}

		public class StopReplicaTopicV1 : ISerialize
		{
			internal StopReplicaTopicV1(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 1 && Version <= 2 ? 
					_name.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 && Version <= 2 ? 
					_partitionIndexesCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<StopReplicaTopicV1> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaTopicV1(version);
				if (instance.Version >= 1 && instance.Version <= 2) 
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1 && instance.Version <= 2) 
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaTopicV1 is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 1 && Version <= 2)
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1 && Version <= 2)
					await _partitionIndexesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					if (Version >= 1 && Version <= 2 == false)
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 1-2");

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public StopReplicaTopicV1 WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<Int32> _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public Array<Int32> PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				private set 
				{
					if (Version >= 1 && Version <= 2 == false)
						throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1-2");

					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public StopReplicaTopicV1 WithPartitionIndexesCollection(Array<Int32> partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		private Array<StopReplicaTopicState> _topicStatesCollection = Array.Empty<StopReplicaTopicState>();
		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Array<StopReplicaTopicState> TopicStatesCollection 
		{
			get => _topicStatesCollection;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"TopicStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_topicStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public StopReplicaRequest WithTopicStatesCollection(params Func<StopReplicaTopicState, StopReplicaTopicState>[] createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(new StopReplicaTopicState(Version)))
				.ToArray();
			return this;
		}

		public delegate StopReplicaTopicState CreateStopReplicaTopicState(StopReplicaTopicState field);

		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public StopReplicaRequest WithTopicStatesCollection(IEnumerable<CreateStopReplicaTopicState> createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(new StopReplicaTopicState(Version)))
				.ToArray();
			return this;
		}

		public class StopReplicaTopicState : ISerialize
		{
			internal StopReplicaTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 3 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 3 ? 
					_partitionStatesCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<StopReplicaTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaTopicState(version);
				if (instance.Version >= 3) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 3) 
					instance.PartitionStatesCollection = await Array<StopReplicaPartitionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaTopicState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 3)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _partitionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public StopReplicaTopicState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<StopReplicaPartitionState> _partitionStatesCollection = Array.Empty<StopReplicaPartitionState>();
			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Array<StopReplicaPartitionState> PartitionStatesCollection 
			{
				get => _partitionStatesCollection;
				private set 
				{
					if (Version >= 3 == false)
						throw new UnsupportedVersionException($"PartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

					_partitionStatesCollection = value;
				}
			}

			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public StopReplicaTopicState WithPartitionStatesCollection(params Func<StopReplicaPartitionState, StopReplicaPartitionState>[] createFields)
			{
				PartitionStatesCollection = createFields
					.Select(createField => createField(new StopReplicaPartitionState(Version)))
					.ToArray();
				return this;
			}

			public delegate StopReplicaPartitionState CreateStopReplicaPartitionState(StopReplicaPartitionState field);

			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public StopReplicaTopicState WithPartitionStatesCollection(IEnumerable<CreateStopReplicaPartitionState> createFields)
			{
				PartitionStatesCollection = createFields
					.Select(createField => createField(new StopReplicaPartitionState(Version)))
					.ToArray();
				return this;
			}

			public class StopReplicaPartitionState : ISerialize
			{
				internal StopReplicaPartitionState(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 2;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 3 ? 
						_partitionIndex.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 3 ? 
						_leaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 3 ? 
						_deletePartition.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<StopReplicaPartitionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new StopReplicaPartitionState(version);
					if (instance.Version >= 3) 
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 3) 
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 3) 
						instance.DeletePartition = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaPartitionState is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 3)
						await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 3)
						await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 3)
						await _deletePartition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						if (Version >= 3 == false)
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public StopReplicaPartitionState WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						if (Version >= 3 == false)
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public StopReplicaPartitionState WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Boolean _deletePartition = Boolean.Default;
				/// <summary>
				/// <para>Whether this partition should be deleted.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public Boolean DeletePartition 
				{
					get => _deletePartition;
					private set 
					{
						if (Version >= 3 == false)
							throw new UnsupportedVersionException($"DeletePartition does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

						_deletePartition = value;
					}
				}

				/// <summary>
				/// <para>Whether this partition should be deleted.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public StopReplicaPartitionState WithDeletePartition(Boolean deletePartition)
				{
					DeletePartition = deletePartition;
					return this;
				}
			}
		}

		public StopReplicaResponse Respond()
			=> new StopReplicaResponse(Version);
	}

	public class StopReplicaResponse : Message
	{
		public StopReplicaResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"StopReplicaResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 2;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(5);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_partitionErrorsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<StopReplicaResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new StopReplicaResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.PartitionErrorsCollection = await Array<StopReplicaPartitionError>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaPartitionError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _partitionErrorsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<StopReplicaPartitionError> _partitionErrorsCollection = Array.Empty<StopReplicaPartitionError>();
		/// <summary>
		/// <para>The responses for each partition.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<StopReplicaPartitionError> PartitionErrorsCollection 
		{
			get => _partitionErrorsCollection;
			private set 
			{
				_partitionErrorsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each partition.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaResponse WithPartitionErrorsCollection(params Func<StopReplicaPartitionError, StopReplicaPartitionError>[] createFields)
		{
			PartitionErrorsCollection = createFields
				.Select(createField => createField(new StopReplicaPartitionError(Version)))
				.ToArray();
			return this;
		}

		public delegate StopReplicaPartitionError CreateStopReplicaPartitionError(StopReplicaPartitionError field);

		/// <summary>
		/// <para>The responses for each partition.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaResponse WithPartitionErrorsCollection(IEnumerable<CreateStopReplicaPartitionError> createFields)
		{
			PartitionErrorsCollection = createFields
				.Select(createField => createField(new StopReplicaPartitionError(Version)))
				.ToArray();
			return this;
		}

		public class StopReplicaPartitionError : ISerialize
		{
			internal StopReplicaPartitionError(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 2;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<StopReplicaPartitionError> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaPartitionError(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaPartitionError is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public StopReplicaPartitionError WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public StopReplicaPartitionError WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The partition error code, or 0 if there was no partition error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The partition error code, or 0 if there was no partition error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public StopReplicaPartitionError WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class SyncGroupRequest : Message, IRespond<SyncGroupResponse>
	{
		public SyncGroupRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SyncGroupRequest does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(14);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_generationId.GetSize(IsFlexibleVersion) +
			_memberId.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_groupInstanceId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_protocolType.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_protocolName.GetSize(IsFlexibleVersion):
				0) +
			_assignmentsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<SyncGroupRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SyncGroupRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.ProtocolType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.ProtocolName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.AssignmentsCollection = await Array<SyncGroupRequestAssignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => SyncGroupRequestAssignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SyncGroupRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _generationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _protocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _protocolName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _assignmentsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _generationId = Int32.Default;
		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			private set 
			{
				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID assigned by the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private NullableString _groupInstanceId = new NullableString(null);
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private NullableString _protocolType = new NullableString(null);
		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolType 
		{
			get => _protocolType;
			private set 
			{
				if (Version >= 5 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ProtocolType does not support null for version {Version}. Supported versions for null value: 5+");

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupRequest WithProtocolType(String? protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private NullableString _protocolName = new NullableString(null);
		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolName 
		{
			get => _protocolName;
			private set 
			{
				if (Version >= 5 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ProtocolName does not support null for version {Version}. Supported versions for null value: 5+");

				_protocolName = value;
			}
		}

		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupRequest WithProtocolName(String? protocolName)
		{
			ProtocolName = protocolName;
			return this;
		}

		private Array<SyncGroupRequestAssignment> _assignmentsCollection = Array.Empty<SyncGroupRequestAssignment>();
		/// <summary>
		/// <para>Each assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<SyncGroupRequestAssignment> AssignmentsCollection 
		{
			get => _assignmentsCollection;
			private set 
			{
				_assignmentsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithAssignmentsCollection(params Func<SyncGroupRequestAssignment, SyncGroupRequestAssignment>[] createFields)
		{
			AssignmentsCollection = createFields
				.Select(createField => createField(new SyncGroupRequestAssignment(Version)))
				.ToArray();
			return this;
		}

		public delegate SyncGroupRequestAssignment CreateSyncGroupRequestAssignment(SyncGroupRequestAssignment field);

		/// <summary>
		/// <para>Each assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithAssignmentsCollection(IEnumerable<CreateSyncGroupRequestAssignment> createFields)
		{
			AssignmentsCollection = createFields
				.Select(createField => createField(new SyncGroupRequestAssignment(Version)))
				.ToArray();
			return this;
		}

		public class SyncGroupRequestAssignment : ISerialize
		{
			internal SyncGroupRequestAssignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 4;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_memberId.GetSize(IsFlexibleVersion) +
				_assignment.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<SyncGroupRequestAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new SyncGroupRequestAssignment(version);
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Assignment = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for SyncGroupRequestAssignment is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The ID of the member to assign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				private set 
				{
					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the member to assign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public SyncGroupRequestAssignment WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private Bytes _assignment = Bytes.Default;
			/// <summary>
			/// <para>The member assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Assignment 
			{
				get => _assignment;
				private set 
				{
					_assignment = value;
				}
			}

			/// <summary>
			/// <para>The member assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public SyncGroupRequestAssignment WithAssignment(Bytes assignment)
			{
				Assignment = assignment;
				return this;
			}
		}

		public SyncGroupResponse Respond()
			=> new SyncGroupResponse(Version);
	}

	public class SyncGroupResponse : Message
	{
		public SyncGroupResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SyncGroupResponse does not support version {version}. Valid versions are: 0-5");

			Version = version;
			IsFlexibleVersion = version >= 4;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(14);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			(Version >= 1 ? 
				_throttleTimeMs.GetSize(IsFlexibleVersion):
				0) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(Version >= 5 ? 
				_protocolType.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_protocolName.GetSize(IsFlexibleVersion):
				0) +
			_assignment.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<SyncGroupResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SyncGroupResponse(version);
			if (instance.Version >= 1) 
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.ProtocolType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.ProtocolName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Assignment = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SyncGroupResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version >= 1)
				await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _protocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _protocolName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public SyncGroupResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _protocolType = new NullableString(null);
		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolType 
		{
			get => _protocolType;
			private set 
			{
				if (Version >= 5 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ProtocolType does not support null for version {Version}. Supported versions for null value: 5+");

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupResponse WithProtocolType(String? protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private NullableString _protocolName = new NullableString(null);
		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolName 
		{
			get => _protocolName;
			private set 
			{
				if (Version >= 5 == false &&
					value == null) 
					throw new UnsupportedVersionException($"ProtocolName does not support null for version {Version}. Supported versions for null value: 5+");

				_protocolName = value;
			}
		}

		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupResponse WithProtocolName(String? protocolName)
		{
			ProtocolName = protocolName;
			return this;
		}

		private Bytes _assignment = Bytes.Default;
		/// <summary>
		/// <para>The member assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Assignment 
		{
			get => _assignment;
			private set 
			{
				_assignment = value;
			}
		}

		/// <summary>
		/// <para>The member assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupResponse WithAssignment(Bytes assignment)
		{
			Assignment = assignment;
			return this;
		}
	}

	public class TxnOffsetCommitRequest : Message, IRespond<TxnOffsetCommitResponse>
	{
		public TxnOffsetCommitRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"TxnOffsetCommitRequest does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(28);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_transactionalId.GetSize(IsFlexibleVersion) +
			_groupId.GetSize(IsFlexibleVersion) +
			_producerId.GetSize(IsFlexibleVersion) +
			_producerEpoch.GetSize(IsFlexibleVersion) +
			(Version >= 3 ? 
				_generationId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_memberId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_groupInstanceId.GetSize(IsFlexibleVersion):
				0) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<TxnOffsetCommitRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new TxnOffsetCommitRequest(version);
			instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TxnOffsetCommitRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _transactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _generationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _memberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 3)
				await _groupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The ID of the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			private set 
			{
				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>The current producer ID in use by the transactional ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			private set 
			{
				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The current producer ID in use by the transactional ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>The current epoch associated with the producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			private set 
			{
				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current epoch associated with the producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private Int32 _generationId = new Int32(-1);
		/// <summary>
		/// <para>The generation of the consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"GenerationId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public TxnOffsetCommitRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = new String(string.Empty);
		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public TxnOffsetCommitRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private NullableString _groupInstanceId = new NullableString(null);
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			private set 
			{
				if (Version >= 3 == false)
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");

				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public TxnOffsetCommitRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private Array<TxnOffsetCommitRequestTopic> _topicsCollection = Array.Empty<TxnOffsetCommitRequestTopic>();
		/// <summary>
		/// <para>Each topic that we want to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TxnOffsetCommitRequestTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithTopicsCollection(params Func<TxnOffsetCommitRequestTopic, TxnOffsetCommitRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TxnOffsetCommitRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate TxnOffsetCommitRequestTopic CreateTxnOffsetCommitRequestTopic(TxnOffsetCommitRequestTopic field);

		/// <summary>
		/// <para>Each topic that we want to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithTopicsCollection(IEnumerable<CreateTxnOffsetCommitRequestTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TxnOffsetCommitRequestTopic(Version)))
				.ToArray();
			return this;
		}

		public class TxnOffsetCommitRequestTopic : ISerialize
		{
			internal TxnOffsetCommitRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TxnOffsetCommitRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TxnOffsetCommitRequestTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<TxnOffsetCommitRequestPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitRequestPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<TxnOffsetCommitRequestPartition> _partitionsCollection = Array.Empty<TxnOffsetCommitRequestPartition>();
			/// <summary>
			/// <para>The partitions inside the topic that we want to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TxnOffsetCommitRequestPartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions inside the topic that we want to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitRequestTopic WithPartitionsCollection(params Func<TxnOffsetCommitRequestPartition, TxnOffsetCommitRequestPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new TxnOffsetCommitRequestPartition(Version)))
					.ToArray();
				return this;
			}

			public delegate TxnOffsetCommitRequestPartition CreateTxnOffsetCommitRequestPartition(TxnOffsetCommitRequestPartition field);

			/// <summary>
			/// <para>The partitions inside the topic that we want to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitRequestTopic WithPartitionsCollection(IEnumerable<CreateTxnOffsetCommitRequestPartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new TxnOffsetCommitRequestPartition(Version)))
					.ToArray();
				return this;
			}

			public class TxnOffsetCommitRequestPartition : ISerialize
			{
				internal TxnOffsetCommitRequestPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 3;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_committedOffset.GetSize(IsFlexibleVersion) +
					(Version >= 2 ? 
						_committedLeaderEpoch.GetSize(IsFlexibleVersion):
						0) +
					_committedMetadata.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<TxnOffsetCommitRequestPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TxnOffsetCommitRequestPartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 2) 
						instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CommittedMetadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitRequestPartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _committedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 2)
						await _committedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _committedMetadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The index of the partition within the topic.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The index of the partition within the topic.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _committedOffset = Int64.Default;
				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 CommittedOffset 
				{
					get => _committedOffset;
					private set 
					{
						_committedOffset = value;
					}
				}

				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithCommittedOffset(Int64 committedOffset)
				{
					CommittedOffset = committedOffset;
					return this;
				}

				private Int32 _committedLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of the last consumed record.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CommittedLeaderEpoch 
				{
					get => _committedLeaderEpoch;
					private set 
					{
						_committedLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the last consumed record.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
				{
					CommittedLeaderEpoch = committedLeaderEpoch;
					return this;
				}

				private NullableString _committedMetadata = NullableString.Default;
				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? CommittedMetadata 
				{
					get => _committedMetadata;
					private set 
					{
						_committedMetadata = value;
					}
				}

				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithCommittedMetadata(String? committedMetadata)
				{
					CommittedMetadata = committedMetadata;
					return this;
				}
			}
		}

		public TxnOffsetCommitResponse Respond()
			=> new TxnOffsetCommitResponse(Version);
	}

	public class TxnOffsetCommitResponse : Message
	{
		public TxnOffsetCommitResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"TxnOffsetCommitResponse does not support version {version}. Valid versions are: 0-4");

			Version = version;
			IsFlexibleVersion = version >= 3;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(28);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<TxnOffsetCommitResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new TxnOffsetCommitResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TxnOffsetCommitResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Array<TxnOffsetCommitResponseTopic> _topicsCollection = Array.Empty<TxnOffsetCommitResponseTopic>();
		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TxnOffsetCommitResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitResponse WithTopicsCollection(params Func<TxnOffsetCommitResponseTopic, TxnOffsetCommitResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TxnOffsetCommitResponseTopic(Version)))
				.ToArray();
			return this;
		}

		public delegate TxnOffsetCommitResponseTopic CreateTxnOffsetCommitResponseTopic(TxnOffsetCommitResponseTopic field);

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitResponse WithTopicsCollection(IEnumerable<CreateTxnOffsetCommitResponseTopic> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TxnOffsetCommitResponseTopic(Version)))
				.ToArray();
			return this;
		}

		public class TxnOffsetCommitResponseTopic : ISerialize
		{
			internal TxnOffsetCommitResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 3;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TxnOffsetCommitResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TxnOffsetCommitResponseTopic(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<TxnOffsetCommitResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Array<TxnOffsetCommitResponsePartition> _partitionsCollection = Array.Empty<TxnOffsetCommitResponsePartition>();
			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<TxnOffsetCommitResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitResponseTopic WithPartitionsCollection(params Func<TxnOffsetCommitResponsePartition, TxnOffsetCommitResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new TxnOffsetCommitResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public delegate TxnOffsetCommitResponsePartition CreateTxnOffsetCommitResponsePartition(TxnOffsetCommitResponsePartition field);

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitResponseTopic WithPartitionsCollection(IEnumerable<CreateTxnOffsetCommitResponsePartition> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new TxnOffsetCommitResponsePartition(Version)))
					.ToArray();
				return this;
			}

			public class TxnOffsetCommitResponsePartition : ISerialize
			{
				internal TxnOffsetCommitResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 3;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<TxnOffsetCommitResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TxnOffsetCommitResponsePartition(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class UnregisterBrokerRequest : Message, IRespond<UnregisterBrokerResponse>
	{
		public UnregisterBrokerRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UnregisterBrokerRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(64);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_brokerId.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UnregisterBrokerRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UnregisterBrokerRequest(version);
			instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UnregisterBrokerRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _brokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The broker ID to unregister.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			private set 
			{
				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID to unregister.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		public UnregisterBrokerResponse Respond()
			=> new UnregisterBrokerResponse(Version);
	}

	public class UnregisterBrokerResponse : Message
	{
		public UnregisterBrokerResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UnregisterBrokerResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(64);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UnregisterBrokerResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UnregisterBrokerResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UnregisterBrokerResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}
	}

	public class UpdateFeaturesRequest : Message, IRespond<UpdateFeaturesResponse>
	{
		public UpdateFeaturesRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UpdateFeaturesRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(57);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_timeoutMs.GetSize(IsFlexibleVersion) +
			_featureUpdatesCollection.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_validateOnly.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UpdateFeaturesRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateFeaturesRequest(version);
			instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.FeatureUpdatesCollection = await Map<String, FeatureUpdateKey>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FeatureUpdateKey.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Feature, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateFeaturesRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _timeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _featureUpdatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 1)
				await _validateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			private set 
			{
				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public UpdateFeaturesRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Map<String, FeatureUpdateKey> _featureUpdatesCollection = Map<String, FeatureUpdateKey>.Default;
		/// <summary>
		/// <para>The list of updates to finalized features.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, FeatureUpdateKey> FeatureUpdatesCollection 
		{
			get => _featureUpdatesCollection;
			private set 
			{
				_featureUpdatesCollection = value;
			}
		}

		/// <summary>
		/// <para>The list of updates to finalized features.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesRequest WithFeatureUpdatesCollection(params Func<FeatureUpdateKey, FeatureUpdateKey>[] createFields)
		{
			FeatureUpdatesCollection = createFields
				.Select(createField => createField(new FeatureUpdateKey(Version)))
				.ToDictionary(field => field.Feature);
			return this;
		}

		public delegate FeatureUpdateKey CreateFeatureUpdateKey(FeatureUpdateKey field);

		/// <summary>
		/// <para>The list of updates to finalized features.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesRequest WithFeatureUpdatesCollection(IEnumerable<CreateFeatureUpdateKey> createFields)
		{
			FeatureUpdatesCollection = createFields
				.Select(createField => createField(new FeatureUpdateKey(Version)))
				.ToDictionary(field => field.Feature);
			return this;
		}

		public class FeatureUpdateKey : ISerialize
		{
			internal FeatureUpdateKey(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_feature.GetSize(IsFlexibleVersion) +
				_maxVersionLevel.GetSize(IsFlexibleVersion) +
				(Version >= 0 && Version <= 0 ? 
					_allowDowngrade.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 ? 
					_upgradeType.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<FeatureUpdateKey> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FeatureUpdateKey(version);
				instance.Feature = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MaxVersionLevel = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 0 && instance.Version <= 0) 
					instance.AllowDowngrade = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.UpgradeType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FeatureUpdateKey is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _feature.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _maxVersionLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 0 && Version <= 0)
					await _allowDowngrade.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _upgradeType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _feature = String.Default;
			/// <summary>
			/// <para>The name of the finalized feature to be updated.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Feature 
			{
				get => _feature;
				private set 
				{
					_feature = value;
				}
			}

			/// <summary>
			/// <para>The name of the finalized feature to be updated.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FeatureUpdateKey WithFeature(String feature)
			{
				Feature = feature;
				return this;
			}

			private Int16 _maxVersionLevel = Int16.Default;
			/// <summary>
			/// <para>The new maximum version level for the finalized feature. A value >= 1 is valid. A value < 1, is special, and can be used to request the deletion of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxVersionLevel 
			{
				get => _maxVersionLevel;
				private set 
				{
					_maxVersionLevel = value;
				}
			}

			/// <summary>
			/// <para>The new maximum version level for the finalized feature. A value >= 1 is valid. A value < 1, is special, and can be used to request the deletion of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FeatureUpdateKey WithMaxVersionLevel(Int16 maxVersionLevel)
			{
				MaxVersionLevel = maxVersionLevel;
				return this;
			}

			private Boolean _allowDowngrade = Boolean.Default;
			/// <summary>
			/// <para>DEPRECATED in version 1 (see DowngradeType). When set to true, the finalized feature version level is allowed to be downgraded/deleted. The downgrade request will fail if the new maximum version level is a value that's not lower than the existing maximum finalized version level.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public Boolean AllowDowngrade 
			{
				get => _allowDowngrade;
				private set 
				{
					if (Version >= 0 && Version <= 0 == false)
						throw new UnsupportedVersionException($"AllowDowngrade does not support version {Version} and has been defined as not ignorable. Supported versions: 0");

					_allowDowngrade = value;
				}
			}

			/// <summary>
			/// <para>DEPRECATED in version 1 (see DowngradeType). When set to true, the finalized feature version level is allowed to be downgraded/deleted. The downgrade request will fail if the new maximum version level is a value that's not lower than the existing maximum finalized version level.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public FeatureUpdateKey WithAllowDowngrade(Boolean allowDowngrade)
			{
				AllowDowngrade = allowDowngrade;
				return this;
			}

			private Int8 _upgradeType = new Int8(1);
			/// <summary>
			/// <para>Determine which type of upgrade will be performed: 1 will perform an upgrade only (default), 2 is safe downgrades only (lossless), 3 is unsafe downgrades (lossy).</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 1</para>
			/// </summary>
			public Int8 UpgradeType 
			{
				get => _upgradeType;
				private set 
				{
					if (Version >= 1 == false)
						throw new UnsupportedVersionException($"UpgradeType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

					_upgradeType = value;
				}
			}

			/// <summary>
			/// <para>Determine which type of upgrade will be performed: 1 will perform an upgrade only (default), 2 is safe downgrades only (lossless), 3 is unsafe downgrades (lossy).</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 1</para>
			/// </summary>
			public FeatureUpdateKey WithUpgradeType(Int8 upgradeType)
			{
				UpgradeType = upgradeType;
				return this;
			}
		}

		private Boolean _validateOnly = new Boolean(false);
		/// <summary>
		/// <para>True if we should validate the request, but not perform the upgrade or downgrade.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			private set 
			{
				if (Version >= 1 == false)
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>True if we should validate the request, but not perform the upgrade or downgrade.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public UpdateFeaturesRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public UpdateFeaturesResponse Respond()
			=> new UpdateFeaturesResponse(Version);
	}

	public class UpdateFeaturesResponse : Message
	{
		public UpdateFeaturesResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UpdateFeaturesResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(57);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			_errorMessage.GetSize(IsFlexibleVersion) +
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UpdateFeaturesResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateFeaturesResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ResultsCollection = await Map<String, UpdatableFeatureResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdatableFeatureResult.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Feature, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateFeaturesResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or `0` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or `0` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private NullableString _errorMessage = NullableString.Default;
		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			private set 
			{
				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Map<String, UpdatableFeatureResult> _resultsCollection = Map<String, UpdatableFeatureResult>.Default;
		/// <summary>
		/// <para>Results for each feature update.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, UpdatableFeatureResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>Results for each feature update.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithResultsCollection(params Func<UpdatableFeatureResult, UpdatableFeatureResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new UpdatableFeatureResult(Version)))
				.ToDictionary(field => field.Feature);
			return this;
		}

		public delegate UpdatableFeatureResult CreateUpdatableFeatureResult(UpdatableFeatureResult field);

		/// <summary>
		/// <para>Results for each feature update.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithResultsCollection(IEnumerable<CreateUpdatableFeatureResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new UpdatableFeatureResult(Version)))
				.ToDictionary(field => field.Feature);
			return this;
		}

		public class UpdatableFeatureResult : ISerialize
		{
			internal UpdatableFeatureResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_feature.GetSize(IsFlexibleVersion) +
				_errorCode.GetSize(IsFlexibleVersion) +
				_errorMessage.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<UpdatableFeatureResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdatableFeatureResult(version);
				instance.Feature = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdatableFeatureResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _feature.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _feature = String.Default;
			/// <summary>
			/// <para>The name of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Feature 
			{
				get => _feature;
				private set 
				{
					_feature = value;
				}
			}

			/// <summary>
			/// <para>The name of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdatableFeatureResult WithFeature(String feature)
			{
				Feature = feature;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The feature update error code or `0` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				private set 
				{
					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The feature update error code or `0` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdatableFeatureResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private NullableString _errorMessage = NullableString.Default;
			/// <summary>
			/// <para>The feature update error, or `null` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				private set 
				{
					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The feature update error, or `null` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdatableFeatureResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class UpdateMetadataRequest : Message, IRespond<UpdateMetadataResponse>
	{
		public UpdateMetadataRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UpdateMetadataRequest does not support version {version}. Valid versions are: 0-8");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(6);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			var tags = new List<Tags.TaggedField>();
			if (Version >= 8 && _typeIsSet) 
				tags.Add(new Tags.TaggedField
				{
					Tag = 0,
					Field = _type
				});
			return new Tags.TagSection(tags.ToArray());
		}

		internal override int GetSize() =>
			_controllerId.GetSize(IsFlexibleVersion) +
			(Version >= 8 ? 
				_isKRaftController.GetSize(IsFlexibleVersion):
				0) +
			_controllerEpoch.GetSize(IsFlexibleVersion) +
			(Version >= 5 ? 
				_brokerEpoch.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 0 && Version <= 4 ? 
				_ungroupedPartitionStatesCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 5 ? 
				_topicStatesCollection.GetSize(IsFlexibleVersion):
				0) +
			_liveBrokersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UpdateMetadataRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateMetadataRequest(version);
			instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 8) 
				instance.IsKRaftController = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 0 && instance.Version <= 4) 
				instance.UngroupedPartitionStatesCollection = await Array<UpdateMetadataPartitionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 5) 
				instance.TopicStatesCollection = await Array<UpdateMetadataTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.LiveBrokersCollection = await Array<UpdateMetadataBroker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataBroker.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version >= 8) 
								instance.Type = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							else
								throw new InvalidOperationException($"Field Type is not supported for version {instance.Version}");
							{
								var size = instance._type.GetSize(true);
								if (size != tag.Length)
									throw new CorruptMessageException($"Tagged field Type read length {tag.Length} but had actual length of {size}");
							}
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _controllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 8)
				await _isKRaftController.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _controllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _brokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 0 && Version <= 4)
				await _ungroupedPartitionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (Version >= 5)
				await _topicStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _liveBrokersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			private set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Boolean _isKRaftController = new Boolean(false);
		/// <summary>
		/// <para>If KRaft controller id is used during migration. See KIP-866</para>
		/// <para>Versions: 8+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IsKRaftController 
		{
			get => _isKRaftController;
			private set 
			{
				if (Version >= 8 == false)
					throw new UnsupportedVersionException($"IsKRaftController does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

				_isKRaftController = value;
			}
		}

		/// <summary>
		/// <para>If KRaft controller id is used during migration. See KIP-866</para>
		/// <para>Versions: 8+</para>
		/// <para>Default: false</para>
		/// </summary>
		public UpdateMetadataRequest WithIsKRaftController(Boolean isKRaftController)
		{
			IsKRaftController = isKRaftController;
			return this;
		}

		private bool _typeIsSet;
		private Int8 _type = new Int8(0);
		/// <summary>
		/// <para>Indicates if this request is a Full metadata snapshot (2), Incremental (1), or Unknown (0). Using during ZK migration, see KIP-866</para>
		/// <para>Versions: 8+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int8 Type 
		{
			get => _type;
			private set 
			{
				if (Version >= 8 == false)
					throw new UnsupportedVersionException($"Type does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");

				_type = value;
				_typeIsSet = true;
			}
		}

		/// <summary>
		/// <para>Indicates if this request is a Full metadata snapshot (2), Incremental (1), or Unknown (0). Using during ZK migration, see KIP-866</para>
		/// <para>Versions: 8+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public UpdateMetadataRequest WithType(Int8 type)
		{
			Type = type;
			return this;
		}

		private Int32 _controllerEpoch = Int32.Default;
		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerEpoch 
		{
			get => _controllerEpoch;
			private set 
			{
				_controllerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithControllerEpoch(Int32 controllerEpoch)
		{
			ControllerEpoch = controllerEpoch;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			private set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public UpdateMetadataRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Array<UpdateMetadataPartitionState> _ungroupedPartitionStatesCollection = Array.Empty<UpdateMetadataPartitionState>();
		/// <summary>
		/// <para>In older versions of this RPC, each partition that we would like to update.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public Array<UpdateMetadataPartitionState> UngroupedPartitionStatesCollection 
		{
			get => _ungroupedPartitionStatesCollection;
			private set 
			{
				if (Version >= 0 && Version <= 4 == false)
					throw new UnsupportedVersionException($"UngroupedPartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-4");

				_ungroupedPartitionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>In older versions of this RPC, each partition that we would like to update.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public UpdateMetadataRequest WithUngroupedPartitionStatesCollection(Array<UpdateMetadataPartitionState> ungroupedPartitionStatesCollection)
		{
			UngroupedPartitionStatesCollection = ungroupedPartitionStatesCollection;
			return this;
		}

		private Array<UpdateMetadataTopicState> _topicStatesCollection = Array.Empty<UpdateMetadataTopicState>();
		/// <summary>
		/// <para>In newer versions of this RPC, each topic that we would like to update.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public Array<UpdateMetadataTopicState> TopicStatesCollection 
		{
			get => _topicStatesCollection;
			private set 
			{
				if (Version >= 5 == false)
					throw new UnsupportedVersionException($"TopicStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

				_topicStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>In newer versions of this RPC, each topic that we would like to update.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public UpdateMetadataRequest WithTopicStatesCollection(params Func<UpdateMetadataTopicState, UpdateMetadataTopicState>[] createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(new UpdateMetadataTopicState(Version)))
				.ToArray();
			return this;
		}

		public delegate UpdateMetadataTopicState CreateUpdateMetadataTopicState(UpdateMetadataTopicState field);

		/// <summary>
		/// <para>In newer versions of this RPC, each topic that we would like to update.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public UpdateMetadataRequest WithTopicStatesCollection(IEnumerable<CreateUpdateMetadataTopicState> createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(new UpdateMetadataTopicState(Version)))
				.ToArray();
			return this;
		}

		public class UpdateMetadataTopicState : ISerialize
		{
			internal UpdateMetadataTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 5 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 7 ? 
					_topicId.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 5 ? 
					_partitionStatesCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<UpdateMetadataTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdateMetadataTopicState(version);
				if (instance.Version >= 5) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 7) 
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 5) 
					instance.PartitionStatesCollection = await Array<UpdateMetadataPartitionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataTopicState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 5)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 7)
					await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 5)
					await _partitionStatesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					if (Version >= 5 == false)
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public UpdateMetadataTopicState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public UpdateMetadataTopicState WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<UpdateMetadataPartitionState> _partitionStatesCollection = Array.Empty<UpdateMetadataPartitionState>();
			/// <summary>
			/// <para>The partition that we would like to update.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Array<UpdateMetadataPartitionState> PartitionStatesCollection 
			{
				get => _partitionStatesCollection;
				private set 
				{
					if (Version >= 5 == false)
						throw new UnsupportedVersionException($"PartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");

					_partitionStatesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition that we would like to update.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public UpdateMetadataTopicState WithPartitionStatesCollection(Array<UpdateMetadataPartitionState> partitionStatesCollection)
			{
				PartitionStatesCollection = partitionStatesCollection;
				return this;
			}
		}

		private Array<UpdateMetadataBroker> _liveBrokersCollection = Array.Empty<UpdateMetadataBroker>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<UpdateMetadataBroker> LiveBrokersCollection 
		{
			get => _liveBrokersCollection;
			private set 
			{
				_liveBrokersCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithLiveBrokersCollection(params Func<UpdateMetadataBroker, UpdateMetadataBroker>[] createFields)
		{
			LiveBrokersCollection = createFields
				.Select(createField => createField(new UpdateMetadataBroker(Version)))
				.ToArray();
			return this;
		}

		public delegate UpdateMetadataBroker CreateUpdateMetadataBroker(UpdateMetadataBroker field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithLiveBrokersCollection(IEnumerable<CreateUpdateMetadataBroker> createFields)
		{
			LiveBrokersCollection = createFields
				.Select(createField => createField(new UpdateMetadataBroker(Version)))
				.ToArray();
			return this;
		}

		public class UpdateMetadataBroker : ISerialize
		{
			internal UpdateMetadataBroker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_id.GetSize(IsFlexibleVersion) +
				(Version >= 0 && Version <= 0 ? 
					_v0Host.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 0 && Version <= 0 ? 
					_v0Port.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 ? 
					_endpointsCollection.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 2 ? 
					_rack.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<UpdateMetadataBroker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdateMetadataBroker(version);
				instance.Id = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 0 && instance.Version <= 0) 
					instance.V0Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 0 && instance.Version <= 0) 
					instance.V0Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.EndpointsCollection = await Array<UpdateMetadataEndpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataEndpoint.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 2) 
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataBroker is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _id.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 0 && Version <= 0)
					await _v0Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 0 && Version <= 0)
					await _v0Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _endpointsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _id = Int32.Default;
			/// <summary>
			/// <para>The broker id.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Id 
			{
				get => _id;
				private set 
				{
					_id = value;
				}
			}

			/// <summary>
			/// <para>The broker id.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataBroker WithId(Int32 id)
			{
				Id = id;
				return this;
			}

			private String _v0Host = String.Default;
			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public String V0Host 
			{
				get => _v0Host;
				private set 
				{
					_v0Host = value;
				}
			}

			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public UpdateMetadataBroker WithV0Host(String v0Host)
			{
				V0Host = v0Host;
				return this;
			}

			private Int32 _v0Port = Int32.Default;
			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public Int32 V0Port 
			{
				get => _v0Port;
				private set 
				{
					_v0Port = value;
				}
			}

			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public UpdateMetadataBroker WithV0Port(Int32 v0Port)
			{
				V0Port = v0Port;
				return this;
			}

			private Array<UpdateMetadataEndpoint> _endpointsCollection = Array.Empty<UpdateMetadataEndpoint>();
			/// <summary>
			/// <para>The broker endpoints.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public Array<UpdateMetadataEndpoint> EndpointsCollection 
			{
				get => _endpointsCollection;
				private set 
				{
					_endpointsCollection = value;
				}
			}

			/// <summary>
			/// <para>The broker endpoints.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public UpdateMetadataBroker WithEndpointsCollection(params Func<UpdateMetadataEndpoint, UpdateMetadataEndpoint>[] createFields)
			{
				EndpointsCollection = createFields
					.Select(createField => createField(new UpdateMetadataEndpoint(Version)))
					.ToArray();
				return this;
			}

			public delegate UpdateMetadataEndpoint CreateUpdateMetadataEndpoint(UpdateMetadataEndpoint field);

			/// <summary>
			/// <para>The broker endpoints.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public UpdateMetadataBroker WithEndpointsCollection(IEnumerable<CreateUpdateMetadataEndpoint> createFields)
			{
				EndpointsCollection = createFields
					.Select(createField => createField(new UpdateMetadataEndpoint(Version)))
					.ToArray();
				return this;
			}

			public class UpdateMetadataEndpoint : ISerialize
			{
				internal UpdateMetadataEndpoint(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 6;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					(Version >= 1 ? 
						_port.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 ? 
						_host.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 3 ? 
						_listener.GetSize(IsFlexibleVersion):
						0) +
					(Version >= 1 ? 
						_securityProtocol.GetSize(IsFlexibleVersion):
						0) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<UpdateMetadataEndpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new UpdateMetadataEndpoint(version);
					if (instance.Version >= 1) 
						instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 3) 
						instance.Listener = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (instance.Version >= 1) 
						instance.SecurityProtocol = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataEndpoint is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version >= 1)
						await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 3)
						await _listener.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					if (Version >= 1)
						await _securityProtocol.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _port = Int32.Default;
				/// <summary>
				/// <para>The port of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public Int32 Port 
				{
					get => _port;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_port = value;
					}
				}

				/// <summary>
				/// <para>The port of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithPort(Int32 port)
				{
					Port = port;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The hostname of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_host = value;
					}
				}

				/// <summary>
				/// <para>The hostname of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithHost(String host)
				{
					Host = host;
					return this;
				}

				private String _listener = String.Default;
				/// <summary>
				/// <para>The listener name.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public String Listener 
				{
					get => _listener;
					private set 
					{
						_listener = value;
					}
				}

				/// <summary>
				/// <para>The listener name.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithListener(String listener)
				{
					Listener = listener;
					return this;
				}

				private Int16 _securityProtocol = Int16.Default;
				/// <summary>
				/// <para>The security protocol type.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public Int16 SecurityProtocol 
				{
					get => _securityProtocol;
					private set 
					{
						if (Version >= 1 == false)
							throw new UnsupportedVersionException($"SecurityProtocol does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

						_securityProtocol = value;
					}
				}

				/// <summary>
				/// <para>The security protocol type.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithSecurityProtocol(Int16 securityProtocol)
				{
					SecurityProtocol = securityProtocol;
					return this;
				}
			}

			private NullableString _rack = NullableString.Default;
			/// <summary>
			/// <para>The rack which this broker belongs to.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				private set 
				{
					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack which this broker belongs to.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public UpdateMetadataBroker WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}

		public class UpdateMetadataPartitionState : ISerialize
		{
			internal UpdateMetadataPartitionState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 6;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 0 && Version <= 4 ? 
					_topicName.GetSize(IsFlexibleVersion):
					0) +
				_partitionIndex.GetSize(IsFlexibleVersion) +
				_controllerEpoch.GetSize(IsFlexibleVersion) +
				_leader.GetSize(IsFlexibleVersion) +
				_leaderEpoch.GetSize(IsFlexibleVersion) +
				_isrCollection.GetSize(IsFlexibleVersion) +
				_zkVersion.GetSize(IsFlexibleVersion) +
				_replicasCollection.GetSize(IsFlexibleVersion) +
				(Version >= 4 ? 
					_offlineReplicasCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<UpdateMetadataPartitionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdateMetadataPartitionState(version);
				if (instance.Version >= 0 && instance.Version <= 4) 
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Leader = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.IsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.ZkVersion = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 4) 
					instance.OfflineReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataPartitionState is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 0 && Version <= 4)
					await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _controllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _leader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _isrCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _zkVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _replicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 4)
					await _offlineReplicasCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>In older versions of this RPC, the topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>In older versions of this RPC, the topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public UpdateMetadataPartitionState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				private set 
				{
					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int32 _controllerEpoch = Int32.Default;
			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ControllerEpoch 
			{
				get => _controllerEpoch;
				private set 
				{
					_controllerEpoch = value;
				}
			}

			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithControllerEpoch(Int32 controllerEpoch)
			{
				ControllerEpoch = controllerEpoch;
				return this;
			}

			private Int32 _leader = Int32.Default;
			/// <summary>
			/// <para>The ID of the broker which is the current partition leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Leader 
			{
				get => _leader;
				private set 
				{
					_leader = value;
				}
			}

			/// <summary>
			/// <para>The ID of the broker which is the current partition leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithLeader(Int32 leader)
			{
				Leader = leader;
				return this;
			}

			private Int32 _leaderEpoch = Int32.Default;
			/// <summary>
			/// <para>The leader epoch of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 LeaderEpoch 
			{
				get => _leaderEpoch;
				private set 
				{
					_leaderEpoch = value;
				}
			}

			/// <summary>
			/// <para>The leader epoch of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithLeaderEpoch(Int32 leaderEpoch)
			{
				LeaderEpoch = leaderEpoch;
				return this;
			}

			private Array<Int32> _isrCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The brokers which are in the ISR for this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> IsrCollection 
			{
				get => _isrCollection;
				private set 
				{
					_isrCollection = value;
				}
			}

			/// <summary>
			/// <para>The brokers which are in the ISR for this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithIsrCollection(Array<Int32> isrCollection)
			{
				IsrCollection = isrCollection;
				return this;
			}

			private Int32 _zkVersion = Int32.Default;
			/// <summary>
			/// <para>The Zookeeper version.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ZkVersion 
			{
				get => _zkVersion;
				private set 
				{
					_zkVersion = value;
				}
			}

			/// <summary>
			/// <para>The Zookeeper version.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithZkVersion(Int32 zkVersion)
			{
				ZkVersion = zkVersion;
				return this;
			}

			private Array<Int32> _replicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>All the replicas of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> ReplicasCollection 
			{
				get => _replicasCollection;
				private set 
				{
					_replicasCollection = value;
				}
			}

			/// <summary>
			/// <para>All the replicas of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithReplicasCollection(Array<Int32> replicasCollection)
			{
				ReplicasCollection = replicasCollection;
				return this;
			}

			private Array<Int32> _offlineReplicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replicas of this partition which are offline.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Array<Int32> OfflineReplicasCollection 
			{
				get => _offlineReplicasCollection;
				private set 
				{
					_offlineReplicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replicas of this partition which are offline.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithOfflineReplicasCollection(Array<Int32> offlineReplicasCollection)
			{
				OfflineReplicasCollection = offlineReplicasCollection;
				return this;
			}
		}

		public UpdateMetadataResponse Respond()
			=> new UpdateMetadataResponse(Version);
	}

	public class UpdateMetadataResponse : Message
	{
		public UpdateMetadataResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UpdateMetadataResponse does not support version {version}. Valid versions are: 0-8");

			Version = version;
			IsFlexibleVersion = version >= 6;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(6);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UpdateMetadataResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateMetadataResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class UpdateRaftVoterRequest : Message, IRespond<UpdateRaftVoterResponse>
	{
		public UpdateRaftVoterRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UpdateRaftVoterRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(82);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clusterId.GetSize(IsFlexibleVersion) +
			_voterId.GetSize(IsFlexibleVersion) +
			_voterDirectoryId.GetSize(IsFlexibleVersion) +
			_listenersCollection.GetSize(IsFlexibleVersion) +
			_kRaftVersionFeature.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UpdateRaftVoterRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateRaftVoterRequest(version);
			instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VoterId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VoterDirectoryId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ListenersCollection = await Map<String, Listener>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Listener.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
			instance.KRaftVersionFeature_ = await KRaftVersionFeature.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateRaftVoterRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _voterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _voterDirectoryId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _listenersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _kRaftVersionFeature.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterRequest WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _voterId = Int32.Default;
		/// <summary>
		/// <para>The replica id of the voter getting updated in the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 VoterId 
		{
			get => _voterId;
			private set 
			{
				_voterId = value;
			}
		}

		/// <summary>
		/// <para>The replica id of the voter getting updated in the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterRequest WithVoterId(Int32 voterId)
		{
			VoterId = voterId;
			return this;
		}

		private Uuid _voterDirectoryId = Uuid.Default;
		/// <summary>
		/// <para>The directory id of the voter getting updated in the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid VoterDirectoryId 
		{
			get => _voterDirectoryId;
			private set 
			{
				_voterDirectoryId = value;
			}
		}

		/// <summary>
		/// <para>The directory id of the voter getting updated in the topic partition</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterRequest WithVoterDirectoryId(Uuid voterDirectoryId)
		{
			VoterDirectoryId = voterDirectoryId;
			return this;
		}

		private Map<String, Listener> _listenersCollection = Map<String, Listener>.Default;
		/// <summary>
		/// <para>The endpoint that can be used to communicate with the leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, Listener> ListenersCollection 
		{
			get => _listenersCollection;
			private set 
			{
				_listenersCollection = value;
			}
		}

		/// <summary>
		/// <para>The endpoint that can be used to communicate with the leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterRequest WithListenersCollection(params Func<Listener, Listener>[] createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public delegate Listener CreateListener(Listener field);

		/// <summary>
		/// <para>The endpoint that can be used to communicate with the leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterRequest WithListenersCollection(IEnumerable<CreateListener> createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(new Listener(Version)))
				.ToDictionary(field => field.Name);
			return this;
		}

		public class Listener : ISerialize
		{
			internal Listener(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_name.GetSize(IsFlexibleVersion) +
				_host.GetSize(IsFlexibleVersion) +
				_port.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Listener> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Listener(version);
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Listener is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the endpoint</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				private set 
				{
					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the endpoint</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithName(String name)
			{
				Name = name;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The hostname</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				private set 
				{
					_host = value;
				}
			}

			/// <summary>
			/// <para>The hostname</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithHost(String host)
			{
				Host = host;
				return this;
			}

			private UInt16 _port = UInt16.Default;
			/// <summary>
			/// <para>The port</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UInt16 Port 
			{
				get => _port;
				private set 
				{
					_port = value;
				}
			}

			/// <summary>
			/// <para>The port</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithPort(UInt16 port)
			{
				Port = port;
				return this;
			}
		}

		private KRaftVersionFeature _kRaftVersionFeature = default!;
		/// <summary>
		/// <para>The range of versions of the protocol that the replica supports</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public KRaftVersionFeature KRaftVersionFeature_ 
		{
			get => _kRaftVersionFeature;
			private set 
			{
				_kRaftVersionFeature = value;
			}
		}

		/// <summary>
		/// <para>The range of versions of the protocol that the replica supports</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterRequest WithKRaftVersionFeature_(Func<KRaftVersionFeature, KRaftVersionFeature> createField)
		{
			KRaftVersionFeature_ = createField(new KRaftVersionFeature(Version));
			return this;
		}

		public class KRaftVersionFeature : ISerialize
		{
			internal KRaftVersionFeature(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_minSupportedVersion.GetSize(IsFlexibleVersion) +
				_maxSupportedVersion.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<KRaftVersionFeature> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new KRaftVersionFeature(version);
				instance.MinSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.MaxSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for KRaftVersionFeature is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _minSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _maxSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int16 _minSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported KRaft protocol version</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MinSupportedVersion 
			{
				get => _minSupportedVersion;
				private set 
				{
					_minSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported KRaft protocol version</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public KRaftVersionFeature WithMinSupportedVersion(Int16 minSupportedVersion)
			{
				MinSupportedVersion = minSupportedVersion;
				return this;
			}

			private Int16 _maxSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported KRaft protocol version</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxSupportedVersion 
			{
				get => _maxSupportedVersion;
				private set 
				{
					_maxSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported KRaft protocol version</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public KRaftVersionFeature WithMaxSupportedVersion(Int16 maxSupportedVersion)
			{
				MaxSupportedVersion = maxSupportedVersion;
				return this;
			}
		}

		public UpdateRaftVoterResponse Respond()
			=> new UpdateRaftVoterResponse(Version);
	}

	public class UpdateRaftVoterResponse : Message
	{
		public UpdateRaftVoterResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"UpdateRaftVoterResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(82);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_throttleTimeMs.GetSize(IsFlexibleVersion) +
			_errorCode.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<UpdateRaftVoterResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateRaftVoterResponse(version);
			instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateRaftVoterResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _throttleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			private set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateRaftVoterResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class VoteRequest : Message, IRespond<VoteResponse>
	{
		public VoteRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"VoteRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(52);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_clusterId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<VoteRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new VoteRequest(version);
			instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for VoteRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _clusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private NullableString _clusterId = new NullableString(null);
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			private set 
			{
				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public VoteRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteRequest WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_candidateEpoch.GetSize(IsFlexibleVersion) +
					_candidateId.GetSize(IsFlexibleVersion) +
					_lastOffsetEpoch.GetSize(IsFlexibleVersion) +
					_lastOffset.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CandidateEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.CandidateId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LastOffsetEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _candidateEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _candidateId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _lastOffsetEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _lastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _candidateEpoch = Int32.Default;
				/// <summary>
				/// <para>The bumped epoch of the candidate sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CandidateEpoch 
				{
					get => _candidateEpoch;
					private set 
					{
						_candidateEpoch = value;
					}
				}

				/// <summary>
				/// <para>The bumped epoch of the candidate sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCandidateEpoch(Int32 candidateEpoch)
				{
					CandidateEpoch = candidateEpoch;
					return this;
				}

				private Int32 _candidateId = Int32.Default;
				/// <summary>
				/// <para>The ID of the voter sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CandidateId 
				{
					get => _candidateId;
					private set 
					{
						_candidateId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the voter sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCandidateId(Int32 candidateId)
				{
					CandidateId = candidateId;
					return this;
				}

				private Int32 _lastOffsetEpoch = Int32.Default;
				/// <summary>
				/// <para>The epoch of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LastOffsetEpoch 
				{
					get => _lastOffsetEpoch;
					private set 
					{
						_lastOffsetEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLastOffsetEpoch(Int32 lastOffsetEpoch)
				{
					LastOffsetEpoch = lastOffsetEpoch;
					return this;
				}

				private Int64 _lastOffset = Int64.Default;
				/// <summary>
				/// <para>The offset of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 LastOffset 
				{
					get => _lastOffset;
					private set 
					{
						_lastOffset = value;
					}
				}

				/// <summary>
				/// <para>The offset of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLastOffset(Int64 lastOffset)
				{
					LastOffset = lastOffset;
					return this;
				}
			}
		}

		public VoteResponse Respond()
			=> new VoteResponse(Version);
	}

	public class VoteResponse : Message
	{
		public VoteResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"VoteResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(52);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_errorCode.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<VoteResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new VoteResponse(version);
			instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for VoteResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			private set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Array<TopicData> _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<TopicData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public delegate TopicData CreateTopicData(TopicData field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteResponse WithTopicsCollection(IEnumerable<CreateTopicData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new TopicData(Version)))
				.ToArray();
			return this;
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicName.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				private set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partitionIndex.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_leaderId.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					_voteGranted.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.VoteGranted = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _voteGranted.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					private set 
					{
						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					private set 
					{
						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Boolean _voteGranted = Boolean.Default;
				/// <summary>
				/// <para>True if the vote was granted and false otherwise</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean VoteGranted 
				{
					get => _voteGranted;
					private set 
					{
						_voteGranted = value;
					}
				}

				/// <summary>
				/// <para>True if the vote was granted and false otherwise</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithVoteGranted(Boolean voteGranted)
				{
					VoteGranted = voteGranted;
					return this;
				}
			}
		}
	}

	public class WriteShareGroupStateRequest : Message, IRespond<WriteShareGroupStateResponse>
	{
		public WriteShareGroupStateRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"WriteShareGroupStateRequest does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(85);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_groupId.GetSize(IsFlexibleVersion) +
			_topicsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<WriteShareGroupStateRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new WriteShareGroupStateRequest(version);
			instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TopicsCollection = await Array<WriteStateData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WriteStateData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteShareGroupStateRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _groupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			private set 
			{
				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteShareGroupStateRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Array<WriteStateData> _topicsCollection = Array.Empty<WriteStateData>();
		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<WriteStateData> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteShareGroupStateRequest WithTopicsCollection(params Func<WriteStateData, WriteStateData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new WriteStateData(Version)))
				.ToArray();
			return this;
		}

		public delegate WriteStateData CreateWriteStateData(WriteStateData field);

		/// <summary>
		/// <para>The data for the topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteShareGroupStateRequest WithTopicsCollection(IEnumerable<CreateWriteStateData> createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(new WriteStateData(Version)))
				.ToArray();
			return this;
		}

		public class WriteStateData : ISerialize
		{
			internal WriteStateData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<WriteStateData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new WriteStateData(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteStateData is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WriteStateData WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionData> _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionData> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WriteStateData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionData CreatePartitionData(PartitionData field);

			/// <summary>
			/// <para>The data for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WriteStateData WithPartitionsCollection(IEnumerable<CreatePartitionData> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionData(Version)))
					.ToArray();
				return this;
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_stateEpoch.GetSize(IsFlexibleVersion) +
					_leaderEpoch.GetSize(IsFlexibleVersion) +
					_startOffset.GetSize(IsFlexibleVersion) +
					_stateBatchesCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StateEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.StateBatchesCollection = await Array<StateBatch>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StateBatch.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _stateEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _leaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _startOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _stateBatchesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _stateEpoch = Int32.Default;
				/// <summary>
				/// <para>The state epoch for this share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 StateEpoch 
				{
					get => _stateEpoch;
					private set 
					{
						_stateEpoch = value;
					}
				}

				/// <summary>
				/// <para>The state epoch for this share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithStateEpoch(Int32 stateEpoch)
				{
					StateEpoch = stateEpoch;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					private set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the share-partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int64 _startOffset = Int64.Default;
				/// <summary>
				/// <para>The share-partition start offset, or -1 if the start offset is not being written.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 StartOffset 
				{
					get => _startOffset;
					private set 
					{
						_startOffset = value;
					}
				}

				/// <summary>
				/// <para>The share-partition start offset, or -1 if the start offset is not being written.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithStartOffset(Int64 startOffset)
				{
					StartOffset = startOffset;
					return this;
				}

				private Array<StateBatch> _stateBatchesCollection = Array.Empty<StateBatch>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<StateBatch> StateBatchesCollection 
				{
					get => _stateBatchesCollection;
					private set 
					{
						_stateBatchesCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithStateBatchesCollection(params Func<StateBatch, StateBatch>[] createFields)
				{
					StateBatchesCollection = createFields
						.Select(createField => createField(new StateBatch(Version)))
						.ToArray();
					return this;
				}

				public delegate StateBatch CreateStateBatch(StateBatch field);

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithStateBatchesCollection(IEnumerable<CreateStateBatch> createFields)
				{
					StateBatchesCollection = createFields
						.Select(createField => createField(new StateBatch(Version)))
						.ToArray();
					return this;
				}

				public class StateBatch : ISerialize
				{
					internal StateBatch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = true;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_firstOffset.GetSize(IsFlexibleVersion) +
						_lastOffset.GetSize(IsFlexibleVersion) +
						_deliveryState.GetSize(IsFlexibleVersion) +
						_deliveryCount.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<StateBatch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new StateBatch(version);
						instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.DeliveryState = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.DeliveryCount = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for StateBatch is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _firstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _lastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _deliveryState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _deliveryCount.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>The base offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						private set 
						{
							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>The base offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}

					private Int64 _lastOffset = Int64.Default;
					/// <summary>
					/// <para>The last offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 LastOffset 
					{
						get => _lastOffset;
						private set 
						{
							_lastOffset = value;
						}
					}

					/// <summary>
					/// <para>The last offset of this state batch.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithLastOffset(Int64 lastOffset)
					{
						LastOffset = lastOffset;
						return this;
					}

					private Int8 _deliveryState = Int8.Default;
					/// <summary>
					/// <para>The state - 0:Available,2:Acked,4:Archived</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int8 DeliveryState 
					{
						get => _deliveryState;
						private set 
						{
							_deliveryState = value;
						}
					}

					/// <summary>
					/// <para>The state - 0:Available,2:Acked,4:Archived</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithDeliveryState(Int8 deliveryState)
					{
						DeliveryState = deliveryState;
						return this;
					}

					private Int16 _deliveryCount = Int16.Default;
					/// <summary>
					/// <para>The delivery count.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int16 DeliveryCount 
					{
						get => _deliveryCount;
						private set 
						{
							_deliveryCount = value;
						}
					}

					/// <summary>
					/// <para>The delivery count.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public StateBatch WithDeliveryCount(Int16 deliveryCount)
					{
						DeliveryCount = deliveryCount;
						return this;
					}
				}
			}
		}

		public WriteShareGroupStateResponse Respond()
			=> new WriteShareGroupStateResponse(Version);
	}

	public class WriteShareGroupStateResponse : Message
	{
		public WriteShareGroupStateResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"WriteShareGroupStateResponse does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(85);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_resultsCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<WriteShareGroupStateResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new WriteShareGroupStateResponse(version);
			instance.ResultsCollection = await Array<WriteStateResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WriteStateResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteShareGroupStateResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _resultsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<WriteStateResult> _resultsCollection = Array.Empty<WriteStateResult>();
		/// <summary>
		/// <para>The write results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<WriteStateResult> ResultsCollection 
		{
			get => _resultsCollection;
			private set 
			{
				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The write results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteShareGroupStateResponse WithResultsCollection(params Func<WriteStateResult, WriteStateResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new WriteStateResult(Version)))
				.ToArray();
			return this;
		}

		public delegate WriteStateResult CreateWriteStateResult(WriteStateResult field);

		/// <summary>
		/// <para>The write results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteShareGroupStateResponse WithResultsCollection(IEnumerable<CreateWriteStateResult> createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(new WriteStateResult(Version)))
				.ToArray();
			return this;
		}

		public class WriteStateResult : ISerialize
		{
			internal WriteStateResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topicId.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<WriteStateResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new WriteStateResult(version);
				instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteStateResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				private set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic identifier</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WriteStateResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Array<PartitionResult> _partitionsCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<PartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WriteStateResult WithPartitionsCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public delegate PartitionResult CreatePartitionResult(PartitionResult field);

			/// <summary>
			/// <para>The results for the partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WriteStateResult WithPartitionsCollection(IEnumerable<CreatePartitionResult> createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(new PartitionResult(Version)))
					.ToArray();
				return this;
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_partition.GetSize(IsFlexibleVersion) +
					_errorCode.GetSize(IsFlexibleVersion) +
					_errorMessage.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _errorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					private set 
					{
						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					private set 
					{
						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private NullableString _errorMessage = new NullableString(null);
				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					private set 
					{
						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class WriteTxnMarkersRequest : Message, IRespond<WriteTxnMarkersResponse>
	{
		public WriteTxnMarkersRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"WriteTxnMarkersRequest does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(27);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 2 : 1);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_markersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<WriteTxnMarkersRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new WriteTxnMarkersRequest(version);
			instance.MarkersCollection = await Array<WritableTxnMarker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarker.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteTxnMarkersRequest is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _markersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<WritableTxnMarker> _markersCollection = Array.Empty<WritableTxnMarker>();
		/// <summary>
		/// <para>The transaction markers to be written.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<WritableTxnMarker> MarkersCollection 
		{
			get => _markersCollection;
			private set 
			{
				_markersCollection = value;
			}
		}

		/// <summary>
		/// <para>The transaction markers to be written.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteTxnMarkersRequest WithMarkersCollection(params Func<WritableTxnMarker, WritableTxnMarker>[] createFields)
		{
			MarkersCollection = createFields
				.Select(createField => createField(new WritableTxnMarker(Version)))
				.ToArray();
			return this;
		}

		public delegate WritableTxnMarker CreateWritableTxnMarker(WritableTxnMarker field);

		/// <summary>
		/// <para>The transaction markers to be written.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteTxnMarkersRequest WithMarkersCollection(IEnumerable<CreateWritableTxnMarker> createFields)
		{
			MarkersCollection = createFields
				.Select(createField => createField(new WritableTxnMarker(Version)))
				.ToArray();
			return this;
		}

		public class WritableTxnMarker : ISerialize
		{
			internal WritableTxnMarker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_producerId.GetSize(IsFlexibleVersion) +
				_producerEpoch.GetSize(IsFlexibleVersion) +
				_transactionResult.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				_coordinatorEpoch.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<WritableTxnMarker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new WritableTxnMarker(version);
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TransactionResult = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Array<WritableTxnMarkerTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				instance.CoordinatorEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarker is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _producerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _transactionResult.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _coordinatorEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>The current producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				private set 
				{
					_producerId = value;
				}
			}

			/// <summary>
			/// <para>The current producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private Int16 _producerEpoch = Int16.Default;
			/// <summary>
			/// <para>The current epoch associated with the producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ProducerEpoch 
			{
				get => _producerEpoch;
				private set 
				{
					_producerEpoch = value;
				}
			}

			/// <summary>
			/// <para>The current epoch associated with the producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithProducerEpoch(Int16 producerEpoch)
			{
				ProducerEpoch = producerEpoch;
				return this;
			}

			private Boolean _transactionResult = Boolean.Default;
			/// <summary>
			/// <para>The result of the transaction to write to the partitions (false = ABORT, true = COMMIT).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Boolean TransactionResult 
			{
				get => _transactionResult;
				private set 
				{
					_transactionResult = value;
				}
			}

			/// <summary>
			/// <para>The result of the transaction to write to the partitions (false = ABORT, true = COMMIT).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithTransactionResult(Boolean transactionResult)
			{
				TransactionResult = transactionResult;
				return this;
			}

			private Array<WritableTxnMarkerTopic> _topicsCollection = Array.Empty<WritableTxnMarkerTopic>();
			/// <summary>
			/// <para>Each topic that we want to write transaction marker(s) for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<WritableTxnMarkerTopic> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each topic that we want to write transaction marker(s) for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithTopicsCollection(params Func<WritableTxnMarkerTopic, WritableTxnMarkerTopic>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new WritableTxnMarkerTopic(Version)))
					.ToArray();
				return this;
			}

			public delegate WritableTxnMarkerTopic CreateWritableTxnMarkerTopic(WritableTxnMarkerTopic field);

			/// <summary>
			/// <para>Each topic that we want to write transaction marker(s) for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithTopicsCollection(IEnumerable<CreateWritableTxnMarkerTopic> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new WritableTxnMarkerTopic(Version)))
					.ToArray();
				return this;
			}

			public class WritableTxnMarkerTopic : ISerialize
			{
				internal WritableTxnMarkerTopic(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_partitionIndexesCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<WritableTxnMarkerTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new WritableTxnMarkerTopic(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerTopic is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionIndexesCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopic WithName(String name)
				{
					Name = name;
					return this;
				}

				private Array<Int32> _partitionIndexesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The indexes of the partitions to write transaction markers for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<Int32> PartitionIndexesCollection 
				{
					get => _partitionIndexesCollection;
					private set 
					{
						_partitionIndexesCollection = value;
					}
				}

				/// <summary>
				/// <para>The indexes of the partitions to write transaction markers for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopic WithPartitionIndexesCollection(Array<Int32> partitionIndexesCollection)
				{
					PartitionIndexesCollection = partitionIndexesCollection;
					return this;
				}
			}

			private Int32 _coordinatorEpoch = Int32.Default;
			/// <summary>
			/// <para>Epoch associated with the transaction state partition hosted by this transaction coordinator</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 CoordinatorEpoch 
			{
				get => _coordinatorEpoch;
				private set 
				{
					_coordinatorEpoch = value;
				}
			}

			/// <summary>
			/// <para>Epoch associated with the transaction state partition hosted by this transaction coordinator</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithCoordinatorEpoch(Int32 coordinatorEpoch)
			{
				CoordinatorEpoch = coordinatorEpoch;
				return this;
			}
		}

		public WriteTxnMarkersResponse Respond()
			=> new WriteTxnMarkersResponse(Version);
	}

	public class WriteTxnMarkersResponse : Message
	{
		public WriteTxnMarkersResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"WriteTxnMarkersResponse does not support version {version}. Valid versions are: 0-1");

			Version = version;
			IsFlexibleVersion = version >= 1;
		}

		internal override Int16 ApiMessageKey => ApiKey;
		public static readonly Int16 ApiKey = Int16.From(27);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public Int16 HeaderVersion 
		{
			get
			{
				return (short)(IsFlexibleVersion ? 1 : 0);
			}
		}

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal override int GetSize() =>
			_markersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		internal static async ValueTask<WriteTxnMarkersResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new WriteTxnMarkersResponse(version);
			instance.MarkersCollection = await Array<WritableTxnMarkerResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteTxnMarkersResponse is unknown");
					}
				}
			}

			return instance;
		}

		internal override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			await _markersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (IsFlexibleVersion)
				await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
		}

		private Array<WritableTxnMarkerResult> _markersCollection = Array.Empty<WritableTxnMarkerResult>();
		/// <summary>
		/// <para>The results for writing makers.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<WritableTxnMarkerResult> MarkersCollection 
		{
			get => _markersCollection;
			private set 
			{
				_markersCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for writing makers.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteTxnMarkersResponse WithMarkersCollection(params Func<WritableTxnMarkerResult, WritableTxnMarkerResult>[] createFields)
		{
			MarkersCollection = createFields
				.Select(createField => createField(new WritableTxnMarkerResult(Version)))
				.ToArray();
			return this;
		}

		public delegate WritableTxnMarkerResult CreateWritableTxnMarkerResult(WritableTxnMarkerResult field);

		/// <summary>
		/// <para>The results for writing makers.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteTxnMarkersResponse WithMarkersCollection(IEnumerable<CreateWritableTxnMarkerResult> createFields)
		{
			MarkersCollection = createFields
				.Select(createField => createField(new WritableTxnMarkerResult(Version)))
				.ToArray();
			return this;
		}

		public class WritableTxnMarkerResult : ISerialize
		{
			internal WritableTxnMarkerResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version >= 1;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_producerId.GetSize(IsFlexibleVersion) +
				_topicsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<WritableTxnMarkerResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new WritableTxnMarkerResult(version);
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.TopicsCollection = await Array<WritableTxnMarkerTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerResult is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _producerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>The current producer ID in use by the transactional ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				private set 
				{
					_producerId = value;
				}
			}

			/// <summary>
			/// <para>The current producer ID in use by the transactional ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerResult WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private Array<WritableTxnMarkerTopicResult> _topicsCollection = Array.Empty<WritableTxnMarkerTopicResult>();
			/// <summary>
			/// <para>The results by topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<WritableTxnMarkerTopicResult> TopicsCollection 
			{
				get => _topicsCollection;
				private set 
				{
					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results by topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerResult WithTopicsCollection(params Func<WritableTxnMarkerTopicResult, WritableTxnMarkerTopicResult>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new WritableTxnMarkerTopicResult(Version)))
					.ToArray();
				return this;
			}

			public delegate WritableTxnMarkerTopicResult CreateWritableTxnMarkerTopicResult(WritableTxnMarkerTopicResult field);

			/// <summary>
			/// <para>The results by topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerResult WithTopicsCollection(IEnumerable<CreateWritableTxnMarkerTopicResult> createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(new WritableTxnMarkerTopicResult(Version)))
					.ToArray();
				return this;
			}

			public class WritableTxnMarkerTopicResult : ISerialize
			{
				internal WritableTxnMarkerTopicResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version >= 1;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_partitionsCollection.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<WritableTxnMarkerTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new WritableTxnMarkerTopicResult(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.PartitionsCollection = await Array<WritableTxnMarkerPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerTopicResult is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopicResult WithName(String name)
				{
					Name = name;
					return this;
				}

				private Array<WritableTxnMarkerPartitionResult> _partitionsCollection = Array.Empty<WritableTxnMarkerPartitionResult>();
				/// <summary>
				/// <para>The results by partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Array<WritableTxnMarkerPartitionResult> PartitionsCollection 
				{
					get => _partitionsCollection;
					private set 
					{
						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The results by partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopicResult WithPartitionsCollection(params Func<WritableTxnMarkerPartitionResult, WritableTxnMarkerPartitionResult>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new WritableTxnMarkerPartitionResult(Version)))
						.ToArray();
					return this;
				}

				public delegate WritableTxnMarkerPartitionResult CreateWritableTxnMarkerPartitionResult(WritableTxnMarkerPartitionResult field);

				/// <summary>
				/// <para>The results by partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopicResult WithPartitionsCollection(IEnumerable<CreateWritableTxnMarkerPartitionResult> createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(new WritableTxnMarkerPartitionResult(Version)))
						.ToArray();
					return this;
				}

				public class WritableTxnMarkerPartitionResult : ISerialize
				{
					internal WritableTxnMarkerPartitionResult(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version >= 1;
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					private Tags.TagSection CreateTagSection()
					{
						return new Tags.TagSection();
					}

					int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
					internal int GetSize(bool _) =>
						_partitionIndex.GetSize(IsFlexibleVersion) +
						_errorCode.GetSize(IsFlexibleVersion) +
						(IsFlexibleVersion ? 
							CreateTagSection().GetSize() :
							0);

					internal static async ValueTask<WritableTxnMarkerPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new WritableTxnMarkerPartitionResult(version);
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerPartitionResult is unknown");
								}
							}
						}

						return instance;
					}

					ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
					internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						await _partitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						await _errorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

						if (IsFlexibleVersion)
							await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						private set 
						{
							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public WritableTxnMarkerPartitionResult WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int16 _errorCode = Int16.Default;
					/// <summary>
					/// <para>The error code, or 0 if there was no error.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int16 ErrorCode 
					{
						get => _errorCode;
						private set 
						{
							_errorCode = value;
						}
					}

					/// <summary>
					/// <para>The error code, or 0 if there was no error.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public WritableTxnMarkerPartitionResult WithErrorCode(Int16 errorCode)
					{
						ErrorCode = errorCode;
						return this;
					}
				}
			}
		}
	}

	public class ConsumerProtocolAssignment
	{
		public ConsumerProtocolAssignment(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ConsumerProtocolAssignment does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = false;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_assignedPartitionsCollection.GetSize(IsFlexibleVersion) +
			_userData.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<ConsumerProtocolAssignment> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new ConsumerProtocolAssignment(version);
			instance.AssignedPartitionsCollection = await Map<String, TopicPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartition.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);
			instance.UserData = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerProtocolAssignment is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _assignedPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _userData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Map<String, TopicPartition> _assignedPartitionsCollection = Map<String, TopicPartition>.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Map<String, TopicPartition> AssignedPartitionsCollection 
		{
			get => _assignedPartitionsCollection;
			private set 
			{
				_assignedPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerProtocolAssignment WithAssignedPartitionsCollection(params Func<TopicPartition, TopicPartition>[] createFields)
		{
			AssignedPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartition(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public delegate TopicPartition CreateTopicPartition(TopicPartition field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerProtocolAssignment WithAssignedPartitionsCollection(IEnumerable<CreateTopicPartition> createFields)
		{
			AssignedPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartition(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public class TopicPartition : ISerialize
		{
			internal TopicPartition(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_topic.GetSize(IsFlexibleVersion) +
				_partitionsCollection.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartition(version);
				instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartition is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartition WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartition WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private NullableBytes _userData = new NullableBytes(null);
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Bytes? UserData 
		{
			get => _userData;
			private set 
			{
				_userData = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerProtocolAssignment WithUserData(Bytes? userData)
		{
			UserData = userData;
			return this;
		}
	}

	public class ConsumerProtocolSubscription
	{
		public ConsumerProtocolSubscription(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"ConsumerProtocolSubscription does not support version {version}. Valid versions are: 0-3");

			Version = version;
			IsFlexibleVersion = false;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_topicsCollection.GetSize(IsFlexibleVersion) +
			_userData.GetSize(IsFlexibleVersion) +
			(Version >= 1 ? 
				_ownedPartitionsCollection.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 2 ? 
				_generationId.GetSize(IsFlexibleVersion):
				0) +
			(Version >= 3 ? 
				_rackId.GetSize(IsFlexibleVersion):
				0) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<ConsumerProtocolSubscription> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new ConsumerProtocolSubscription(version);
			instance.TopicsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.UserData = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 1) 
				instance.OwnedPartitionsCollection = await Map<String, TopicPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartition.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Topic, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 2) 
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			if (instance.Version >= 3) 
				instance.RackId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerProtocolSubscription is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _topicsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _userData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _ownedPartitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 2)
					await _generationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 3)
					await _rackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Array<String> _topicsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<String> TopicsCollection 
		{
			get => _topicsCollection;
			private set 
			{
				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerProtocolSubscription WithTopicsCollection(Array<String> topicsCollection)
		{
			TopicsCollection = topicsCollection;
			return this;
		}

		private NullableBytes _userData = new NullableBytes(null);
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Bytes? UserData 
		{
			get => _userData;
			private set 
			{
				_userData = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerProtocolSubscription WithUserData(Bytes? userData)
		{
			UserData = userData;
			return this;
		}

		private Map<String, TopicPartition> _ownedPartitionsCollection = Map<String, TopicPartition>.Default;
		/// <summary>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Map<String, TopicPartition> OwnedPartitionsCollection 
		{
			get => _ownedPartitionsCollection;
			private set 
			{
				_ownedPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ConsumerProtocolSubscription WithOwnedPartitionsCollection(params Func<TopicPartition, TopicPartition>[] createFields)
		{
			OwnedPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartition(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public delegate TopicPartition CreateTopicPartition(TopicPartition field);

		/// <summary>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ConsumerProtocolSubscription WithOwnedPartitionsCollection(IEnumerable<CreateTopicPartition> createFields)
		{
			OwnedPartitionsCollection = createFields
				.Select(createField => createField(new TopicPartition(Version)))
				.ToDictionary(field => field.Topic);
			return this;
		}

		public class TopicPartition : ISerialize
		{
			internal TopicPartition(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = false;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				(Version >= 1 ? 
					_topic.GetSize(IsFlexibleVersion):
					0) +
				(Version >= 1 ? 
					_partitionsCollection.GetSize(IsFlexibleVersion):
					0) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<TopicPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartition(version);
				if (instance.Version >= 1) 
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (instance.Version >= 1) 
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartition is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version >= 1)
					await _topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				if (Version >= 1)
					await _partitionsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				private set 
				{
					if (Version >= 1 == false)
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

					_topic = value;
				}
			}

			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public TopicPartition WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Array<Int32> _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public Array<Int32> PartitionsCollection 
			{
				get => _partitionsCollection;
				private set 
				{
					if (Version >= 1 == false)
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public TopicPartition WithPartitionsCollection(Array<Int32> partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private Int32 _generationId = new Int32(-1);
		/// <summary>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			private set 
			{
				_generationId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ConsumerProtocolSubscription WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private NullableString _rackId = new NullableString(null);
		/// <summary>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? RackId 
		{
			get => _rackId;
			private set 
			{
				if (Version >= 3 == false &&
					value == null) 
					throw new UnsupportedVersionException($"RackId does not support null for version {Version}. Supported versions for null value: 3+");

				_rackId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerProtocolSubscription WithRackId(String? rackId)
		{
			RackId = rackId;
			return this;
		}
	}

	public class DefaultPrincipalData
	{
		public DefaultPrincipalData(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"DefaultPrincipalData does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_type.GetSize(IsFlexibleVersion) +
			_name.GetSize(IsFlexibleVersion) +
			_tokenAuthenticated.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<DefaultPrincipalData> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new DefaultPrincipalData(version);
			instance.Type = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.TokenAuthenticated = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DefaultPrincipalData is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _type.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _tokenAuthenticated.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private String _type = String.Default;
		/// <summary>
		/// <para>The principal type</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Type 
		{
			get => _type;
			private set 
			{
				_type = value;
			}
		}

		/// <summary>
		/// <para>The principal type</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DefaultPrincipalData WithType(String type)
		{
			Type = type;
			return this;
		}

		private String _name = String.Default;
		/// <summary>
		/// <para>The principal name</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Name 
		{
			get => _name;
			private set 
			{
				_name = value;
			}
		}

		/// <summary>
		/// <para>The principal name</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DefaultPrincipalData WithName(String name)
		{
			Name = name;
			return this;
		}

		private Boolean _tokenAuthenticated = Boolean.Default;
		/// <summary>
		/// <para>Whether the principal was authenticated by a delegation token on the forwarding broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean TokenAuthenticated 
		{
			get => _tokenAuthenticated;
			private set 
			{
				_tokenAuthenticated = value;
			}
		}

		/// <summary>
		/// <para>Whether the principal was authenticated by a delegation token on the forwarding broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DefaultPrincipalData WithTokenAuthenticated(Boolean tokenAuthenticated)
		{
			TokenAuthenticated = tokenAuthenticated;
			return this;
		}
	}

	public class KRaftVersionRecord
	{
		public KRaftVersionRecord(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"KRaftVersionRecord does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_version.GetSize(IsFlexibleVersion) +
			_kRaftVersion.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<KRaftVersionRecord> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new KRaftVersionRecord(version);
			instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.KRaftVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for KRaftVersionRecord is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _kRaftVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the kraft version record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			private set 
			{
				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the kraft version record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public KRaftVersionRecord WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		private Int16 _kRaftVersion = Int16.Default;
		/// <summary>
		/// <para>The kraft protocol version</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 KRaftVersion 
		{
			get => _kRaftVersion;
			private set 
			{
				_kRaftVersion = value;
			}
		}

		/// <summary>
		/// <para>The kraft protocol version</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public KRaftVersionRecord WithKRaftVersion(Int16 kRaftVersion)
		{
			KRaftVersion = kRaftVersion;
			return this;
		}
	}

	public class LeaderChangeMessage
	{
		public LeaderChangeMessage(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"LeaderChangeMessage does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_version.GetSize(IsFlexibleVersion) +
			_leaderId.GetSize(IsFlexibleVersion) +
			_votersCollection.GetSize(IsFlexibleVersion) +
			_grantingVotersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<LeaderChangeMessage> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new LeaderChangeMessage(version);
			instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VotersCollection = await Array<Voter>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Voter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			instance.GrantingVotersCollection = await Array<Voter>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Voter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderChangeMessage is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _leaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _votersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _grantingVotersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the leader change message</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			private set 
			{
				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the leader change message</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		private Int32 _leaderId = Int32.Default;
		/// <summary>
		/// <para>The ID of the newly elected leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 LeaderId 
		{
			get => _leaderId;
			private set 
			{
				_leaderId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the newly elected leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithLeaderId(Int32 leaderId)
		{
			LeaderId = leaderId;
			return this;
		}

		private Array<Voter> _votersCollection = Array.Empty<Voter>();
		/// <summary>
		/// <para>The set of voters in the quorum for this epoch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<Voter> VotersCollection 
		{
			get => _votersCollection;
			private set 
			{
				_votersCollection = value;
			}
		}

		/// <summary>
		/// <para>The set of voters in the quorum for this epoch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithVotersCollection(Array<Voter> votersCollection)
		{
			VotersCollection = votersCollection;
			return this;
		}

		private Array<Voter> _grantingVotersCollection = Array.Empty<Voter>();
		/// <summary>
		/// <para>The voters who voted for the leader at the time of election</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<Voter> GrantingVotersCollection 
		{
			get => _grantingVotersCollection;
			private set 
			{
				_grantingVotersCollection = value;
			}
		}

		/// <summary>
		/// <para>The voters who voted for the leader at the time of election</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithGrantingVotersCollection(Array<Voter> grantingVotersCollection)
		{
			GrantingVotersCollection = grantingVotersCollection;
			return this;
		}

		public class Voter : ISerialize
		{
			internal Voter(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_voterId.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Voter> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Voter(version);
				instance.VoterId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Voter is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _voterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _voterId = Int32.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 VoterId 
			{
				get => _voterId;
				private set 
				{
					_voterId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithVoterId(Int32 voterId)
			{
				VoterId = voterId;
				return this;
			}
		}
	}

	public class SnapshotFooterRecord
	{
		public SnapshotFooterRecord(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SnapshotFooterRecord does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_version.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<SnapshotFooterRecord> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new SnapshotFooterRecord(version);
			instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotFooterRecord is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the snapshot footer record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			private set 
			{
				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the snapshot footer record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SnapshotFooterRecord WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}
	}

	public class SnapshotHeaderRecord
	{
		public SnapshotHeaderRecord(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"SnapshotHeaderRecord does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_version.GetSize(IsFlexibleVersion) +
			_lastContainedLogTimestamp.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<SnapshotHeaderRecord> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new SnapshotHeaderRecord(version);
			instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.LastContainedLogTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotHeaderRecord is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _lastContainedLogTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the snapshot header record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			private set 
			{
				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the snapshot header record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SnapshotHeaderRecord WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		private Int64 _lastContainedLogTimestamp = Int64.Default;
		/// <summary>
		/// <para>The append time of the last record from the log contained in this snapshot</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 LastContainedLogTimestamp 
		{
			get => _lastContainedLogTimestamp;
			private set 
			{
				_lastContainedLogTimestamp = value;
			}
		}

		/// <summary>
		/// <para>The append time of the last record from the log contained in this snapshot</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SnapshotHeaderRecord WithLastContainedLogTimestamp(Int64 lastContainedLogTimestamp)
		{
			LastContainedLogTimestamp = lastContainedLogTimestamp;
			return this;
		}
	}

	public class VotersRecord
	{
		public VotersRecord(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
				throw new UnsupportedVersionException($"VotersRecord does not support version {version}. Valid versions are: 0");

			Version = version;
			IsFlexibleVersion = true;
		}

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		private Tags.TagSection CreateTagSection()
		{
			return new Tags.TagSection();
		}

		internal int GetSize() =>
			_version.GetSize(IsFlexibleVersion) +
			_votersCollection.GetSize(IsFlexibleVersion) +
			(IsFlexibleVersion ? 
				CreateTagSection().GetSize() :
				0);

		public static async ValueTask<VotersRecord> FromBytesAsync(Bytes data, CancellationToken cancellationToken = default)
		{
			var pipe = new Pipe();
			await pipe.Writer.WriteAsync(data.Value, cancellationToken).ConfigureAwait(false);
			var reader = pipe.Reader;

			var version = await Int16.FromReaderAsync(reader, false, cancellationToken).ConfigureAwait(false);
			var instance = new VotersRecord(version);
			instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			instance.VotersCollection = await Array<Voter>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Voter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for VotersRecord is unknown");
					}
				}
			}

			return instance;
		}

		public async ValueTask<Bytes> ToBytesAsync(CancellationToken cancellationToken = default)
		{
			var writer = new MemoryStream();
			await using (writer.ConfigureAwait(false))
			{
				await Version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _version.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _votersCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				return new Bytes(writer.ToArray());
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the voters record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			private set 
			{
				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the voters record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VotersRecord WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		private Array<Voter> _votersCollection = Array.Empty<Voter>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Array<Voter> VotersCollection 
		{
			get => _votersCollection;
			private set 
			{
				_votersCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VotersRecord WithVotersCollection(params Func<Voter, Voter>[] createFields)
		{
			VotersCollection = createFields
				.Select(createField => createField(new Voter(Version)))
				.ToArray();
			return this;
		}

		public delegate Voter CreateVoter(Voter field);

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VotersRecord WithVotersCollection(IEnumerable<CreateVoter> createFields)
		{
			VotersCollection = createFields
				.Select(createField => createField(new Voter(Version)))
				.ToArray();
			return this;
		}

		public class Voter : ISerialize
		{
			internal Voter(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = true;
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			private Tags.TagSection CreateTagSection()
			{
				return new Tags.TagSection();
			}

			int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
			internal int GetSize(bool _) =>
				_voterId.GetSize(IsFlexibleVersion) +
				_voterDirectoryId.GetSize(IsFlexibleVersion) +
				_endpointsCollection.GetSize(IsFlexibleVersion) +
				_kRaftVersionFeature.GetSize(IsFlexibleVersion) +
				(IsFlexibleVersion ? 
					CreateTagSection().GetSize() :
					0);

			internal static async ValueTask<Voter> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Voter(version);
				instance.VoterId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.VoterDirectoryId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				instance.EndpointsCollection = await Map<String, Endpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Endpoint.FromReaderAsync(instance.Version, reader, cancellationToken), field => field.Name, cancellationToken).ConfigureAwait(false);
				instance.KRaftVersionFeature_ = await KRaftVersionFeature.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Voter is unknown");
						}
					}
				}

				return instance;
			}

			ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
			internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				await _voterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _voterDirectoryId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _endpointsCollection.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				await _kRaftVersionFeature.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

				if (IsFlexibleVersion)
					await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
			}

			private Int32 _voterId = Int32.Default;
			/// <summary>
			/// <para>The replica id of the voter in the topic partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 VoterId 
			{
				get => _voterId;
				private set 
				{
					_voterId = value;
				}
			}

			/// <summary>
			/// <para>The replica id of the voter in the topic partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithVoterId(Int32 voterId)
			{
				VoterId = voterId;
				return this;
			}

			private Uuid _voterDirectoryId = Uuid.Default;
			/// <summary>
			/// <para>The directory id of the voter in the topic partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Uuid VoterDirectoryId 
			{
				get => _voterDirectoryId;
				private set 
				{
					_voterDirectoryId = value;
				}
			}

			/// <summary>
			/// <para>The directory id of the voter in the topic partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithVoterDirectoryId(Uuid voterDirectoryId)
			{
				VoterDirectoryId = voterDirectoryId;
				return this;
			}

			private Map<String, Endpoint> _endpointsCollection = Map<String, Endpoint>.Default;
			/// <summary>
			/// <para>The endpoint that can be used to communicate with the voter</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Map<String, Endpoint> EndpointsCollection 
			{
				get => _endpointsCollection;
				private set 
				{
					_endpointsCollection = value;
				}
			}

			/// <summary>
			/// <para>The endpoint that can be used to communicate with the voter</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithEndpointsCollection(params Func<Endpoint, Endpoint>[] createFields)
			{
				EndpointsCollection = createFields
					.Select(createField => createField(new Endpoint(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public delegate Endpoint CreateEndpoint(Endpoint field);

			/// <summary>
			/// <para>The endpoint that can be used to communicate with the voter</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithEndpointsCollection(IEnumerable<CreateEndpoint> createFields)
			{
				EndpointsCollection = createFields
					.Select(createField => createField(new Endpoint(Version)))
					.ToDictionary(field => field.Name);
				return this;
			}

			public class Endpoint : ISerialize
			{
				internal Endpoint(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_name.GetSize(IsFlexibleVersion) +
					_host.GetSize(IsFlexibleVersion) +
					_port.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<Endpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new Endpoint(version);
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for Endpoint is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The name of the endpoint</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					private set 
					{
						_name = value;
					}
				}

				/// <summary>
				/// <para>The name of the endpoint</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Endpoint WithName(String name)
				{
					Name = name;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The hostname</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					private set 
					{
						_host = value;
					}
				}

				/// <summary>
				/// <para>The hostname</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Endpoint WithHost(String host)
				{
					Host = host;
					return this;
				}

				private UInt16 _port = UInt16.Default;
				/// <summary>
				/// <para>The port</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public UInt16 Port 
				{
					get => _port;
					private set 
					{
						_port = value;
					}
				}

				/// <summary>
				/// <para>The port</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Endpoint WithPort(UInt16 port)
				{
					Port = port;
					return this;
				}
			}

			private KRaftVersionFeature _kRaftVersionFeature = default!;
			/// <summary>
			/// <para>The range of versions of the protocol that the replica supports</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public KRaftVersionFeature KRaftVersionFeature_ 
			{
				get => _kRaftVersionFeature;
				private set 
				{
					_kRaftVersionFeature = value;
				}
			}

			/// <summary>
			/// <para>The range of versions of the protocol that the replica supports</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithKRaftVersionFeature_(Func<KRaftVersionFeature, KRaftVersionFeature> createField)
			{
				KRaftVersionFeature_ = createField(new KRaftVersionFeature(Version));
				return this;
			}

			public class KRaftVersionFeature : ISerialize
			{
				internal KRaftVersionFeature(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = true;
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				private Tags.TagSection CreateTagSection()
				{
					return new Tags.TagSection();
				}

				int ISerialize.GetSize(bool asCompact) => GetSize(asCompact);
				internal int GetSize(bool _) =>
					_minSupportedVersion.GetSize(IsFlexibleVersion) +
					_maxSupportedVersion.GetSize(IsFlexibleVersion) +
					(IsFlexibleVersion ? 
						CreateTagSection().GetSize() :
						0);

				internal static async ValueTask<KRaftVersionFeature> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new KRaftVersionFeature(version);
					instance.MinSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					instance.MaxSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for KRaftVersionFeature is unknown");
							}
						}
					}

					return instance;
				}

				ValueTask ISerialize.WriteToAsync(Stream writer, bool asCompact, CancellationToken cancellationToken) => WriteToAsync(writer, asCompact, cancellationToken);
				internal async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					await _minSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					await _maxSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);

					if (IsFlexibleVersion)
						await CreateTagSection().WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
				}

				private Int16 _minSupportedVersion = Int16.Default;
				/// <summary>
				/// <para>The minimum supported KRaft protocol version</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 MinSupportedVersion 
				{
					get => _minSupportedVersion;
					private set 
					{
						_minSupportedVersion = value;
					}
				}

				/// <summary>
				/// <para>The minimum supported KRaft protocol version</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public KRaftVersionFeature WithMinSupportedVersion(Int16 minSupportedVersion)
				{
					MinSupportedVersion = minSupportedVersion;
					return this;
				}

				private Int16 _maxSupportedVersion = Int16.Default;
				/// <summary>
				/// <para>The maximum supported KRaft protocol version</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 MaxSupportedVersion 
				{
					get => _maxSupportedVersion;
					private set 
					{
						_maxSupportedVersion = value;
					}
				}

				/// <summary>
				/// <para>The maximum supported KRaft protocol version</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public KRaftVersionFeature WithMaxSupportedVersion(Int16 maxSupportedVersion)
				{
					MaxSupportedVersion = maxSupportedVersion;
					return this;
				}
			}
		}
	}

	public static class ResponseExtensions
	{
		public static ApiVersionsResponse WithAllApiKeys(this ApiVersionsResponse response)
		{
			return response.WithApiKeysCollection(
				key => key
					.WithApiKey(AddOffsetsToTxnRequest.ApiKey)
					.WithMinVersion(AddOffsetsToTxnRequest.MinVersion)
					.WithMaxVersion(AddOffsetsToTxnRequest.MaxVersion),
				key => key
					.WithApiKey(AddPartitionsToTxnRequest.ApiKey)
					.WithMinVersion(AddPartitionsToTxnRequest.MinVersion)
					.WithMaxVersion(AddPartitionsToTxnRequest.MaxVersion),
				key => key
					.WithApiKey(AddRaftVoterRequest.ApiKey)
					.WithMinVersion(AddRaftVoterRequest.MinVersion)
					.WithMaxVersion(AddRaftVoterRequest.MaxVersion),
				key => key
					.WithApiKey(AllocateProducerIdsRequest.ApiKey)
					.WithMinVersion(AllocateProducerIdsRequest.MinVersion)
					.WithMaxVersion(AllocateProducerIdsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterClientQuotasRequest.ApiKey)
					.WithMinVersion(AlterClientQuotasRequest.MinVersion)
					.WithMaxVersion(AlterClientQuotasRequest.MaxVersion),
				key => key
					.WithApiKey(AlterConfigsRequest.ApiKey)
					.WithMinVersion(AlterConfigsRequest.MinVersion)
					.WithMaxVersion(AlterConfigsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterPartitionReassignmentsRequest.ApiKey)
					.WithMinVersion(AlterPartitionReassignmentsRequest.MinVersion)
					.WithMaxVersion(AlterPartitionReassignmentsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterPartitionRequest.ApiKey)
					.WithMinVersion(AlterPartitionRequest.MinVersion)
					.WithMaxVersion(AlterPartitionRequest.MaxVersion),
				key => key
					.WithApiKey(AlterReplicaLogDirsRequest.ApiKey)
					.WithMinVersion(AlterReplicaLogDirsRequest.MinVersion)
					.WithMaxVersion(AlterReplicaLogDirsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterUserScramCredentialsRequest.ApiKey)
					.WithMinVersion(AlterUserScramCredentialsRequest.MinVersion)
					.WithMaxVersion(AlterUserScramCredentialsRequest.MaxVersion),
				key => key
					.WithApiKey(ApiVersionsRequest.ApiKey)
					.WithMinVersion(ApiVersionsRequest.MinVersion)
					.WithMaxVersion(ApiVersionsRequest.MaxVersion),
				key => key
					.WithApiKey(AssignReplicasToDirsRequest.ApiKey)
					.WithMinVersion(AssignReplicasToDirsRequest.MinVersion)
					.WithMaxVersion(AssignReplicasToDirsRequest.MaxVersion),
				key => key
					.WithApiKey(BeginQuorumEpochRequest.ApiKey)
					.WithMinVersion(BeginQuorumEpochRequest.MinVersion)
					.WithMaxVersion(BeginQuorumEpochRequest.MaxVersion),
				key => key
					.WithApiKey(BrokerHeartbeatRequest.ApiKey)
					.WithMinVersion(BrokerHeartbeatRequest.MinVersion)
					.WithMaxVersion(BrokerHeartbeatRequest.MaxVersion),
				key => key
					.WithApiKey(BrokerRegistrationRequest.ApiKey)
					.WithMinVersion(BrokerRegistrationRequest.MinVersion)
					.WithMaxVersion(BrokerRegistrationRequest.MaxVersion),
				key => key
					.WithApiKey(ConsumerGroupDescribeRequest.ApiKey)
					.WithMinVersion(ConsumerGroupDescribeRequest.MinVersion)
					.WithMaxVersion(ConsumerGroupDescribeRequest.MaxVersion),
				key => key
					.WithApiKey(ConsumerGroupHeartbeatRequest.ApiKey)
					.WithMinVersion(ConsumerGroupHeartbeatRequest.MinVersion)
					.WithMaxVersion(ConsumerGroupHeartbeatRequest.MaxVersion),
				key => key
					.WithApiKey(ControlledShutdownRequest.ApiKey)
					.WithMinVersion(ControlledShutdownRequest.MinVersion)
					.WithMaxVersion(ControlledShutdownRequest.MaxVersion),
				key => key
					.WithApiKey(ControllerRegistrationRequest.ApiKey)
					.WithMinVersion(ControllerRegistrationRequest.MinVersion)
					.WithMaxVersion(ControllerRegistrationRequest.MaxVersion),
				key => key
					.WithApiKey(CreateAclsRequest.ApiKey)
					.WithMinVersion(CreateAclsRequest.MinVersion)
					.WithMaxVersion(CreateAclsRequest.MaxVersion),
				key => key
					.WithApiKey(CreateDelegationTokenRequest.ApiKey)
					.WithMinVersion(CreateDelegationTokenRequest.MinVersion)
					.WithMaxVersion(CreateDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(CreatePartitionsRequest.ApiKey)
					.WithMinVersion(CreatePartitionsRequest.MinVersion)
					.WithMaxVersion(CreatePartitionsRequest.MaxVersion),
				key => key
					.WithApiKey(CreateTopicsRequest.ApiKey)
					.WithMinVersion(CreateTopicsRequest.MinVersion)
					.WithMaxVersion(CreateTopicsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteAclsRequest.ApiKey)
					.WithMinVersion(DeleteAclsRequest.MinVersion)
					.WithMaxVersion(DeleteAclsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteGroupsRequest.ApiKey)
					.WithMinVersion(DeleteGroupsRequest.MinVersion)
					.WithMaxVersion(DeleteGroupsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteRecordsRequest.ApiKey)
					.WithMinVersion(DeleteRecordsRequest.MinVersion)
					.WithMaxVersion(DeleteRecordsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteShareGroupStateRequest.ApiKey)
					.WithMinVersion(DeleteShareGroupStateRequest.MinVersion)
					.WithMaxVersion(DeleteShareGroupStateRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteTopicsRequest.ApiKey)
					.WithMinVersion(DeleteTopicsRequest.MinVersion)
					.WithMaxVersion(DeleteTopicsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeAclsRequest.ApiKey)
					.WithMinVersion(DescribeAclsRequest.MinVersion)
					.WithMaxVersion(DescribeAclsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeClientQuotasRequest.ApiKey)
					.WithMinVersion(DescribeClientQuotasRequest.MinVersion)
					.WithMaxVersion(DescribeClientQuotasRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeClusterRequest.ApiKey)
					.WithMinVersion(DescribeClusterRequest.MinVersion)
					.WithMaxVersion(DescribeClusterRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeConfigsRequest.ApiKey)
					.WithMinVersion(DescribeConfigsRequest.MinVersion)
					.WithMaxVersion(DescribeConfigsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeDelegationTokenRequest.ApiKey)
					.WithMinVersion(DescribeDelegationTokenRequest.MinVersion)
					.WithMaxVersion(DescribeDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeGroupsRequest.ApiKey)
					.WithMinVersion(DescribeGroupsRequest.MinVersion)
					.WithMaxVersion(DescribeGroupsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeLogDirsRequest.ApiKey)
					.WithMinVersion(DescribeLogDirsRequest.MinVersion)
					.WithMaxVersion(DescribeLogDirsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeProducersRequest.ApiKey)
					.WithMinVersion(DescribeProducersRequest.MinVersion)
					.WithMaxVersion(DescribeProducersRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeQuorumRequest.ApiKey)
					.WithMinVersion(DescribeQuorumRequest.MinVersion)
					.WithMaxVersion(DescribeQuorumRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeTopicPartitionsRequest.ApiKey)
					.WithMinVersion(DescribeTopicPartitionsRequest.MinVersion)
					.WithMaxVersion(DescribeTopicPartitionsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeTransactionsRequest.ApiKey)
					.WithMinVersion(DescribeTransactionsRequest.MinVersion)
					.WithMaxVersion(DescribeTransactionsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeUserScramCredentialsRequest.ApiKey)
					.WithMinVersion(DescribeUserScramCredentialsRequest.MinVersion)
					.WithMaxVersion(DescribeUserScramCredentialsRequest.MaxVersion),
				key => key
					.WithApiKey(ElectLeadersRequest.ApiKey)
					.WithMinVersion(ElectLeadersRequest.MinVersion)
					.WithMaxVersion(ElectLeadersRequest.MaxVersion),
				key => key
					.WithApiKey(EndQuorumEpochRequest.ApiKey)
					.WithMinVersion(EndQuorumEpochRequest.MinVersion)
					.WithMaxVersion(EndQuorumEpochRequest.MaxVersion),
				key => key
					.WithApiKey(EndTxnRequest.ApiKey)
					.WithMinVersion(EndTxnRequest.MinVersion)
					.WithMaxVersion(EndTxnRequest.MaxVersion),
				key => key
					.WithApiKey(EnvelopeRequest.ApiKey)
					.WithMinVersion(EnvelopeRequest.MinVersion)
					.WithMaxVersion(EnvelopeRequest.MaxVersion),
				key => key
					.WithApiKey(ExpireDelegationTokenRequest.ApiKey)
					.WithMinVersion(ExpireDelegationTokenRequest.MinVersion)
					.WithMaxVersion(ExpireDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(FetchRequest.ApiKey)
					.WithMinVersion(FetchRequest.MinVersion)
					.WithMaxVersion(FetchRequest.MaxVersion),
				key => key
					.WithApiKey(FetchSnapshotRequest.ApiKey)
					.WithMinVersion(FetchSnapshotRequest.MinVersion)
					.WithMaxVersion(FetchSnapshotRequest.MaxVersion),
				key => key
					.WithApiKey(FindCoordinatorRequest.ApiKey)
					.WithMinVersion(FindCoordinatorRequest.MinVersion)
					.WithMaxVersion(FindCoordinatorRequest.MaxVersion),
				key => key
					.WithApiKey(GetTelemetrySubscriptionsRequest.ApiKey)
					.WithMinVersion(GetTelemetrySubscriptionsRequest.MinVersion)
					.WithMaxVersion(GetTelemetrySubscriptionsRequest.MaxVersion),
				key => key
					.WithApiKey(HeartbeatRequest.ApiKey)
					.WithMinVersion(HeartbeatRequest.MinVersion)
					.WithMaxVersion(HeartbeatRequest.MaxVersion),
				key => key
					.WithApiKey(IncrementalAlterConfigsRequest.ApiKey)
					.WithMinVersion(IncrementalAlterConfigsRequest.MinVersion)
					.WithMaxVersion(IncrementalAlterConfigsRequest.MaxVersion),
				key => key
					.WithApiKey(InitializeShareGroupStateRequest.ApiKey)
					.WithMinVersion(InitializeShareGroupStateRequest.MinVersion)
					.WithMaxVersion(InitializeShareGroupStateRequest.MaxVersion),
				key => key
					.WithApiKey(InitProducerIdRequest.ApiKey)
					.WithMinVersion(InitProducerIdRequest.MinVersion)
					.WithMaxVersion(InitProducerIdRequest.MaxVersion),
				key => key
					.WithApiKey(JoinGroupRequest.ApiKey)
					.WithMinVersion(JoinGroupRequest.MinVersion)
					.WithMaxVersion(JoinGroupRequest.MaxVersion),
				key => key
					.WithApiKey(LeaderAndIsrRequest.ApiKey)
					.WithMinVersion(LeaderAndIsrRequest.MinVersion)
					.WithMaxVersion(LeaderAndIsrRequest.MaxVersion),
				key => key
					.WithApiKey(LeaveGroupRequest.ApiKey)
					.WithMinVersion(LeaveGroupRequest.MinVersion)
					.WithMaxVersion(LeaveGroupRequest.MaxVersion),
				key => key
					.WithApiKey(ListClientMetricsResourcesRequest.ApiKey)
					.WithMinVersion(ListClientMetricsResourcesRequest.MinVersion)
					.WithMaxVersion(ListClientMetricsResourcesRequest.MaxVersion),
				key => key
					.WithApiKey(ListGroupsRequest.ApiKey)
					.WithMinVersion(ListGroupsRequest.MinVersion)
					.WithMaxVersion(ListGroupsRequest.MaxVersion),
				key => key
					.WithApiKey(ListOffsetsRequest.ApiKey)
					.WithMinVersion(ListOffsetsRequest.MinVersion)
					.WithMaxVersion(ListOffsetsRequest.MaxVersion),
				key => key
					.WithApiKey(ListPartitionReassignmentsRequest.ApiKey)
					.WithMinVersion(ListPartitionReassignmentsRequest.MinVersion)
					.WithMaxVersion(ListPartitionReassignmentsRequest.MaxVersion),
				key => key
					.WithApiKey(ListTransactionsRequest.ApiKey)
					.WithMinVersion(ListTransactionsRequest.MinVersion)
					.WithMaxVersion(ListTransactionsRequest.MaxVersion),
				key => key
					.WithApiKey(MetadataRequest.ApiKey)
					.WithMinVersion(MetadataRequest.MinVersion)
					.WithMaxVersion(MetadataRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetCommitRequest.ApiKey)
					.WithMinVersion(OffsetCommitRequest.MinVersion)
					.WithMaxVersion(OffsetCommitRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetDeleteRequest.ApiKey)
					.WithMinVersion(OffsetDeleteRequest.MinVersion)
					.WithMaxVersion(OffsetDeleteRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetFetchRequest.ApiKey)
					.WithMinVersion(OffsetFetchRequest.MinVersion)
					.WithMaxVersion(OffsetFetchRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetForLeaderEpochRequest.ApiKey)
					.WithMinVersion(OffsetForLeaderEpochRequest.MinVersion)
					.WithMaxVersion(OffsetForLeaderEpochRequest.MaxVersion),
				key => key
					.WithApiKey(ProduceRequest.ApiKey)
					.WithMinVersion(ProduceRequest.MinVersion)
					.WithMaxVersion(ProduceRequest.MaxVersion),
				key => key
					.WithApiKey(PushTelemetryRequest.ApiKey)
					.WithMinVersion(PushTelemetryRequest.MinVersion)
					.WithMaxVersion(PushTelemetryRequest.MaxVersion),
				key => key
					.WithApiKey(ReadShareGroupStateRequest.ApiKey)
					.WithMinVersion(ReadShareGroupStateRequest.MinVersion)
					.WithMaxVersion(ReadShareGroupStateRequest.MaxVersion),
				key => key
					.WithApiKey(ReadShareGroupStateSummaryRequest.ApiKey)
					.WithMinVersion(ReadShareGroupStateSummaryRequest.MinVersion)
					.WithMaxVersion(ReadShareGroupStateSummaryRequest.MaxVersion),
				key => key
					.WithApiKey(RemoveRaftVoterRequest.ApiKey)
					.WithMinVersion(RemoveRaftVoterRequest.MinVersion)
					.WithMaxVersion(RemoveRaftVoterRequest.MaxVersion),
				key => key
					.WithApiKey(RenewDelegationTokenRequest.ApiKey)
					.WithMinVersion(RenewDelegationTokenRequest.MinVersion)
					.WithMaxVersion(RenewDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(SaslAuthenticateRequest.ApiKey)
					.WithMinVersion(SaslAuthenticateRequest.MinVersion)
					.WithMaxVersion(SaslAuthenticateRequest.MaxVersion),
				key => key
					.WithApiKey(SaslHandshakeRequest.ApiKey)
					.WithMinVersion(SaslHandshakeRequest.MinVersion)
					.WithMaxVersion(SaslHandshakeRequest.MaxVersion),
				key => key
					.WithApiKey(ShareAcknowledgeRequest.ApiKey)
					.WithMinVersion(ShareAcknowledgeRequest.MinVersion)
					.WithMaxVersion(ShareAcknowledgeRequest.MaxVersion),
				key => key
					.WithApiKey(ShareFetchRequest.ApiKey)
					.WithMinVersion(ShareFetchRequest.MinVersion)
					.WithMaxVersion(ShareFetchRequest.MaxVersion),
				key => key
					.WithApiKey(ShareGroupDescribeRequest.ApiKey)
					.WithMinVersion(ShareGroupDescribeRequest.MinVersion)
					.WithMaxVersion(ShareGroupDescribeRequest.MaxVersion),
				key => key
					.WithApiKey(ShareGroupHeartbeatRequest.ApiKey)
					.WithMinVersion(ShareGroupHeartbeatRequest.MinVersion)
					.WithMaxVersion(ShareGroupHeartbeatRequest.MaxVersion),
				key => key
					.WithApiKey(StopReplicaRequest.ApiKey)
					.WithMinVersion(StopReplicaRequest.MinVersion)
					.WithMaxVersion(StopReplicaRequest.MaxVersion),
				key => key
					.WithApiKey(SyncGroupRequest.ApiKey)
					.WithMinVersion(SyncGroupRequest.MinVersion)
					.WithMaxVersion(SyncGroupRequest.MaxVersion),
				key => key
					.WithApiKey(TxnOffsetCommitRequest.ApiKey)
					.WithMinVersion(TxnOffsetCommitRequest.MinVersion)
					.WithMaxVersion(TxnOffsetCommitRequest.MaxVersion),
				key => key
					.WithApiKey(UnregisterBrokerRequest.ApiKey)
					.WithMinVersion(UnregisterBrokerRequest.MinVersion)
					.WithMaxVersion(UnregisterBrokerRequest.MaxVersion),
				key => key
					.WithApiKey(UpdateFeaturesRequest.ApiKey)
					.WithMinVersion(UpdateFeaturesRequest.MinVersion)
					.WithMaxVersion(UpdateFeaturesRequest.MaxVersion),
				key => key
					.WithApiKey(UpdateMetadataRequest.ApiKey)
					.WithMinVersion(UpdateMetadataRequest.MinVersion)
					.WithMaxVersion(UpdateMetadataRequest.MaxVersion),
				key => key
					.WithApiKey(UpdateRaftVoterRequest.ApiKey)
					.WithMinVersion(UpdateRaftVoterRequest.MinVersion)
					.WithMaxVersion(UpdateRaftVoterRequest.MaxVersion),
				key => key
					.WithApiKey(VoteRequest.ApiKey)
					.WithMinVersion(VoteRequest.MinVersion)
					.WithMaxVersion(VoteRequest.MaxVersion),
				key => key
					.WithApiKey(WriteShareGroupStateRequest.ApiKey)
					.WithMinVersion(WriteShareGroupStateRequest.MinVersion)
					.WithMaxVersion(WriteShareGroupStateRequest.MaxVersion),
				key => key
					.WithApiKey(WriteTxnMarkersRequest.ApiKey)
					.WithMinVersion(WriteTxnMarkersRequest.MinVersion)
					.WithMaxVersion(WriteTxnMarkersRequest.MaxVersion));
		}
	}
}