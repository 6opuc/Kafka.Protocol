<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="netstandard" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ assembly name="$(NuGetPackageRoot)\htmlagilitypack\1.9.0\lib\netstandard2.0\HtmlAgilityPack.dll" #>
<#@ assembly name="$(SolutionDir)\Kafka.Protocol.Generator\bin\Debug\netstandard2.0\Kafka.Protocol.Generator.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="HtmlAgilityPack" #>
<#@ import namespace="Kafka.Protocol.Generator" #>
<#@ import namespace="Kafka.Protocol.Generator.Definitions" #>
<#@ import namespace="Kafka.Protocol.Generator.Extensions" #>
<#@ import namespace="Kafka.Protocol.Generator.Definitions.Messages" #>
<#
    var path = Path.Combine(Host.ResolvePath(@"ProtocolSpecifications\Apache Kafka.html"));
    var apacheKafkaDefinitionPage = new HtmlDocument();
    apacheKafkaDefinitionPage.LoadHtml(File.ReadAllText(path));

    var protocol = ProtocolSpecification.Load(apacheKafkaDefinitionPage);

	var messageDefinitionPath = Path.Combine(Host.ResolvePath(@"..\Kafka.Protocol.MessageDefinitionsDownloader\MessageDefinitions\"));
	var messageDefinitions = JsonFileLoader.LoadFrom<Message>(messageDefinitionPath);

    void Block(Action action) { this.Block(action); }
	void PrintOnNewRowForEach<TValue>(IEnumerable<TValue> iterator, Action<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void PrintOnNewRowForEachWithIndex<TValue>(IEnumerable<TValue> iterator, ActionDelegateWithIndexAndLength<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void _(int count = 1) { this.WriteNewLine(count); }
    
	void GenerateDocumentation(string documentation)
    {
        if (string.IsNullOrEmpty(documentation))
        {
            return;
        }

        #>/// <summary><# _();
        foreach (var documentationRow in documentation.Trim().Split('\n'))
        {
            #>/// <#= documentationRow.Trim() #><# _();
        }
		#>/// </summary><# _();
    }
#>
// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.

using System;
using System.Linq;
using System.Net;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace Kafka.Protocol<# Block(() =>
{
	// Primitive types
	// todo: Ignore request and response messages until we have a proper way to deal with them
    PrintOnNewRowForEach(protocol.PrimitiveTypes.Values
        .Where(type => 
            type.Type!="RequestMessage" && 
            type.Type!="ResponseMessage"), primitiveType =>
    {
        var className = primitiveType.GetClassName();
        var type = primitiveType.GetTypeName();

        GenerateDocumentation(primitiveType.Description);
        #>public struct <#= className #> : ISerialize <# Block(() =>
        {
            #>public <#= type #> Value { get; private set; }<# _(2);

            #>public <#= className #>(<#= type #> value)<# Block(() =>
            {
                #>Value = value;<#
            }); _(2);

			#>public override bool Equals(object obj) <# Block(() =>
            {
                #>return obj is <#= className #> comparing<#= className #> && this == comparing<#= className #>;<#
            }); _(2);

			#>public override int GetHashCode() <# Block(() => 
			{
				#>return Value.GetHashCode();<#
			}); _(2);

			#>public override string ToString() <# Block(() => 
			{
				#>return Value.ToString();<#
			}); _(2);

			#>public static bool operator == (<#= className #> x, <#= className #> y)<# Block(() => 
			{
				#>return x.Value == y.Value;<#
			}); _(2);

			#>public static bool operator != (<#= className #> x, <#= className #> y)<# Block(() =>
            {
                #>return !(x == y);<#
            }); _(2);

			#>public void ReadFrom(IKafkaReader reader)<# Block(() => 
			{
				#>Value = reader.Read<#= className #>();<#
			}); _(2);

			#>public void WriteTo(IKafkaWriter writer)<# Block(() => 
			{
				#>writer.Write<#= className #>(Value);<#
			}); _(2);

			#>public static <#= className #> From(<#= type #> value)<# Block(() =>
            {
                #>return new <#= className #>(value);<#
            });
        }); _();
    });

	// Exceptions
    PrintOnNewRowForEachWithIndex(protocol.ErrorCodes.Values, (errorCode, index, count) =>
    {
        var exceptionName = errorCode.Error.ToPascalCase('_');
        GenerateDocumentation(errorCode.Description);
        #>public class <#= exceptionName #>Exception : Exception<# Block(() =>
        {
			#>public <#= exceptionName #>Exception()<# Block(() =>
			{
			}); _(2);

            #>public <#= exceptionName #>Exception(string message) : base(message)<# Block(() =>
			{
			}); _(2);

			#>public int Code { get; } = <#= errorCode.Code #>;<# 
        });

		if (index + 1 != count) _();
    }); _(2);

	PrintOnNewRowForEach(messageDefinitions, messageDefinition =>
	{
		#>public class <#= messageDefinition.Name #><# Block(() => 
		{
			#>public <#= messageDefinition.Name #>(int version)<# Block(() => 
			{
				 #>Version = version;<#
			}); _(2);

			#>public int Version { get; }<# _(2);

			#>public int ApiKey => <#= messageDefinition.ApiKey #>;<# _(2);

			#>public void ReadFrom(IKafkaReader reader)<# Block(() => 
			{
				PrintOnNewRowForEach(messageDefinition.Fields, messageField => 
				{
					PrintReadFrom(messageField);
				});
			}); _(2);

			#>public void WriteTo(IKafkaWriter writer)<# Block(() => 
			{
				PrintOnNewRowForEach(messageDefinition.Fields, messageField => 
				{
					PrintWriteTo(messageField);
				});
			}); _(2);

			PrintOnNewRowForEachWithIndex(messageDefinition.Fields, (messageField, messageFieldIndex, messageFieldCount) =>
			{
				PrintField(messageField);
				if (messageFieldIndex + 1 != messageFieldCount) _();
			});
		}); _();
	}); 
});

void PrintReadFrom(Kafka.Protocol.Generator.Definitions.Messages.Field messageField)
{
	var versionRange = VersionRange.Parse(messageField.Versions);
	#>if (Version.InRange(new VersionRange(<#= versionRange.From #>, <#= versionRange.To #>))) <# Block(() => 
	{
		var fieldTypeName = messageField.GetTypeName();
		if (messageField.Fields == null)
		{
			if (messageField.IsArray())
			{
			#><#= messageField.GetName() #> = reader.Read(() => new <#= fieldTypeName.TrimEnd('[', ']') #>(reader.Read<#= fieldTypeName.TrimEnd('[', ']') #>()));<# 	
			} 
			else 
			{
			#><#= messageField.GetName() #> = new <#= fieldTypeName #>(reader.Read<#= fieldTypeName #>());<# 
			}
		}
		else 
		{
			#><#= messageField.GetName() #> = reader.Read(() => new <#= fieldTypeName.TrimEnd('[', ']') #>(Version));<# 
		}
	});		
}

void PrintWriteTo(Kafka.Protocol.Generator.Definitions.Messages.Field messageField)
{
	var versionRange = VersionRange.Parse(messageField.Versions);
	#>if (Version.InRange(new VersionRange(<#= versionRange.From #>, <#= versionRange.To #>))) <# Block(() => 
	{
		if (messageField.Fields == null)
		{
			var fieldTypeName = messageField.GetTypeName();
			if (messageField.IsArray())
			{
			#>writer.Write(<#= messageField.GetName() #>);<# 	
			} 
			else 
			{
			#>writer.Write<#= fieldTypeName #>(<#= messageField.GetName() #>.Value);<# 
			}
		}
		else 
		{
			#>writer.Write(<#= messageField.GetName() #>);<# 
		}
	});		
}

void PrintField(Kafka.Protocol.Generator.Definitions.Messages.Field field)
{
	GenerateDocumentation(field.About);
	var fieldTypeName = field.GetTypeName();
	#>public <#= fieldTypeName #> <#= field.GetName() #> { get; set; }<# if(field.Default != null) { #> = new <#= fieldTypeName #>(<#= field.Default #>);<# } #><# 

	if (field.Fields == null) 
	{
		return;
	} 
				
	_(2); 
	#>public class <#= fieldTypeName.TrimEnd('[', ']') #> : ISerialize<# Block(() => 
	{
		#>public <#= fieldTypeName.TrimEnd('[', ']') #>(int version)<# Block(() => 
		{
			#>Version = version;<#
		}); _(2);

		#>public int Version { get; }<# _(2);

		#>public void ReadFrom(IKafkaReader reader)<# Block(() => 
		{
			PrintOnNewRowForEach(field.Fields, messageField => 
			{
				PrintReadFrom(messageField);
			});
		}); _(2);

		#>public void WriteTo(IKafkaWriter writer)<# Block(() => 
		{
			PrintOnNewRowForEach(field.Fields, messageField => 
			{
				PrintWriteTo(messageField);
			});
		}); _(2);

		PrintOnNewRowForEachWithIndex(field.Fields, (nestedField, index, count) =>
		{
			PrintField(nestedField); 
			if (index + 1 != count) _();
		});					
	});
}
#>