<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="netstandard" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ assembly name="$(NuGetPackageRoot)\htmlagilitypack\1.9.0\lib\netstandard2.0\HtmlAgilityPack.dll" #>
<#@ assembly name="$(SolutionDir)\Kafka.Protocol.Generator\bin\Debug\netstandard2.0\Kafka.Protocol.Generator.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="HtmlAgilityPack" #>
<#@ import namespace="Kafka.Protocol.Generator" #>
<#@ import namespace="Kafka.Protocol.Generator.Definitions" #>
<#@ import namespace="Kafka.Protocol.Generator.Extensions" #>
<#@ import namespace="Kafka.Protocol.Generator.Definitions.Messages" #>
<#
    var path = Path.Combine(Host.ResolvePath(@"ProtocolSpecifications\Apache Kafka.html"));
    var apacheKafkaDefinitionPage = new HtmlDocument();
    apacheKafkaDefinitionPage.LoadHtml(File.ReadAllText(path));

    var protocol = ProtocolSpecification.Load(apacheKafkaDefinitionPage);

	var messageDefinitionPath = Path.Combine(Host.ResolvePath(@"..\Kafka.Protocol.MessageDefinitionsDownloader\MessageDefinitions\"));
	var messageDefinitions = JsonFileLoader.LoadFrom<Message>(messageDefinitionPath);

    void Block(Action action) { this.Block(action); }
	void PrintOnNewRowForEach<TValue>(IEnumerable<TValue> iterator, Action<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void PrintOnNewRowForEachWithIndex<TValue>(IEnumerable<TValue> iterator, ActionDelegateWithIndexAndLength<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void _(int count = 1) { this.WriteNewLine(count); }
    
	void GenerateDocumentation(string documentation)
    {
        if (string.IsNullOrEmpty(documentation))
        {
            return;
        }

        #>/// <summary><# _();
        foreach (var documentationRow in documentation.Trim().Split('\n'))
        {
            #>/// <#= documentationRow.Trim() #><# _();
        }
		#>/// </summary><# _();
    }
#>
// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.Linq;

namespace Kafka.Protocol<# Block(() =>
{
	// Primitive types
	// todo: Ignore request and response messages until we have a proper way to deal with them
    PrintOnNewRowForEach(protocol.PrimitiveTypes.Values
        .Where(type => 
            type.Type!="RequestMessage" && 
            type.Type!="ResponseMessage"), primitiveType =>
    {
        var className = primitiveType.GetClassName();
        var type = primitiveType.GetTypeName();
		var defaultValue = primitiveType.GetDefaultValue();

        GenerateDocumentation(primitiveType.Description);
        #>public struct <#= className #> : ISerialize <# Block(() =>
        {
            #>public <#= type #> Value { get; private set; }<# _(2);

            #>public <#= className #>(<#= type #> value)<# Block(() =>
            {
                #>Value = value;<#
            }); _(2);

			#>public override bool Equals(object obj) <# Block(() =>
            {
                #>return obj is <#= className #> comparing<#= className #> && this == comparing<#= className #>;<#
            }); _(2);

			#>public override int GetHashCode() <# Block(() => 
			{
				#>return Value.GetHashCode();<#
			}); _(2);

			#>public override string ToString() <# Block(() => 
			{
				#>return Value.ToString();<#
			}); _(2);

			#>public static bool operator == (<#= className #> x, <#= className #> y)<# Block(() => 
			{
				#>return x.Value == y.Value;<#
			}); _(2);

			#>public static bool operator != (<#= className #> x, <#= className #> y)<# Block(() =>
            {
                #>return !(x == y);<#
            }); _(2);

			#>public void ReadFrom(IKafkaReader reader)<# Block(() => 
			{
				#>Value = reader.Read<#= className #>();<#
			}); _(2);

			#>public void WriteTo(IKafkaWriter writer)<# Block(() => 
			{
				#>writer.Write<#= className #>(Value);<#
			}); _(2);

			#>public static <#= className #> From(<#= type #> value)<# Block(() =>
            {
                #>return new <#= className #>(value);<#
            }); _(2);

			#>public static <#= className #> Default => <#= className #>.From(<#= defaultValue #>);<#
        }); _();
    });

	// Exceptions
    PrintOnNewRowForEachWithIndex(protocol.ErrorCodes.Values, (errorCode, index, count) =>
    {
        var exceptionName = errorCode.Error.ToPascalCase('_');
        GenerateDocumentation(errorCode.Description);
        #>public class <#= exceptionName #>Exception : Exception<# Block(() =>
        {
			#>public <#= exceptionName #>Exception()<# Block(() =>
			{
			}); _(2);

            #>public <#= exceptionName #>Exception(string message) : base(message)<# Block(() =>
			{
			}); _(2);

			#>public int Code { get; } = <#= errorCode.Code #>;<# 
        });

		if (index + 1 != count) _();
    }); _(2);

	// Messages
	PrintOnNewRowForEach(messageDefinitions, messageDefinition =>
	{
		#>public class <#= messageDefinition.Name #><# Block(() => 
		{
			#>public <#= messageDefinition.Name #>(int version)<# Block(() => 
			{
				var versionRange = VersionRange.Parse(messageDefinition.ValidVersions);
				#>if (version.InRange(new VersionRange(<#= versionRange.From #>, <#= versionRange.To #>)) == false) <# Block(() => 
				{
					#>throw new UnsupportedVersionException($"<#= messageDefinition.Name #> does not support version {version}. Valid versions are: <#= messageDefinition.ValidVersions #>");<#
				}); _(2);

				 #>Version = version;<#
			}); _(2);

			#>public int Version { get; }<# _(2);

			#>public int ApiKey => <#= messageDefinition.ApiKey #>;<# _(2);

			#>public void ReadFrom(IKafkaReader reader)<# Block(() => 
			{
				PrintOnNewRowForEach(messageDefinition.Fields, messageField => 
				{
					PrintReadFrom(messageField);
				});
			}); _(2);

			#>public void WriteTo(IKafkaWriter writer)<# Block(() => 
			{
				PrintOnNewRowForEach(messageDefinition.Fields, messageField => 
				{
					PrintWriteTo(messageField);
				});
			}); _(2);

			PrintOnNewRowForEachWithIndex(messageDefinition.Fields, (messageField, messageFieldIndex, messageFieldCount) =>
			{
				PrintField(messageField);
				if (messageFieldIndex + 1 != messageFieldCount) _();
			});
		}); _();
	}); 
});

void PrintReadFrom(Kafka.Protocol.Generator.Definitions.Messages.Field messageField)
{
	var versionRange = VersionRange.Parse(messageField.Versions);
	#>if (Version.InRange(new VersionRange(<#= versionRange.From #>, <#= versionRange.To #>))) <# Block(() => 
	{
		var fieldTypeName = messageField.GetTypeName();
		var fieldTypeNameWithoutArrayCharacters = messageField.GetTypeNameWithoutArrayCharacters();
		var fieldName = messageField.GetName();
		if (messageField.Fields == null)
		{
			if (messageField.IsArray())
			{
			#><#= fieldName #> = reader.Read(() => new <#= fieldTypeNameWithoutArrayCharacters #>(reader.Read<#= fieldTypeNameWithoutArrayCharacters #>()));<# 	
			} 
			else 
			{
			#><#= fieldName #> = new <#= fieldTypeName #>(reader.Read<#= fieldTypeName #>());<# 
			}
		}
		else 
		{
			var mapKeyField = messageField.Fields.FirstOrDefault(field => field.MapKey);
			if (mapKeyField == null)
			{
				#><#= fieldName #> = reader.Read(() => new <#= fieldTypeNameWithoutArrayCharacters #>(Version));<# 
			}
			else 
			{
				#><#= fieldName #> = reader.Read(() => new <#= fieldTypeNameWithoutArrayCharacters #>(Version)).ToDictionary(field => field.<#= mapKeyField.GetName() #>);<# 
			}
		}
	});		
}

void PrintWriteTo(Kafka.Protocol.Generator.Definitions.Messages.Field messageField)
{
	var versionRange = VersionRange.Parse(messageField.Versions);
	#>if (Version.InRange(new VersionRange(<#= versionRange.From #>, <#= versionRange.To #>))) <# Block(() => 
	{
		var fieldName = messageField.GetName();
		if (messageField.Fields == null)
		{
			var fieldTypeName = messageField.GetTypeName();
			if (messageField.IsArray())
			{
			#>writer.Write(<#= fieldName #>);<# 	
			} 
			else 
			{
			#>writer.Write<#= fieldTypeName #>(<#= fieldName #>.Value);<# 
			}
		}
		else 
		{
			var mapKeyField = messageField.Fields.FirstOrDefault(field => field.MapKey);
			if (mapKeyField == null)
			{
				#>writer.Write(<#= fieldName #>);<# 
			} 
			else 
			{
				#>writer.Write(<#= fieldName #>.Values.ToArray());<#
			}
		}
	});		
}

void PrintField(Kafka.Protocol.Generator.Definitions.Messages.Field field)
{
	GenerateDocumentation(field.About);

	var fieldTypeName = field.GetTypeName();
	var fieldTypeNameWithoutArrayCharacters = field.GetTypeNameWithoutArrayCharacters();
	var privateFieldName = field.GetName().FirstCharacterToLowerCase();
	
	#>private <#= fieldTypeName #> _<#= privateFieldName #><#
	
	if(field.Default != null) 
	{ 
		#> = new <#= fieldTypeName #>(<#= field.Default #>);<# 
	} 
	else if (field.IsDictionary())
	{
		#> = new <#= fieldTypeName #>();<# 
	}
	else if (field.IsArray())
	{
		#> = System.Array.Empty<<#= fieldTypeNameWithoutArrayCharacters #>>();<# 
	}
	else 
	{
		#> = <#= fieldTypeName #>.Default;<# 
	} _();

	#>public <#= fieldTypeName #> <#= field.GetName() #> <# Block(() => 
	{
		#>get => _<#= privateFieldName #>;<# _();
		#>set <# Block(() => 
		{
			if (field.Ignorable == false)
			{
				var versionRange = VersionRange.Parse(field.Versions);
				#>if (Version.InRange(new VersionRange(<#= versionRange.From #>, <#= versionRange.To #>)) == false) <# Block(() => 
				{
					#>throw new UnsupportedVersionException($"<#= field.GetName() #> does not support version {Version} and has been defined as not ignorable. Supported versions: <#= field.Versions #>");<#
				}); _(2);
			}

			if (field.NullableVersions == null)
			{
				#>if (value == null) <# Block(() => 
				{					
					#>throw new UnsupportedVersionException($"<#= field.GetName() #> is non-nullable.");<#
				}); _(2);
			}
			else
			{
				var nullableVersionRange = VersionRange.Parse(field.NullableVersions);
				#>if (Version.InRange(new VersionRange(<#= nullableVersionRange.From #>, <#= nullableVersionRange.To #>)) == false &&<# _();
				#>	value == null) <# Block(() => 
				{					
					#>throw new UnsupportedVersionException($"<#= field.GetName() #> does not support null for version {Version}. Supported versions for null value: <#= field.NullableVersions #>");<#
				}); _(2);
			}

			#>_<#= privateFieldName #> = value;<#
		});
	});
	
	if (field.Fields == null) 
	{
		return;
	} _(2); 

	#>public <#= fieldTypeNameWithoutArrayCharacters #> Create<#= fieldTypeNameWithoutArrayCharacters #>()<# Block(() => 
	{
		#>return new <#= fieldTypeNameWithoutArrayCharacters #>(Version);<#
	}); _(2);

	#>public class <#= fieldTypeNameWithoutArrayCharacters #> : ISerialize<# Block(() => 
	{
		#>internal <#= fieldTypeNameWithoutArrayCharacters #>(int version)<# Block(() => 
		{
			#>Version = version;<#
		}); _(2);

		#>internal int Version { get; }<# _(2);

		#>public void ReadFrom(IKafkaReader reader)<# Block(() => 
		{
			PrintOnNewRowForEach(field.Fields, messageField => 
			{
				PrintReadFrom(messageField);
			});
		}); _(2);

		#>public void WriteTo(IKafkaWriter writer)<# Block(() => 
		{
			PrintOnNewRowForEach(field.Fields, messageField => 
			{
				PrintWriteTo(messageField);
			});
		}); _(2);

		PrintOnNewRowForEachWithIndex(field.Fields, (nestedField, index, count) =>
		{
			PrintField(nestedField); 
			if (index + 1 != count) _();
		});					
	});
}
#>