<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="netstandard" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Text.RegularExpressions" #>
<#@ assembly name="$(NuGetPackageRoot)\htmlagilitypack\1.9.0\lib\netstandard2.0\HtmlAgilityPack.dll" #>
<#@ assembly name="$(SolutionDir)\Kafka.Protocol.Generator\bin\Debug\netstandard2.0\Kafka.Protocol.Generator.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="HtmlAgilityPack" #>
<#@ import namespace="Kafka.Protocol.Generator" #>
<#@ import namespace="Kafka.Protocol.Generator.Definitions" #>
<#@ import namespace="Kafka.Protocol.Generator.Extensions" #>
<#@ import namespace="Kafka.Protocol.Generator.Definitions.Messages" #>
<#
    var path = Path.Combine(Host.ResolvePath(@"ProtocolSpecifications\Apache Kafka.html"));
    var apacheKafkaDefinitionPage = new HtmlDocument();
    apacheKafkaDefinitionPage.LoadHtml(File.ReadAllText(path));

    var protocol = ProtocolSpecification.Load(apacheKafkaDefinitionPage);
	var protocolPrimitiveTypeConverter = new ProtocolPrimitiveTypeConverter();

	var messageDefinitionPath = Path.Combine(Host.ResolvePath(@"..\Kafka.Protocol.MessageDefinitionsDownloader\MessageDefinitions\"));
	var messageDefinitions = JsonFileLoader.LoadFrom<Message>(messageDefinitionPath);

    void Block(Action action) { this.Block(action); }
	void PrintOnNewRowForEach<TValue>(IEnumerable<TValue> iterator, Action<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void PrintOnNewRowForEachWithIndex<TValue>(IEnumerable<TValue> iterator, ActionDelegateWithIndexAndLength<TValue> action) { this.PrintOnNewRowForEach(iterator, action); }
	void _(int count = 1) { this.WriteNewLine(count); }
    
	void GenerateDocumentation(string documentation)
    {
        if (string.IsNullOrEmpty(documentation))
        {
            return;
        }

        #>/// <summary><# _();
        foreach (var documentationRow in documentation.Trim().Split('\n'))
        {
            #>/// <#= documentationRow.Trim() #><# _();
        }
		#>/// </summary><# _();
    }
#>
// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.

using System;
using System.Linq;
using System.Net;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace Kafka.Protocol<# Block(() =>
{
	// Primitive types
	// todo: Ignore request and response messages until we have a proper way to deal with them
    PrintOnNewRowForEach(protocol.PrimitiveTypes.Values
        .Where(type => 
            type.Type!="RequestMessage" && 
            type.Type!="ResponseMessage"), primitiveType =>
    {
        var className = primitiveType.Type.ToPascalCase('_');
        var type = protocolPrimitiveTypeConverter.Convert(className);

        GenerateDocumentation(primitiveType.Description);
        #>public struct <#= className #> <# Block(() =>
        {
            #>public <#= type #> Value { get; }<# _(2);

            #>public <#= className #>(<#= type #> value)<# Block(() =>
            {
                #>Value = value;<#
            }); _(2);

			#>public override bool Equals(object obj) <# Block(() =>
            {
                #>return obj is <#= className #> comparing<#= className #> && this == comparing<#= className #>;<#
            }); _(2);

			#>public override int GetHashCode() <# Block(() => 
			{
				#>return Value.GetHashCode();<#
			}); _(2);

			#>public override string ToString() <# Block(() => 
			{
				#>return Value.ToString();<#
			}); _(2);

			#>public static bool operator == (<#= className #> x, <#= className #> y)<# Block(() => 
			{
				#>return x.Value == y.Value;<#
			}); _(2);

			#>public static bool operator != (<#= className #> x, <#= className #> y)<# Block(() =>
            {
                #>return !(x == y);<#
            }); _(2);

			#>public static <#= className #> From(<#= type #> value)<# Block(() =>
            {
                #>return new <#= className #>(value);<#
            });
        }); _();
    });

	// Exceptions
    PrintOnNewRowForEachWithIndex(protocol.ErrorCodes.Values, (errorCode, index, count) =>
    {
        var exceptionName = errorCode.Error.ToPascalCase('_');
        GenerateDocumentation(errorCode.Description);
        #>public class <#= exceptionName #>Exception : Exception<# Block(() =>
        {
			#>public <#= exceptionName #>Exception()<# Block(() =>
			{
			}); _(2);

            #>public <#= exceptionName #>Exception(string message) : base(message)<# Block(() =>
			{
			}); _(2);

			#>public int Code { get; } = <#= errorCode.Code #>;<# 
        });

		if (index + 1 != count) _();
    }); _(2);

	PrintOnNewRowForEach(messageDefinitions, messageDefinition =>
	{
		#>public class <#= messageDefinition.Name #><# Block(() => 
		{
			PrintOnNewRowForEachWithIndex(messageDefinition.Fields, (messageField, messageFieldIndex, messageFieldCount) =>
			{
				PrintField(messageField);
				if (messageFieldIndex + 1 != messageFieldCount) _();
			});

			void PrintField(Kafka.Protocol.Generator.Definitions.Messages.Field field)
			{
				GenerateDocumentation(field.About);
				var fieldTypeName = protocolPrimitiveTypeConverter.Convert(field.Type);
				#>public <#= fieldTypeName #> <#= field.Name + (fieldTypeName.EndsWith("[]") ? "Collection" : "") #> { get; }<# 

				if (field.Fields == null) 
				{
					return;
				} 
				
				_(2); 
				#>public class <#= fieldTypeName.Replace("[]", "") #><# Block(() => 
				{
					PrintOnNewRowForEachWithIndex(field.Fields, (nestedField, index, count) =>
					{
						PrintField(nestedField); 
						if (index + 1 != count) _();
					});					
				});
			}
		}); _();
	}); 
});
#>