// WARNING! THIS FILE IS AUTO-GENERATED! DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Pipelines;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
// ReSharper disable MemberHidesStaticFromOuterClass FromReaderAsync will cause a lot of these warnings
namespace Kafka.Protocol
{
	/// <summary>
	/// <para>Represents a boolean value in a byte. Values 0 and 1 are used to represent false and true respectively. When reading a boolean value, any non-zero value is considered true.</para>
	/// </summary>
	public readonly partial struct Boolean : ISerialize 
	{
		public bool Value { get; }

		public Boolean(bool value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Boolean comparingBoolean && this == comparingBoolean;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Boolean x, Boolean y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Boolean x, Boolean y)
		{
			return !(x == y);
		}

		public static implicit operator bool(Boolean value) => value.Value;

		public static implicit operator Boolean(bool value) => From(value);

		public static Boolean From(bool value)
		{
			return new Boolean(value);
		}

		public static Boolean Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between -2^7 and 2^7-1 inclusive.</para>
	/// </summary>
	public readonly partial struct Int8 : ISerialize 
	{
		public sbyte Value { get; }

		public Int8(sbyte value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Int8 comparingInt8 && this == comparingInt8;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Int8 x, Int8 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Int8 x, Int8 y)
		{
			return !(x == y);
		}

		public static implicit operator sbyte(Int8 value) => value.Value;

		public static implicit operator Int8(sbyte value) => From(value);

		public static Int8 From(sbyte value)
		{
			return new Int8(value);
		}

		public static Int8 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between -2^15 and 2^15-1 inclusive. The values are encoded using two bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct Int16 : ISerialize 
	{
		public short Value { get; }

		public Int16(short value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Int16 comparingInt16 && this == comparingInt16;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Int16 x, Int16 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Int16 x, Int16 y)
		{
			return !(x == y);
		}

		public static implicit operator short(Int16 value) => value.Value;

		public static implicit operator Int16(short value) => From(value);

		public static Int16 From(short value)
		{
			return new Int16(value);
		}

		public static Int16 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between -2^31 and 2^31-1 inclusive. The values are encoded using four bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct Int32 : ISerialize 
	{
		public int Value { get; }

		public Int32(int value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Int32 comparingInt32 && this == comparingInt32;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Int32 x, Int32 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Int32 x, Int32 y)
		{
			return !(x == y);
		}

		public static implicit operator int(Int32 value) => value.Value;

		public static implicit operator Int32(int value) => From(value);

		public static Int32 From(int value)
		{
			return new Int32(value);
		}

		public static Int32 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between -2^63 and 2^63-1 inclusive. The values are encoded using eight bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct Int64 : ISerialize 
	{
		public long Value { get; }

		public Int64(long value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Int64 comparingInt64 && this == comparingInt64;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Int64 x, Int64 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Int64 x, Int64 y)
		{
			return !(x == y);
		}

		public static implicit operator long(Int64 value) => value.Value;

		public static implicit operator Int64(long value) => From(value);

		public static Int64 From(long value)
		{
			return new Int64(value);
		}

		public static Int64 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between 0 and 2^32-1 inclusive. The values are encoded using four bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct UInt32 : ISerialize 
	{
		public uint Value { get; }

		public UInt32(uint value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is UInt32 comparingUInt32 && this == comparingUInt32;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (UInt32 x, UInt32 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (UInt32 x, UInt32 y)
		{
			return !(x == y);
		}

		public static implicit operator uint(UInt32 value) => value.Value;

		public static implicit operator UInt32(uint value) => From(value);

		public static UInt32 From(uint value)
		{
			return new UInt32(value);
		}

		public static UInt32 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between -2^31 and 2^31-1 inclusive. Encoding follows the variable-length zig-zag encoding from  <a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html"> Google Protocol Buffers</a>.</para>
	/// </summary>
	public readonly partial struct VarInt : ISerialize 
	{
		public int Value { get; }

		public VarInt(int value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is VarInt comparingVarInt && this == comparingVarInt;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (VarInt x, VarInt y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (VarInt x, VarInt y)
		{
			return !(x == y);
		}

		public static implicit operator int(VarInt value) => value.Value;

		public static implicit operator VarInt(int value) => From(value);

		public static VarInt From(int value)
		{
			return new VarInt(value);
		}

		public static VarInt Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents an integer between -2^63 and 2^63-1 inclusive. Encoding follows the variable-length zig-zag encoding from  <a href="http://code.google.com/apis/protocolbuffers/docs/encoding.html"> Google Protocol Buffers</a>.</para>
	/// </summary>
	public readonly partial struct VarLong : ISerialize 
	{
		public long Value { get; }

		public VarLong(long value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is VarLong comparingVarLong && this == comparingVarLong;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (VarLong x, VarLong y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (VarLong x, VarLong y)
		{
			return !(x == y);
		}

		public static implicit operator long(VarLong value) => value.Value;

		public static implicit operator VarLong(long value) => From(value);

		public static VarLong From(long value)
		{
			return new VarLong(value);
		}

		public static VarLong Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents a type 4 immutable universally unique identifier (Uuid). The values are encoded using sixteen bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct Uuid : ISerialize 
	{
		public Guid Value { get; }

		public Uuid(Guid value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Uuid comparingUuid && this == comparingUuid;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Uuid x, Uuid y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Uuid x, Uuid y)
		{
			return !(x == y);
		}

		public static implicit operator Guid(Uuid value) => value.Value;

		public static implicit operator Uuid(Guid value) => From(value);

		public static Uuid From(Guid value)
		{
			return new Uuid(value);
		}

		public static Uuid Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents a double-precision 64-bit format IEEE 754 value. The values are encoded using eight bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct Float64 : ISerialize 
	{
		public double Value { get; }

		public Float64(double value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Float64 comparingFloat64 && this == comparingFloat64;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Float64 x, Float64 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Float64 x, Float64 y)
		{
			return !(x == y);
		}

		public static implicit operator double(Float64 value) => value.Value;

		public static implicit operator Float64(double value) => From(value);

		public static Float64 From(double value)
		{
			return new Float64(value);
		}

		public static Float64 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents a sequence of characters. First the length N is given as an INT16. Then N bytes follow which are the UTF-8 encoding of the character sequence. Length must not be negative.</para>
	/// </summary>
	public readonly partial struct String : ISerialize 
	{
		public string Value { get; }

		public String(string value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is String comparingString && this == comparingString;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (String x, String y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (String x, String y)
		{
			return !(x == y);
		}

		public static implicit operator string(String value) => value.Value;

		public static implicit operator String(string value) => From(value);

		public static String From(string value)
		{
			return new String(value);
		}

		public static String Default { get; } = From(string.Empty);
	}


	/// <summary>
	/// <para>Represents a sequence of characters or null. For non-null strings, first the length N is given as an INT16. Then N bytes follow which are the UTF-8 encoding of the character sequence. A null value is encoded with length of -1 and there are no following bytes.</para>
	/// </summary>
	public readonly partial struct NullableString : ISerialize 
	{
		public string? Value { get; }

		public NullableString(string? value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is NullableString comparingNullableString && this == comparingNullableString;
		}

		public override int GetHashCode() 
		{
			return Value?.GetHashCode() ?? 0;
		}

		public override string ToString() 
		{
			return Value?.ToString() ?? string.Empty;
		}

		public static bool operator == (NullableString x, NullableString y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (NullableString x, NullableString y)
		{
			return !(x == y);
		}

		public static implicit operator string?(NullableString value) => value.Value;

		public static implicit operator NullableString(string? value) => From(value);

		public static NullableString From(string? value)
		{
			return new NullableString(value);
		}

		public static NullableString Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents a raw sequence of bytes. First the length N is given as an INT32. Then N bytes follow.</para>
	/// </summary>
	public readonly partial struct Bytes : ISerialize 
	{
		public byte[] Value { get; }

		public Bytes(params byte[] value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Bytes comparingBytes && this == comparingBytes;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Bytes x, Bytes y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Bytes x, Bytes y)
		{
			return !(x == y);
		}

		public static implicit operator byte[](Bytes value) => value.Value;

		public static implicit operator Bytes(byte[] value) => From(value);

		public static Bytes From(params byte[] value)
		{
			return new Bytes(value);
		}

		public static Bytes Default { get; } = From(System.Array.Empty<byte>());
	}


	/// <summary>
	/// <para>Represents a raw sequence of bytes or null. For non-null values, first the length N is given as an INT32. Then N bytes follow. A null value is encoded with length of -1 and there are no following bytes.</para>
	/// </summary>
	public readonly partial struct NullableBytes : ISerialize 
	{
		public byte[]? Value { get; }

		public NullableBytes(params byte[]? value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is NullableBytes comparingNullableBytes && this == comparingNullableBytes;
		}

		public override int GetHashCode() 
		{
			return Value?.GetHashCode() ?? 0;
		}

		public override string ToString() 
		{
			return Value?.ToString() ?? string.Empty;
		}

		public static bool operator == (NullableBytes x, NullableBytes y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (NullableBytes x, NullableBytes y)
		{
			return !(x == y);
		}

		public static implicit operator byte[]?(NullableBytes value) => value.Value;

		public static implicit operator NullableBytes(byte[]? value) => From(value);

		public static NullableBytes From(params byte[]? value)
		{
			return new NullableBytes(value);
		}

		public static NullableBytes Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents a sequence of objects of a given type T. Type T can be either a primitive type (e.g. STRING) or a structure. First, the length N is given as an INT32. Then N instances of type T follow. A null array is represented with a length of -1. In protocol documentation an array of T instances is referred to as [T].</para>
	/// </summary>
	public readonly partial struct Array<T> : ISerialize 
		where T : ISerialize
	{
		public T[] Value { get; }

		public Array(params T[] value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is Array<T> comparingArray && this == comparingArray;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (Array<T> x, Array<T> y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (Array<T> x, Array<T> y)
		{
			return !(x == y);
		}

		public static implicit operator T[](Array<T> value) => value.Value;

		public static implicit operator Array<T>(T[] value) => From(value);

		public static Array<T> From(params T[] value)
		{
			return new Array<T>(value);
		}

		public static Array<T> Default { get; } = From(System.Array.Empty<T>());
	}


	/// <summary>
	/// <para>Represents an integer between 0 and 2^16-1 inclusive. The values are encoded using four bytes in network byte order (big-endian).</para>
	/// </summary>
	public readonly partial struct UInt16 : ISerialize 
	{
		public ushort Value { get; }

		public UInt16(ushort value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is UInt16 comparingUInt16 && this == comparingUInt16;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (UInt16 x, UInt16 y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (UInt16 x, UInt16 y)
		{
			return !(x == y);
		}

		public static implicit operator ushort(UInt16 value) => value.Value;

		public static implicit operator UInt16(ushort value) => From(value);

		public static UInt16 From(ushort value)
		{
			return new UInt16(value);
		}

		public static UInt16 Default { get; } = From(default);
	}


	/// <summary>
	/// <para>The UNSIGNED_VARINT type describes an unsigned variable length integer.</para>
	/// </summary>
	public readonly partial struct UVarInt : ISerialize 
	{
		public uint Value { get; }

		public UVarInt(uint value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is UVarInt comparingUVarInt && this == comparingUVarInt;
		}

		public override int GetHashCode() 
		{
			return Value.GetHashCode();
		}

		public override string ToString() 
		{
			return Value.ToString();
		}

		public static bool operator == (UVarInt x, UVarInt y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (UVarInt x, UVarInt y)
		{
			return !(x == y);
		}

		public static implicit operator uint(UVarInt value) => value.Value;

		public static implicit operator UVarInt(uint value) => From(value);

		public static UVarInt From(uint value)
		{
			return new UVarInt(value);
		}

		public static UVarInt Default { get; } = From(default);
	}


	/// <summary>
	/// <para>Represents a sequence of objects of a given type T. Type T can be either a primitive type (e.g. STRING) or a structure. First, the length N + 1 is given as an UNSIGNED_VARINT. Then N instances of type T follow. A null array is represented with a length of 0. In protocol documentation an array of T instances is referred to as [T].</para>
	/// </summary>
	public readonly partial struct NullableArray<T> : ISerialize 
		where T : ISerialize
	{
		public T[]? Value { get; }

		public NullableArray(params T[]? value)
		{
			Value = value;
		}

		public override bool Equals(object obj) 
		{
			return obj is NullableArray<T> comparingNullableArray && this == comparingNullableArray;
		}

		public override int GetHashCode() 
		{
			return Value?.GetHashCode() ?? 0;
		}

		public override string ToString() 
		{
			return Value?.ToString() ?? string.Empty;
		}

		public static bool operator == (NullableArray<T> x, NullableArray<T> y)
		{
			return x.Value == y.Value;
		}

		public static bool operator != (NullableArray<T> x, NullableArray<T> y)
		{
			return !(x == y);
		}

		public static implicit operator T[]?(NullableArray<T> value) => value.Value;

		public static implicit operator NullableArray<T>(T[]? value) => From(value);

		public static NullableArray<T> From(params T[]? value)
		{
			return new NullableArray<T>(value);
		}

		public static NullableArray<T> Default { get; } = From(default);
	}

	/// <summary>
	/// <para>The server experienced an unexpected error when processing the request.</para>
	/// </summary>
	public class UnknownServerErrorException : Exception
	{
		public UnknownServerErrorException()
		{

		}

		public UnknownServerErrorException(string message) : base(message)
		{

		}

		public int Code => -1;
	}

	public class NoneException : Exception
	{
		public NoneException()
		{

		}

		public NoneException(string message) : base(message)
		{

		}

		public int Code => 0;
	}

	/// <summary>
	/// <para>The requested offset is not within the range of offsets maintained by the server.</para>
	/// </summary>
	public class OffsetOutOfRangeException : Exception
	{
		public OffsetOutOfRangeException()
		{

		}

		public OffsetOutOfRangeException(string message) : base(message)
		{

		}

		public int Code => 1;
	}

	/// <summary>
	/// <para>This message has failed its CRC checksum, exceeds the valid size, has a null key for a compacted topic, or is otherwise corrupt.</para>
	/// </summary>
	public class CorruptMessageException : Exception
	{
		public CorruptMessageException()
		{

		}

		public CorruptMessageException(string message) : base(message)
		{

		}

		public int Code => 2;
	}

	/// <summary>
	/// <para>This server does not host this topic-partition.</para>
	/// </summary>
	public class UnknownTopicOrPartitionException : Exception
	{
		public UnknownTopicOrPartitionException()
		{

		}

		public UnknownTopicOrPartitionException(string message) : base(message)
		{

		}

		public int Code => 3;
	}

	/// <summary>
	/// <para>The requested fetch size is invalid.</para>
	/// </summary>
	public class InvalidFetchSizeException : Exception
	{
		public InvalidFetchSizeException()
		{

		}

		public InvalidFetchSizeException(string message) : base(message)
		{

		}

		public int Code => 4;
	}

	/// <summary>
	/// <para>There is no leader for this topic-partition as we are in the middle of a leadership election.</para>
	/// </summary>
	public class LeaderNotAvailableException : Exception
	{
		public LeaderNotAvailableException()
		{

		}

		public LeaderNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 5;
	}

	/// <summary>
	/// <para>For requests intended only for the leader, this error indicates that the broker is not the current leader. For requests intended for any replica, this error indicates that the broker is not a replica of the topic partition.</para>
	/// </summary>
	public class NotLeaderOrFollowerException : Exception
	{
		public NotLeaderOrFollowerException()
		{

		}

		public NotLeaderOrFollowerException(string message) : base(message)
		{

		}

		public int Code => 6;
	}

	/// <summary>
	/// <para>The request timed out.</para>
	/// </summary>
	public class RequestTimedOutException : Exception
	{
		public RequestTimedOutException()
		{

		}

		public RequestTimedOutException(string message) : base(message)
		{

		}

		public int Code => 7;
	}

	/// <summary>
	/// <para>The broker is not available.</para>
	/// </summary>
	public class BrokerNotAvailableException : Exception
	{
		public BrokerNotAvailableException()
		{

		}

		public BrokerNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 8;
	}

	/// <summary>
	/// <para>The replica is not available for the requested topic-partition. Produce/Fetch requests and other requests intended only for the leader or follower return NOT_LEADER_OR_FOLLOWER if the broker is not a replica of the topic-partition.</para>
	/// </summary>
	public class ReplicaNotAvailableException : Exception
	{
		public ReplicaNotAvailableException()
		{

		}

		public ReplicaNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 9;
	}

	/// <summary>
	/// <para>The request included a message larger than the max message size the server will accept.</para>
	/// </summary>
	public class MessageTooLargeException : Exception
	{
		public MessageTooLargeException()
		{

		}

		public MessageTooLargeException(string message) : base(message)
		{

		}

		public int Code => 10;
	}

	/// <summary>
	/// <para>The controller moved to another broker.</para>
	/// </summary>
	public class StaleControllerEpochException : Exception
	{
		public StaleControllerEpochException()
		{

		}

		public StaleControllerEpochException(string message) : base(message)
		{

		}

		public int Code => 11;
	}

	/// <summary>
	/// <para>The metadata field of the offset request was too large.</para>
	/// </summary>
	public class OffsetMetadataTooLargeException : Exception
	{
		public OffsetMetadataTooLargeException()
		{

		}

		public OffsetMetadataTooLargeException(string message) : base(message)
		{

		}

		public int Code => 12;
	}

	/// <summary>
	/// <para>The server disconnected before a response was received.</para>
	/// </summary>
	public class NetworkExceptionException : Exception
	{
		public NetworkExceptionException()
		{

		}

		public NetworkExceptionException(string message) : base(message)
		{

		}

		public int Code => 13;
	}

	/// <summary>
	/// <para>The coordinator is loading and hence can't process requests.</para>
	/// </summary>
	public class CoordinatorLoadInProgressException : Exception
	{
		public CoordinatorLoadInProgressException()
		{

		}

		public CoordinatorLoadInProgressException(string message) : base(message)
		{

		}

		public int Code => 14;
	}

	/// <summary>
	/// <para>The coordinator is not available.</para>
	/// </summary>
	public class CoordinatorNotAvailableException : Exception
	{
		public CoordinatorNotAvailableException()
		{

		}

		public CoordinatorNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 15;
	}

	/// <summary>
	/// <para>This is not the correct coordinator.</para>
	/// </summary>
	public class NotCoordinatorException : Exception
	{
		public NotCoordinatorException()
		{

		}

		public NotCoordinatorException(string message) : base(message)
		{

		}

		public int Code => 16;
	}

	/// <summary>
	/// <para>The request attempted to perform an operation on an invalid topic.</para>
	/// </summary>
	public class InvalidTopicExceptionException : Exception
	{
		public InvalidTopicExceptionException()
		{

		}

		public InvalidTopicExceptionException(string message) : base(message)
		{

		}

		public int Code => 17;
	}

	/// <summary>
	/// <para>The request included message batch larger than the configured segment size on the server.</para>
	/// </summary>
	public class RecordListTooLargeException : Exception
	{
		public RecordListTooLargeException()
		{

		}

		public RecordListTooLargeException(string message) : base(message)
		{

		}

		public int Code => 18;
	}

	/// <summary>
	/// <para>Messages are rejected since there are fewer in-sync replicas than required.</para>
	/// </summary>
	public class NotEnoughReplicasException : Exception
	{
		public NotEnoughReplicasException()
		{

		}

		public NotEnoughReplicasException(string message) : base(message)
		{

		}

		public int Code => 19;
	}

	/// <summary>
	/// <para>Messages are written to the log, but to fewer in-sync replicas than required.</para>
	/// </summary>
	public class NotEnoughReplicasAfterAppendException : Exception
	{
		public NotEnoughReplicasAfterAppendException()
		{

		}

		public NotEnoughReplicasAfterAppendException(string message) : base(message)
		{

		}

		public int Code => 20;
	}

	/// <summary>
	/// <para>Produce request specified an invalid value for required acks.</para>
	/// </summary>
	public class InvalidRequiredAcksException : Exception
	{
		public InvalidRequiredAcksException()
		{

		}

		public InvalidRequiredAcksException(string message) : base(message)
		{

		}

		public int Code => 21;
	}

	/// <summary>
	/// <para>Specified group generation id is not valid.</para>
	/// </summary>
	public class IllegalGenerationException : Exception
	{
		public IllegalGenerationException()
		{

		}

		public IllegalGenerationException(string message) : base(message)
		{

		}

		public int Code => 22;
	}

	/// <summary>
	/// <para>The group member's supported protocols are incompatible with those of existing members or first group member tried to join with empty protocol type or empty protocol list.</para>
	/// </summary>
	public class InconsistentGroupProtocolException : Exception
	{
		public InconsistentGroupProtocolException()
		{

		}

		public InconsistentGroupProtocolException(string message) : base(message)
		{

		}

		public int Code => 23;
	}

	/// <summary>
	/// <para>The configured groupId is invalid.</para>
	/// </summary>
	public class InvalidGroupIdException : Exception
	{
		public InvalidGroupIdException()
		{

		}

		public InvalidGroupIdException(string message) : base(message)
		{

		}

		public int Code => 24;
	}

	/// <summary>
	/// <para>The coordinator is not aware of this member.</para>
	/// </summary>
	public class UnknownMemberIdException : Exception
	{
		public UnknownMemberIdException()
		{

		}

		public UnknownMemberIdException(string message) : base(message)
		{

		}

		public int Code => 25;
	}

	/// <summary>
	/// <para>The session timeout is not within the range allowed by the broker (as configured by group.min.session.timeout.ms and group.max.session.timeout.ms).</para>
	/// </summary>
	public class InvalidSessionTimeoutException : Exception
	{
		public InvalidSessionTimeoutException()
		{

		}

		public InvalidSessionTimeoutException(string message) : base(message)
		{

		}

		public int Code => 26;
	}

	/// <summary>
	/// <para>The group is rebalancing, so a rejoin is needed.</para>
	/// </summary>
	public class RebalanceInProgressException : Exception
	{
		public RebalanceInProgressException()
		{

		}

		public RebalanceInProgressException(string message) : base(message)
		{

		}

		public int Code => 27;
	}

	/// <summary>
	/// <para>The committing offset data size is not valid.</para>
	/// </summary>
	public class InvalidCommitOffsetSizeException : Exception
	{
		public InvalidCommitOffsetSizeException()
		{

		}

		public InvalidCommitOffsetSizeException(string message) : base(message)
		{

		}

		public int Code => 28;
	}

	/// <summary>
	/// <para>Topic authorization failed.</para>
	/// </summary>
	public class TopicAuthorizationFailedException : Exception
	{
		public TopicAuthorizationFailedException()
		{

		}

		public TopicAuthorizationFailedException(string message) : base(message)
		{

		}

		public int Code => 29;
	}

	/// <summary>
	/// <para>Group authorization failed.</para>
	/// </summary>
	public class GroupAuthorizationFailedException : Exception
	{
		public GroupAuthorizationFailedException()
		{

		}

		public GroupAuthorizationFailedException(string message) : base(message)
		{

		}

		public int Code => 30;
	}

	/// <summary>
	/// <para>Cluster authorization failed.</para>
	/// </summary>
	public class ClusterAuthorizationFailedException : Exception
	{
		public ClusterAuthorizationFailedException()
		{

		}

		public ClusterAuthorizationFailedException(string message) : base(message)
		{

		}

		public int Code => 31;
	}

	/// <summary>
	/// <para>The timestamp of the message is out of acceptable range.</para>
	/// </summary>
	public class InvalidTimestampException : Exception
	{
		public InvalidTimestampException()
		{

		}

		public InvalidTimestampException(string message) : base(message)
		{

		}

		public int Code => 32;
	}

	/// <summary>
	/// <para>The broker does not support the requested SASL mechanism.</para>
	/// </summary>
	public class UnsupportedSaslMechanismException : Exception
	{
		public UnsupportedSaslMechanismException()
		{

		}

		public UnsupportedSaslMechanismException(string message) : base(message)
		{

		}

		public int Code => 33;
	}

	/// <summary>
	/// <para>Request is not valid given the current SASL state.</para>
	/// </summary>
	public class IllegalSaslStateException : Exception
	{
		public IllegalSaslStateException()
		{

		}

		public IllegalSaslStateException(string message) : base(message)
		{

		}

		public int Code => 34;
	}

	/// <summary>
	/// <para>The version of API is not supported.</para>
	/// </summary>
	public class UnsupportedVersionException : Exception
	{
		public UnsupportedVersionException()
		{

		}

		public UnsupportedVersionException(string message) : base(message)
		{

		}

		public int Code => 35;
	}

	/// <summary>
	/// <para>Topic with this name already exists.</para>
	/// </summary>
	public class TopicAlreadyExistsException : Exception
	{
		public TopicAlreadyExistsException()
		{

		}

		public TopicAlreadyExistsException(string message) : base(message)
		{

		}

		public int Code => 36;
	}

	/// <summary>
	/// <para>Number of partitions is below 1.</para>
	/// </summary>
	public class InvalidPartitionsException : Exception
	{
		public InvalidPartitionsException()
		{

		}

		public InvalidPartitionsException(string message) : base(message)
		{

		}

		public int Code => 37;
	}

	/// <summary>
	/// <para>Replication factor is below 1 or larger than the number of available brokers.</para>
	/// </summary>
	public class InvalidReplicationFactorException : Exception
	{
		public InvalidReplicationFactorException()
		{

		}

		public InvalidReplicationFactorException(string message) : base(message)
		{

		}

		public int Code => 38;
	}

	/// <summary>
	/// <para>Replica assignment is invalid.</para>
	/// </summary>
	public class InvalidReplicaAssignmentException : Exception
	{
		public InvalidReplicaAssignmentException()
		{

		}

		public InvalidReplicaAssignmentException(string message) : base(message)
		{

		}

		public int Code => 39;
	}

	/// <summary>
	/// <para>Configuration is invalid.</para>
	/// </summary>
	public class InvalidConfigException : Exception
	{
		public InvalidConfigException()
		{

		}

		public InvalidConfigException(string message) : base(message)
		{

		}

		public int Code => 40;
	}

	/// <summary>
	/// <para>This is not the correct controller for this cluster.</para>
	/// </summary>
	public class NotControllerException : Exception
	{
		public NotControllerException()
		{

		}

		public NotControllerException(string message) : base(message)
		{

		}

		public int Code => 41;
	}

	/// <summary>
	/// <para>This most likely occurs because of a request being malformed by the client library or the message was sent to an incompatible broker. See the broker logs for more details.</para>
	/// </summary>
	public class InvalidRequestException : Exception
	{
		public InvalidRequestException()
		{

		}

		public InvalidRequestException(string message) : base(message)
		{

		}

		public int Code => 42;
	}

	/// <summary>
	/// <para>The message format version on the broker does not support the request.</para>
	/// </summary>
	public class UnsupportedForMessageFormatException : Exception
	{
		public UnsupportedForMessageFormatException()
		{

		}

		public UnsupportedForMessageFormatException(string message) : base(message)
		{

		}

		public int Code => 43;
	}

	/// <summary>
	/// <para>Request parameters do not satisfy the configured policy.</para>
	/// </summary>
	public class PolicyViolationException : Exception
	{
		public PolicyViolationException()
		{

		}

		public PolicyViolationException(string message) : base(message)
		{

		}

		public int Code => 44;
	}

	/// <summary>
	/// <para>The broker received an out of order sequence number.</para>
	/// </summary>
	public class OutOfOrderSequenceNumberException : Exception
	{
		public OutOfOrderSequenceNumberException()
		{

		}

		public OutOfOrderSequenceNumberException(string message) : base(message)
		{

		}

		public int Code => 45;
	}

	/// <summary>
	/// <para>The broker received a duplicate sequence number.</para>
	/// </summary>
	public class DuplicateSequenceNumberException : Exception
	{
		public DuplicateSequenceNumberException()
		{

		}

		public DuplicateSequenceNumberException(string message) : base(message)
		{

		}

		public int Code => 46;
	}

	/// <summary>
	/// <para>Producer attempted to produce with an old epoch.</para>
	/// </summary>
	public class InvalidProducerEpochException : Exception
	{
		public InvalidProducerEpochException()
		{

		}

		public InvalidProducerEpochException(string message) : base(message)
		{

		}

		public int Code => 47;
	}

	/// <summary>
	/// <para>The producer attempted a transactional operation in an invalid state.</para>
	/// </summary>
	public class InvalidTxnStateException : Exception
	{
		public InvalidTxnStateException()
		{

		}

		public InvalidTxnStateException(string message) : base(message)
		{

		}

		public int Code => 48;
	}

	/// <summary>
	/// <para>The producer attempted to use a producer id which is not currently assigned to its transactional id.</para>
	/// </summary>
	public class InvalidProducerIdMappingException : Exception
	{
		public InvalidProducerIdMappingException()
		{

		}

		public InvalidProducerIdMappingException(string message) : base(message)
		{

		}

		public int Code => 49;
	}

	/// <summary>
	/// <para>The transaction timeout is larger than the maximum value allowed by the broker (as configured by transaction.max.timeout.ms).</para>
	/// </summary>
	public class InvalidTransactionTimeoutException : Exception
	{
		public InvalidTransactionTimeoutException()
		{

		}

		public InvalidTransactionTimeoutException(string message) : base(message)
		{

		}

		public int Code => 50;
	}

	/// <summary>
	/// <para>The producer attempted to update a transaction while another concurrent operation on the same transaction was ongoing.</para>
	/// </summary>
	public class ConcurrentTransactionsException : Exception
	{
		public ConcurrentTransactionsException()
		{

		}

		public ConcurrentTransactionsException(string message) : base(message)
		{

		}

		public int Code => 51;
	}

	/// <summary>
	/// <para>Indicates that the transaction coordinator sending a WriteTxnMarker is no longer the current coordinator for a given producer.</para>
	/// </summary>
	public class TransactionCoordinatorFencedException : Exception
	{
		public TransactionCoordinatorFencedException()
		{

		}

		public TransactionCoordinatorFencedException(string message) : base(message)
		{

		}

		public int Code => 52;
	}

	/// <summary>
	/// <para>Transactional Id authorization failed.</para>
	/// </summary>
	public class TransactionalIdAuthorizationFailedException : Exception
	{
		public TransactionalIdAuthorizationFailedException()
		{

		}

		public TransactionalIdAuthorizationFailedException(string message) : base(message)
		{

		}

		public int Code => 53;
	}

	/// <summary>
	/// <para>Security features are disabled.</para>
	/// </summary>
	public class SecurityDisabledException : Exception
	{
		public SecurityDisabledException()
		{

		}

		public SecurityDisabledException(string message) : base(message)
		{

		}

		public int Code => 54;
	}

	/// <summary>
	/// <para>The broker did not attempt to execute this operation. This may happen for batched RPCs where some operations in the batch failed, causing the broker to respond without trying the rest.</para>
	/// </summary>
	public class OperationNotAttemptedException : Exception
	{
		public OperationNotAttemptedException()
		{

		}

		public OperationNotAttemptedException(string message) : base(message)
		{

		}

		public int Code => 55;
	}

	/// <summary>
	/// <para>Disk error when trying to access log file on the disk.</para>
	/// </summary>
	public class KafkaStorageErrorException : Exception
	{
		public KafkaStorageErrorException()
		{

		}

		public KafkaStorageErrorException(string message) : base(message)
		{

		}

		public int Code => 56;
	}

	/// <summary>
	/// <para>The user-specified log directory is not found in the broker config.</para>
	/// </summary>
	public class LogDirNotFoundException : Exception
	{
		public LogDirNotFoundException()
		{

		}

		public LogDirNotFoundException(string message) : base(message)
		{

		}

		public int Code => 57;
	}

	/// <summary>
	/// <para>SASL Authentication failed.</para>
	/// </summary>
	public class SaslAuthenticationFailedException : Exception
	{
		public SaslAuthenticationFailedException()
		{

		}

		public SaslAuthenticationFailedException(string message) : base(message)
		{

		}

		public int Code => 58;
	}

	/// <summary>
	/// <para>This exception is raised by the broker if it could not locate the producer metadata associated with the producerId in question. This could happen if, for instance, the producer's records were deleted because their retention time had elapsed. Once the last records of the producerId are removed, the producer's metadata is removed from the broker, and future appends by the producer will return this exception.</para>
	/// </summary>
	public class UnknownProducerIdException : Exception
	{
		public UnknownProducerIdException()
		{

		}

		public UnknownProducerIdException(string message) : base(message)
		{

		}

		public int Code => 59;
	}

	/// <summary>
	/// <para>A partition reassignment is in progress.</para>
	/// </summary>
	public class ReassignmentInProgressException : Exception
	{
		public ReassignmentInProgressException()
		{

		}

		public ReassignmentInProgressException(string message) : base(message)
		{

		}

		public int Code => 60;
	}

	/// <summary>
	/// <para>Delegation Token feature is not enabled.</para>
	/// </summary>
	public class DelegationTokenAuthDisabledException : Exception
	{
		public DelegationTokenAuthDisabledException()
		{

		}

		public DelegationTokenAuthDisabledException(string message) : base(message)
		{

		}

		public int Code => 61;
	}

	/// <summary>
	/// <para>Delegation Token is not found on server.</para>
	/// </summary>
	public class DelegationTokenNotFoundException : Exception
	{
		public DelegationTokenNotFoundException()
		{

		}

		public DelegationTokenNotFoundException(string message) : base(message)
		{

		}

		public int Code => 62;
	}

	/// <summary>
	/// <para>Specified Principal is not valid Owner/Renewer.</para>
	/// </summary>
	public class DelegationTokenOwnerMismatchException : Exception
	{
		public DelegationTokenOwnerMismatchException()
		{

		}

		public DelegationTokenOwnerMismatchException(string message) : base(message)
		{

		}

		public int Code => 63;
	}

	/// <summary>
	/// <para>Delegation Token requests are not allowed on PLAINTEXT/1-way SSL channels and on delegation token authenticated channels.</para>
	/// </summary>
	public class DelegationTokenRequestNotAllowedException : Exception
	{
		public DelegationTokenRequestNotAllowedException()
		{

		}

		public DelegationTokenRequestNotAllowedException(string message) : base(message)
		{

		}

		public int Code => 64;
	}

	/// <summary>
	/// <para>Delegation Token authorization failed.</para>
	/// </summary>
	public class DelegationTokenAuthorizationFailedException : Exception
	{
		public DelegationTokenAuthorizationFailedException()
		{

		}

		public DelegationTokenAuthorizationFailedException(string message) : base(message)
		{

		}

		public int Code => 65;
	}

	/// <summary>
	/// <para>Delegation Token is expired.</para>
	/// </summary>
	public class DelegationTokenExpiredException : Exception
	{
		public DelegationTokenExpiredException()
		{

		}

		public DelegationTokenExpiredException(string message) : base(message)
		{

		}

		public int Code => 66;
	}

	/// <summary>
	/// <para>Supplied principalType is not supported.</para>
	/// </summary>
	public class InvalidPrincipalTypeException : Exception
	{
		public InvalidPrincipalTypeException()
		{

		}

		public InvalidPrincipalTypeException(string message) : base(message)
		{

		}

		public int Code => 67;
	}

	/// <summary>
	/// <para>The group is not empty.</para>
	/// </summary>
	public class NonEmptyGroupException : Exception
	{
		public NonEmptyGroupException()
		{

		}

		public NonEmptyGroupException(string message) : base(message)
		{

		}

		public int Code => 68;
	}

	/// <summary>
	/// <para>The group id does not exist.</para>
	/// </summary>
	public class GroupIdNotFoundException : Exception
	{
		public GroupIdNotFoundException()
		{

		}

		public GroupIdNotFoundException(string message) : base(message)
		{

		}

		public int Code => 69;
	}

	/// <summary>
	/// <para>The fetch session ID was not found.</para>
	/// </summary>
	public class FetchSessionIdNotFoundException : Exception
	{
		public FetchSessionIdNotFoundException()
		{

		}

		public FetchSessionIdNotFoundException(string message) : base(message)
		{

		}

		public int Code => 70;
	}

	/// <summary>
	/// <para>The fetch session epoch is invalid.</para>
	/// </summary>
	public class InvalidFetchSessionEpochException : Exception
	{
		public InvalidFetchSessionEpochException()
		{

		}

		public InvalidFetchSessionEpochException(string message) : base(message)
		{

		}

		public int Code => 71;
	}

	/// <summary>
	/// <para>There is no listener on the leader broker that matches the listener on which metadata request was processed.</para>
	/// </summary>
	public class ListenerNotFoundException : Exception
	{
		public ListenerNotFoundException()
		{

		}

		public ListenerNotFoundException(string message) : base(message)
		{

		}

		public int Code => 72;
	}

	/// <summary>
	/// <para>Topic deletion is disabled.</para>
	/// </summary>
	public class TopicDeletionDisabledException : Exception
	{
		public TopicDeletionDisabledException()
		{

		}

		public TopicDeletionDisabledException(string message) : base(message)
		{

		}

		public int Code => 73;
	}

	/// <summary>
	/// <para>The leader epoch in the request is older than the epoch on the broker.</para>
	/// </summary>
	public class FencedLeaderEpochException : Exception
	{
		public FencedLeaderEpochException()
		{

		}

		public FencedLeaderEpochException(string message) : base(message)
		{

		}

		public int Code => 74;
	}

	/// <summary>
	/// <para>The leader epoch in the request is newer than the epoch on the broker.</para>
	/// </summary>
	public class UnknownLeaderEpochException : Exception
	{
		public UnknownLeaderEpochException()
		{

		}

		public UnknownLeaderEpochException(string message) : base(message)
		{

		}

		public int Code => 75;
	}

	/// <summary>
	/// <para>The requesting client does not support the compression type of given partition.</para>
	/// </summary>
	public class UnsupportedCompressionTypeException : Exception
	{
		public UnsupportedCompressionTypeException()
		{

		}

		public UnsupportedCompressionTypeException(string message) : base(message)
		{

		}

		public int Code => 76;
	}

	/// <summary>
	/// <para>Broker epoch has changed.</para>
	/// </summary>
	public class StaleBrokerEpochException : Exception
	{
		public StaleBrokerEpochException()
		{

		}

		public StaleBrokerEpochException(string message) : base(message)
		{

		}

		public int Code => 77;
	}

	/// <summary>
	/// <para>The leader high watermark has not caught up from a recent leader election so the offsets cannot be guaranteed to be monotonically increasing.</para>
	/// </summary>
	public class OffsetNotAvailableException : Exception
	{
		public OffsetNotAvailableException()
		{

		}

		public OffsetNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 78;
	}

	/// <summary>
	/// <para>The group member needs to have a valid member id before actually entering a consumer group.</para>
	/// </summary>
	public class MemberIdRequiredException : Exception
	{
		public MemberIdRequiredException()
		{

		}

		public MemberIdRequiredException(string message) : base(message)
		{

		}

		public int Code => 79;
	}

	/// <summary>
	/// <para>The preferred leader was not available.</para>
	/// </summary>
	public class PreferredLeaderNotAvailableException : Exception
	{
		public PreferredLeaderNotAvailableException()
		{

		}

		public PreferredLeaderNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 80;
	}

	/// <summary>
	/// <para>The consumer group has reached its max size.</para>
	/// </summary>
	public class GroupMaxSizeReachedException : Exception
	{
		public GroupMaxSizeReachedException()
		{

		}

		public GroupMaxSizeReachedException(string message) : base(message)
		{

		}

		public int Code => 81;
	}

	/// <summary>
	/// <para>The broker rejected this static consumer since another consumer with the same group.instance.id has registered with a different member.id.</para>
	/// </summary>
	public class FencedInstanceIdException : Exception
	{
		public FencedInstanceIdException()
		{

		}

		public FencedInstanceIdException(string message) : base(message)
		{

		}

		public int Code => 82;
	}

	/// <summary>
	/// <para>Eligible topic partition leaders are not available.</para>
	/// </summary>
	public class EligibleLeadersNotAvailableException : Exception
	{
		public EligibleLeadersNotAvailableException()
		{

		}

		public EligibleLeadersNotAvailableException(string message) : base(message)
		{

		}

		public int Code => 83;
	}

	/// <summary>
	/// <para>Leader election not needed for topic partition.</para>
	/// </summary>
	public class ElectionNotNeededException : Exception
	{
		public ElectionNotNeededException()
		{

		}

		public ElectionNotNeededException(string message) : base(message)
		{

		}

		public int Code => 84;
	}

	/// <summary>
	/// <para>No partition reassignment is in progress.</para>
	/// </summary>
	public class NoReassignmentInProgressException : Exception
	{
		public NoReassignmentInProgressException()
		{

		}

		public NoReassignmentInProgressException(string message) : base(message)
		{

		}

		public int Code => 85;
	}

	/// <summary>
	/// <para>Deleting offsets of a topic is forbidden while the consumer group is actively subscribed to it.</para>
	/// </summary>
	public class GroupSubscribedToTopicException : Exception
	{
		public GroupSubscribedToTopicException()
		{

		}

		public GroupSubscribedToTopicException(string message) : base(message)
		{

		}

		public int Code => 86;
	}

	/// <summary>
	/// <para>This record has failed the validation on broker and hence will be rejected.</para>
	/// </summary>
	public class InvalidRecordException : Exception
	{
		public InvalidRecordException()
		{

		}

		public InvalidRecordException(string message) : base(message)
		{

		}

		public int Code => 87;
	}

	/// <summary>
	/// <para>There are unstable offsets that need to be cleared.</para>
	/// </summary>
	public class UnstableOffsetCommitException : Exception
	{
		public UnstableOffsetCommitException()
		{

		}

		public UnstableOffsetCommitException(string message) : base(message)
		{

		}

		public int Code => 88;
	}

	/// <summary>
	/// <para>The throttling quota has been exceeded.</para>
	/// </summary>
	public class ThrottlingQuotaExceededException : Exception
	{
		public ThrottlingQuotaExceededException()
		{

		}

		public ThrottlingQuotaExceededException(string message) : base(message)
		{

		}

		public int Code => 89;
	}

	/// <summary>
	/// <para>There is a newer producer with the same transactionalId which fences the current one.</para>
	/// </summary>
	public class ProducerFencedException : Exception
	{
		public ProducerFencedException()
		{

		}

		public ProducerFencedException(string message) : base(message)
		{

		}

		public int Code => 90;
	}

	/// <summary>
	/// <para>A request illegally referred to a resource that does not exist.</para>
	/// </summary>
	public class ResourceNotFoundException : Exception
	{
		public ResourceNotFoundException()
		{

		}

		public ResourceNotFoundException(string message) : base(message)
		{

		}

		public int Code => 91;
	}

	/// <summary>
	/// <para>A request illegally referred to the same resource twice.</para>
	/// </summary>
	public class DuplicateResourceException : Exception
	{
		public DuplicateResourceException()
		{

		}

		public DuplicateResourceException(string message) : base(message)
		{

		}

		public int Code => 92;
	}

	/// <summary>
	/// <para>Requested credential would not meet criteria for acceptability.</para>
	/// </summary>
	public class UnacceptableCredentialException : Exception
	{
		public UnacceptableCredentialException()
		{

		}

		public UnacceptableCredentialException(string message) : base(message)
		{

		}

		public int Code => 93;
	}

	/// <summary>
	/// <para>Indicates that the either the sender or recipient of a voter-only request is not one of the expected voters</para>
	/// </summary>
	public class InconsistentVoterSetException : Exception
	{
		public InconsistentVoterSetException()
		{

		}

		public InconsistentVoterSetException(string message) : base(message)
		{

		}

		public int Code => 94;
	}

	/// <summary>
	/// <para>The given update version was invalid.</para>
	/// </summary>
	public class InvalidUpdateVersionException : Exception
	{
		public InvalidUpdateVersionException()
		{

		}

		public InvalidUpdateVersionException(string message) : base(message)
		{

		}

		public int Code => 95;
	}

	/// <summary>
	/// <para>Unable to update finalized features due to an unexpected server error.</para>
	/// </summary>
	public class FeatureUpdateFailedException : Exception
	{
		public FeatureUpdateFailedException()
		{

		}

		public FeatureUpdateFailedException(string message) : base(message)
		{

		}

		public int Code => 96;
	}

	/// <summary>
	/// <para>Request principal deserialization failed during forwarding. This indicates an internal error on the broker cluster security setup.</para>
	/// </summary>
	public class PrincipalDeserializationFailureException : Exception
	{
		public PrincipalDeserializationFailureException()
		{

		}

		public PrincipalDeserializationFailureException(string message) : base(message)
		{

		}

		public int Code => 97;
	}

	/// <summary>
	/// <para>Requested snapshot was not found</para>
	/// </summary>
	public class SnapshotNotFoundException : Exception
	{
		public SnapshotNotFoundException()
		{

		}

		public SnapshotNotFoundException(string message) : base(message)
		{

		}

		public int Code => 98;
	}

	/// <summary>
	/// <para>Requested position is not greater than or equal to zero, and less than the size of the snapshot.</para>
	/// </summary>
	public class PositionOutOfRangeException : Exception
	{
		public PositionOutOfRangeException()
		{

		}

		public PositionOutOfRangeException(string message) : base(message)
		{

		}

		public int Code => 99;
	}

	/// <summary>
	/// <para>This server does not host this topic ID.</para>
	/// </summary>
	public class UnknownTopicIdException : Exception
	{
		public UnknownTopicIdException()
		{

		}

		public UnknownTopicIdException(string message) : base(message)
		{

		}

		public int Code => 100;
	}

	/// <summary>
	/// <para>This broker ID is already in use.</para>
	/// </summary>
	public class DuplicateBrokerRegistrationException : Exception
	{
		public DuplicateBrokerRegistrationException()
		{

		}

		public DuplicateBrokerRegistrationException(string message) : base(message)
		{

		}

		public int Code => 101;
	}

	/// <summary>
	/// <para>The given broker ID was not registered.</para>
	/// </summary>
	public class BrokerIdNotRegisteredException : Exception
	{
		public BrokerIdNotRegisteredException()
		{

		}

		public BrokerIdNotRegisteredException(string message) : base(message)
		{

		}

		public int Code => 102;
	}

	/// <summary>
	/// <para>The log's topic ID did not match the topic ID in the request</para>
	/// </summary>
	public class InconsistentTopicIdException : Exception
	{
		public InconsistentTopicIdException()
		{

		}

		public InconsistentTopicIdException(string message) : base(message)
		{

		}

		public int Code => 103;
	}

	/// <summary>
	/// <para>The clusterId in the request does not match that found on the server</para>
	/// </summary>
	public class InconsistentClusterIdException : Exception
	{
		public InconsistentClusterIdException()
		{

		}

		public InconsistentClusterIdException(string message) : base(message)
		{

		}

		public int Code => 104;
	}

	/// <summary>
	/// <para>The transactionalId could not be found</para>
	/// </summary>
	public class TransactionalIdNotFoundException : Exception
	{
		public TransactionalIdNotFoundException()
		{

		}

		public TransactionalIdNotFoundException(string message) : base(message)
		{

		}

		public int Code => 105;
	}

	public static class Messages 
	{
		public static async ValueTask<Message> CreateRequestMessageFromReaderAsync(
			Int16 apiKey, 
			Int16 version, 
			PipeReader reader, 
			CancellationToken cancellationToken = default)
		{
			if (AddOffsetsToTxnRequest.ApiKey == apiKey)
			{
				return await AddOffsetsToTxnRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AddPartitionsToTxnRequest.ApiKey == apiKey)
			{
				return await AddPartitionsToTxnRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AllocateProducerIdsRequest.ApiKey == apiKey)
			{
				return await AllocateProducerIdsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterClientQuotasRequest.ApiKey == apiKey)
			{
				return await AlterClientQuotasRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterConfigsRequest.ApiKey == apiKey)
			{
				return await AlterConfigsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterIsrRequest.ApiKey == apiKey)
			{
				return await AlterIsrRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterPartitionReassignmentsRequest.ApiKey == apiKey)
			{
				return await AlterPartitionReassignmentsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterReplicaLogDirsRequest.ApiKey == apiKey)
			{
				return await AlterReplicaLogDirsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterUserScramCredentialsRequest.ApiKey == apiKey)
			{
				return await AlterUserScramCredentialsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ApiVersionsRequest.ApiKey == apiKey)
			{
				return await ApiVersionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (BeginQuorumEpochRequest.ApiKey == apiKey)
			{
				return await BeginQuorumEpochRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (BrokerHeartbeatRequest.ApiKey == apiKey)
			{
				return await BrokerHeartbeatRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (BrokerRegistrationRequest.ApiKey == apiKey)
			{
				return await BrokerRegistrationRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ControlledShutdownRequest.ApiKey == apiKey)
			{
				return await ControlledShutdownRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreateAclsRequest.ApiKey == apiKey)
			{
				return await CreateAclsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreateDelegationTokenRequest.ApiKey == apiKey)
			{
				return await CreateDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreatePartitionsRequest.ApiKey == apiKey)
			{
				return await CreatePartitionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreateTopicsRequest.ApiKey == apiKey)
			{
				return await CreateTopicsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteAclsRequest.ApiKey == apiKey)
			{
				return await DeleteAclsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteGroupsRequest.ApiKey == apiKey)
			{
				return await DeleteGroupsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteRecordsRequest.ApiKey == apiKey)
			{
				return await DeleteRecordsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteTopicsRequest.ApiKey == apiKey)
			{
				return await DeleteTopicsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeAclsRequest.ApiKey == apiKey)
			{
				return await DescribeAclsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeClientQuotasRequest.ApiKey == apiKey)
			{
				return await DescribeClientQuotasRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeClusterRequest.ApiKey == apiKey)
			{
				return await DescribeClusterRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeConfigsRequest.ApiKey == apiKey)
			{
				return await DescribeConfigsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeDelegationTokenRequest.ApiKey == apiKey)
			{
				return await DescribeDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeGroupsRequest.ApiKey == apiKey)
			{
				return await DescribeGroupsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeLogDirsRequest.ApiKey == apiKey)
			{
				return await DescribeLogDirsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeProducersRequest.ApiKey == apiKey)
			{
				return await DescribeProducersRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeQuorumRequest.ApiKey == apiKey)
			{
				return await DescribeQuorumRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeTransactionsRequest.ApiKey == apiKey)
			{
				return await DescribeTransactionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeUserScramCredentialsRequest.ApiKey == apiKey)
			{
				return await DescribeUserScramCredentialsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ElectLeadersRequest.ApiKey == apiKey)
			{
				return await ElectLeadersRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (EndQuorumEpochRequest.ApiKey == apiKey)
			{
				return await EndQuorumEpochRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (EndTxnRequest.ApiKey == apiKey)
			{
				return await EndTxnRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (EnvelopeRequest.ApiKey == apiKey)
			{
				return await EnvelopeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ExpireDelegationTokenRequest.ApiKey == apiKey)
			{
				return await ExpireDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (FetchRequest.ApiKey == apiKey)
			{
				return await FetchRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (FetchSnapshotRequest.ApiKey == apiKey)
			{
				return await FetchSnapshotRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (FindCoordinatorRequest.ApiKey == apiKey)
			{
				return await FindCoordinatorRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (HeartbeatRequest.ApiKey == apiKey)
			{
				return await HeartbeatRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (IncrementalAlterConfigsRequest.ApiKey == apiKey)
			{
				return await IncrementalAlterConfigsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (InitProducerIdRequest.ApiKey == apiKey)
			{
				return await InitProducerIdRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (JoinGroupRequest.ApiKey == apiKey)
			{
				return await JoinGroupRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (LeaderAndIsrRequest.ApiKey == apiKey)
			{
				return await LeaderAndIsrRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (LeaveGroupRequest.ApiKey == apiKey)
			{
				return await LeaveGroupRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListGroupsRequest.ApiKey == apiKey)
			{
				return await ListGroupsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListOffsetsRequest.ApiKey == apiKey)
			{
				return await ListOffsetsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListPartitionReassignmentsRequest.ApiKey == apiKey)
			{
				return await ListPartitionReassignmentsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListTransactionsRequest.ApiKey == apiKey)
			{
				return await ListTransactionsRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (MetadataRequest.ApiKey == apiKey)
			{
				return await MetadataRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetCommitRequest.ApiKey == apiKey)
			{
				return await OffsetCommitRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetDeleteRequest.ApiKey == apiKey)
			{
				return await OffsetDeleteRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetFetchRequest.ApiKey == apiKey)
			{
				return await OffsetFetchRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetForLeaderEpochRequest.ApiKey == apiKey)
			{
				return await OffsetForLeaderEpochRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ProduceRequest.ApiKey == apiKey)
			{
				return await ProduceRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (RenewDelegationTokenRequest.ApiKey == apiKey)
			{
				return await RenewDelegationTokenRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (SaslAuthenticateRequest.ApiKey == apiKey)
			{
				return await SaslAuthenticateRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (SaslHandshakeRequest.ApiKey == apiKey)
			{
				return await SaslHandshakeRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (StopReplicaRequest.ApiKey == apiKey)
			{
				return await StopReplicaRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (SyncGroupRequest.ApiKey == apiKey)
			{
				return await SyncGroupRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (TxnOffsetCommitRequest.ApiKey == apiKey)
			{
				return await TxnOffsetCommitRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (UnregisterBrokerRequest.ApiKey == apiKey)
			{
				return await UnregisterBrokerRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (UpdateFeaturesRequest.ApiKey == apiKey)
			{
				return await UpdateFeaturesRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (UpdateMetadataRequest.ApiKey == apiKey)
			{
				return await UpdateMetadataRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (VoteRequest.ApiKey == apiKey)
			{
				return await VoteRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (WriteTxnMarkersRequest.ApiKey == apiKey)
			{
				return await WriteTxnMarkersRequest.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			throw new ArgumentException($"{apiKey} is not supported");
		}

		public static async ValueTask<Message> CreateResponseMessageFromReaderAsync(
			Int16 apiKey, 
			Int16 version, 
			PipeReader reader, 
			CancellationToken cancellationToken = default)
		{
			if (AddOffsetsToTxnResponse.ApiKey == apiKey)
			{
				return await AddOffsetsToTxnResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AddPartitionsToTxnResponse.ApiKey == apiKey)
			{
				return await AddPartitionsToTxnResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AllocateProducerIdsResponse.ApiKey == apiKey)
			{
				return await AllocateProducerIdsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterClientQuotasResponse.ApiKey == apiKey)
			{
				return await AlterClientQuotasResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterConfigsResponse.ApiKey == apiKey)
			{
				return await AlterConfigsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterIsrResponse.ApiKey == apiKey)
			{
				return await AlterIsrResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterPartitionReassignmentsResponse.ApiKey == apiKey)
			{
				return await AlterPartitionReassignmentsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterReplicaLogDirsResponse.ApiKey == apiKey)
			{
				return await AlterReplicaLogDirsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (AlterUserScramCredentialsResponse.ApiKey == apiKey)
			{
				return await AlterUserScramCredentialsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ApiVersionsResponse.ApiKey == apiKey)
			{
				return await ApiVersionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (BeginQuorumEpochResponse.ApiKey == apiKey)
			{
				return await BeginQuorumEpochResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (BrokerHeartbeatResponse.ApiKey == apiKey)
			{
				return await BrokerHeartbeatResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (BrokerRegistrationResponse.ApiKey == apiKey)
			{
				return await BrokerRegistrationResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ControlledShutdownResponse.ApiKey == apiKey)
			{
				return await ControlledShutdownResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreateAclsResponse.ApiKey == apiKey)
			{
				return await CreateAclsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreateDelegationTokenResponse.ApiKey == apiKey)
			{
				return await CreateDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreatePartitionsResponse.ApiKey == apiKey)
			{
				return await CreatePartitionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (CreateTopicsResponse.ApiKey == apiKey)
			{
				return await CreateTopicsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteAclsResponse.ApiKey == apiKey)
			{
				return await DeleteAclsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteGroupsResponse.ApiKey == apiKey)
			{
				return await DeleteGroupsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteRecordsResponse.ApiKey == apiKey)
			{
				return await DeleteRecordsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DeleteTopicsResponse.ApiKey == apiKey)
			{
				return await DeleteTopicsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeAclsResponse.ApiKey == apiKey)
			{
				return await DescribeAclsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeClientQuotasResponse.ApiKey == apiKey)
			{
				return await DescribeClientQuotasResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeClusterResponse.ApiKey == apiKey)
			{
				return await DescribeClusterResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeConfigsResponse.ApiKey == apiKey)
			{
				return await DescribeConfigsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeDelegationTokenResponse.ApiKey == apiKey)
			{
				return await DescribeDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeGroupsResponse.ApiKey == apiKey)
			{
				return await DescribeGroupsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeLogDirsResponse.ApiKey == apiKey)
			{
				return await DescribeLogDirsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeProducersResponse.ApiKey == apiKey)
			{
				return await DescribeProducersResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeQuorumResponse.ApiKey == apiKey)
			{
				return await DescribeQuorumResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeTransactionsResponse.ApiKey == apiKey)
			{
				return await DescribeTransactionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (DescribeUserScramCredentialsResponse.ApiKey == apiKey)
			{
				return await DescribeUserScramCredentialsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ElectLeadersResponse.ApiKey == apiKey)
			{
				return await ElectLeadersResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (EndQuorumEpochResponse.ApiKey == apiKey)
			{
				return await EndQuorumEpochResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (EndTxnResponse.ApiKey == apiKey)
			{
				return await EndTxnResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (EnvelopeResponse.ApiKey == apiKey)
			{
				return await EnvelopeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ExpireDelegationTokenResponse.ApiKey == apiKey)
			{
				return await ExpireDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (FetchResponse.ApiKey == apiKey)
			{
				return await FetchResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (FetchSnapshotResponse.ApiKey == apiKey)
			{
				return await FetchSnapshotResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (FindCoordinatorResponse.ApiKey == apiKey)
			{
				return await FindCoordinatorResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (HeartbeatResponse.ApiKey == apiKey)
			{
				return await HeartbeatResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (IncrementalAlterConfigsResponse.ApiKey == apiKey)
			{
				return await IncrementalAlterConfigsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (InitProducerIdResponse.ApiKey == apiKey)
			{
				return await InitProducerIdResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (JoinGroupResponse.ApiKey == apiKey)
			{
				return await JoinGroupResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (LeaderAndIsrResponse.ApiKey == apiKey)
			{
				return await LeaderAndIsrResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (LeaveGroupResponse.ApiKey == apiKey)
			{
				return await LeaveGroupResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListGroupsResponse.ApiKey == apiKey)
			{
				return await ListGroupsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListOffsetsResponse.ApiKey == apiKey)
			{
				return await ListOffsetsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListPartitionReassignmentsResponse.ApiKey == apiKey)
			{
				return await ListPartitionReassignmentsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ListTransactionsResponse.ApiKey == apiKey)
			{
				return await ListTransactionsResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (MetadataResponse.ApiKey == apiKey)
			{
				return await MetadataResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetCommitResponse.ApiKey == apiKey)
			{
				return await OffsetCommitResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetDeleteResponse.ApiKey == apiKey)
			{
				return await OffsetDeleteResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetFetchResponse.ApiKey == apiKey)
			{
				return await OffsetFetchResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (OffsetForLeaderEpochResponse.ApiKey == apiKey)
			{
				return await OffsetForLeaderEpochResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (ProduceResponse.ApiKey == apiKey)
			{
				return await ProduceResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (RenewDelegationTokenResponse.ApiKey == apiKey)
			{
				return await RenewDelegationTokenResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (SaslAuthenticateResponse.ApiKey == apiKey)
			{
				return await SaslAuthenticateResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (SaslHandshakeResponse.ApiKey == apiKey)
			{
				return await SaslHandshakeResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (StopReplicaResponse.ApiKey == apiKey)
			{
				return await StopReplicaResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (SyncGroupResponse.ApiKey == apiKey)
			{
				return await SyncGroupResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (TxnOffsetCommitResponse.ApiKey == apiKey)
			{
				return await TxnOffsetCommitResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (UnregisterBrokerResponse.ApiKey == apiKey)
			{
				return await UnregisterBrokerResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (UpdateFeaturesResponse.ApiKey == apiKey)
			{
				return await UpdateFeaturesResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (UpdateMetadataResponse.ApiKey == apiKey)
			{
				return await UpdateMetadataResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (VoteResponse.ApiKey == apiKey)
			{
				return await VoteResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			if (WriteTxnMarkersResponse.ApiKey == apiKey)
			{
				return await WriteTxnMarkersResponse.FromReaderAsync(version, reader, cancellationToken).ConfigureAwait(false);
			}

			throw new ArgumentException($"{apiKey} is not supported");
		}
	}

	public class AddOffsetsToTxnRequest : Message, IRespond<AddOffsetsToTxnResponse>
	{
		public AddOffsetsToTxnRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AddOffsetsToTxnRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(25);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AddOffsetsToTxnRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddOffsetsToTxnRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddOffsetsToTxnRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		public AddOffsetsToTxnResponse Respond()
			=> new AddOffsetsToTxnResponse(Version);
	}

	public class AddOffsetsToTxnResponse : Message
	{
		public AddOffsetsToTxnResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AddOffsetsToTxnResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(25);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AddOffsetsToTxnResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddOffsetsToTxnResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddOffsetsToTxnResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The response error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The response error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddOffsetsToTxnResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class AddPartitionsToTxnRequest : Message, IRespond<AddPartitionsToTxnResponse>
	{
		public AddPartitionsToTxnRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AddPartitionsToTxnRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(24);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AddPartitionsToTxnRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddPartitionsToTxnRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<AddPartitionsToTxnTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AddPartitionsToTxnTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional id corresponding to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>Current producer id in use by the transactional id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>Current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private Dictionary<String, AddPartitionsToTxnTopic> _topicsCollection = new Dictionary<String, AddPartitionsToTxnTopic>();
		/// <summary>
		/// <para>The partitions to add to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, AddPartitionsToTxnTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions to add to the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnRequest WithTopicsCollection(params Func<AddPartitionsToTxnTopic, AddPartitionsToTxnTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateAddPartitionsToTxnTopic()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal AddPartitionsToTxnTopic CreateAddPartitionsToTxnTopic()
		{
			return new AddPartitionsToTxnTopic(Version);
		}

		public class AddPartitionsToTxnTopic : ISerialize
		{
			internal AddPartitionsToTxnTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AddPartitionsToTxnTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32[] _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes to add to the transaction</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes to add to the transaction</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopic WithPartitionsCollection(Int32[] partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public AddPartitionsToTxnResponse Respond()
			=> new AddPartitionsToTxnResponse(Version);
	}

	public class AddPartitionsToTxnResponse : Message
	{
		public AddPartitionsToTxnResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AddPartitionsToTxnResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(24);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AddPartitionsToTxnResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AddPartitionsToTxnResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = (await Array<AddPartitionsToTxnTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AddPartitionsToTxnTopicResult>.From(ResultsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, AddPartitionsToTxnTopicResult> _resultsCollection = new Dictionary<String, AddPartitionsToTxnTopicResult>();
		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, AddPartitionsToTxnTopicResult> ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AddPartitionsToTxnResponse WithResultsCollection(params Func<AddPartitionsToTxnTopicResult, AddPartitionsToTxnTopicResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateAddPartitionsToTxnTopicResult()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal AddPartitionsToTxnTopicResult CreateAddPartitionsToTxnTopicResult()
		{
			return new AddPartitionsToTxnTopicResult(Version);
		}

		public class AddPartitionsToTxnTopicResult : ISerialize
		{
			internal AddPartitionsToTxnTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<AddPartitionsToTxnPartitionResult>.From(ResultsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AddPartitionsToTxnTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AddPartitionsToTxnTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResultsCollection = (await Array<AddPartitionsToTxnPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AddPartitionsToTxnPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.PartitionIndex);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<AddPartitionsToTxnPartitionResult>.From(ResultsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Dictionary<Int32, AddPartitionsToTxnPartitionResult> _resultsCollection = new Dictionary<Int32, AddPartitionsToTxnPartitionResult>();
			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<Int32, AddPartitionsToTxnPartitionResult> ResultsCollection 
			{
				get => _resultsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resultsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AddPartitionsToTxnTopicResult WithResultsCollection(params Func<AddPartitionsToTxnPartitionResult, AddPartitionsToTxnPartitionResult>[] createFields)
			{
				ResultsCollection = createFields
					.Select(createField => createField(CreateAddPartitionsToTxnPartitionResult()))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			internal AddPartitionsToTxnPartitionResult CreateAddPartitionsToTxnPartitionResult()
			{
				return new AddPartitionsToTxnPartitionResult(Version);
			}

			public class AddPartitionsToTxnPartitionResult : ISerialize
			{
				internal AddPartitionsToTxnPartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(3, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<AddPartitionsToTxnPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AddPartitionsToTxnPartitionResult(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AddPartitionsToTxnPartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition indexes.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition indexes.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AddPartitionsToTxnPartitionResult WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The response error code.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The response error code.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AddPartitionsToTxnPartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class AllocateProducerIdsRequest : Message, IRespond<AllocateProducerIdsResponse>
	{
		public AllocateProducerIdsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AllocateProducerIdsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(67);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AllocateProducerIdsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AllocateProducerIdsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AllocateProducerIdsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public AllocateProducerIdsRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		public AllocateProducerIdsResponse Respond()
			=> new AllocateProducerIdsResponse(Version);
	}

	public class AllocateProducerIdsResponse : Message
	{
		public AllocateProducerIdsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AllocateProducerIdsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(67);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AllocateProducerIdsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AllocateProducerIdsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerIdStart = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerIdLen = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AllocateProducerIdsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerIdStart.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerIdLen.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _producerIdStart = Int64.Default;
		/// <summary>
		/// <para>The first producer ID in this range, inclusive</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerIdStart 
		{
			get => _producerIdStart;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerIdStart does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerIdStart = value;
			}
		}

		/// <summary>
		/// <para>The first producer ID in this range, inclusive</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithProducerIdStart(Int64 producerIdStart)
		{
			ProducerIdStart = producerIdStart;
			return this;
		}

		private Int32 _producerIdLen = Int32.Default;
		/// <summary>
		/// <para>The number of producer IDs in this range</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ProducerIdLen 
		{
			get => _producerIdLen;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerIdLen does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerIdLen = value;
			}
		}

		/// <summary>
		/// <para>The number of producer IDs in this range</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AllocateProducerIdsResponse WithProducerIdLen(Int32 producerIdLen)
		{
			ProducerIdLen = producerIdLen;
			return this;
		}
	}

	public class AlterClientQuotasRequest : Message, IRespond<AlterClientQuotasResponse>
	{
		public AlterClientQuotasRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterClientQuotasRequest does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(49);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterClientQuotasRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterClientQuotasRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.EntriesCollection = await Array<EntryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterClientQuotasRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<EntryData>.From(EntriesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ValidateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private EntryData[] _entriesCollection = Array.Empty<EntryData>();
		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EntryData[] EntriesCollection 
		{
			get => _entriesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"EntriesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_entriesCollection = value;
			}
		}

		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasRequest WithEntriesCollection(params Func<EntryData, EntryData>[] createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(CreateEntryData()))
				.ToArray();
			return this;
		}

		internal EntryData CreateEntryData()
		{
			return new EntryData(Version);
		}

		public class EntryData : ISerialize
		{
			internal EntryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Array<EntityData>.From(EntityCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OpData>.From(OpsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<EntryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new EntryData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.EntityCollection = await Array<EntityData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntityData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.OpsCollection = await Array<OpData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OpData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for EntryData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<EntityData>.From(EntityCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OpData>.From(OpsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private EntityData[] _entityCollection = Array.Empty<EntityData>();
			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntityData[] EntityCollection 
			{
				get => _entityCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"EntityCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_entityCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(params Func<EntityData, EntityData>[] createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(CreateEntityData()))
					.ToArray();
				return this;
			}

			internal EntityData CreateEntityData()
			{
				return new EntityData(Version);
			}

			public class EntityData : ISerialize
			{
				internal EntityData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						EntityType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						EntityName.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<EntityData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EntityData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EntityName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EntityData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await EntityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await EntityName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _entityType = String.Default;
				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String EntityType 
				{
					get => _entityType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EntityType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_entityType = value;
					}
				}

				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityType(String entityType)
				{
					EntityType = entityType;
					return this;
				}

				private String? _entityName;
				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? EntityName 
				{
					get => _entityName;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EntityName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"EntityName does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_entityName = value;
					}
				}

				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityName(String? entityName)
				{
					EntityName = entityName;
					return this;
				}
			}

			private OpData[] _opsCollection = Array.Empty<OpData>();
			/// <summary>
			/// <para>An individual quota configuration entry to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OpData[] OpsCollection 
			{
				get => _opsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"OpsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_opsCollection = value;
				}
			}

			/// <summary>
			/// <para>An individual quota configuration entry to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithOpsCollection(params Func<OpData, OpData>[] createFields)
			{
				OpsCollection = createFields
					.Select(createField => createField(CreateOpData()))
					.ToArray();
				return this;
			}

			internal OpData CreateOpData()
			{
				return new OpData(Version);
			}

			public class OpData : ISerialize
			{
				internal OpData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Key.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Remove.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OpData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OpData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Value = await Float64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Remove = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OpData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Remove.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _key = String.Default;
				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Key 
				{
					get => _key;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Key does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_key = value;
					}
				}

				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OpData WithKey(String key)
				{
					Key = key;
					return this;
				}

				private Float64 _value = Float64.Default;
				/// <summary>
				/// <para>The value to set, otherwise ignored if the value is to be removed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Float64 Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The value to set, otherwise ignored if the value is to be removed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OpData WithValue(Float64 value)
				{
					Value = value;
					return this;
				}

				private Boolean _remove = Boolean.Default;
				/// <summary>
				/// <para>Whether the quota configuration value should be removed, otherwise set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean Remove 
				{
					get => _remove;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Remove does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_remove = value;
					}
				}

				/// <summary>
				/// <para>Whether the quota configuration value should be removed, otherwise set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OpData WithRemove(Boolean remove)
				{
					Remove = remove;
					return this;
				}
			}
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>Whether the alteration should be validated, but not performed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>Whether the alteration should be validated, but not performed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public AlterClientQuotasResponse Respond()
			=> new AlterClientQuotasResponse(Version);
	}

	public class AlterClientQuotasResponse : Message
	{
		public AlterClientQuotasResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterClientQuotasResponse does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(49);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterClientQuotasResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterClientQuotasResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.EntriesCollection = await Array<EntryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterClientQuotasResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<EntryData>.From(EntriesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private EntryData[] _entriesCollection = Array.Empty<EntryData>();
		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EntryData[] EntriesCollection 
		{
			get => _entriesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"EntriesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_entriesCollection = value;
			}
		}

		/// <summary>
		/// <para>The quota configuration entries to alter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterClientQuotasResponse WithEntriesCollection(params Func<EntryData, EntryData>[] createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(CreateEntryData()))
				.ToArray();
			return this;
		}

		internal EntryData CreateEntryData()
		{
			return new EntryData(Version);
		}

		public class EntryData : ISerialize
		{
			internal EntryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<EntityData>.From(EntityCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<EntryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new EntryData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.EntityCollection = await Array<EntityData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntityData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for EntryData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<EntityData>.From(EntityCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or `0` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or `0` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, or `null` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or `null` if the quota alteration succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private EntityData[] _entityCollection = Array.Empty<EntityData>();
			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntityData[] EntityCollection 
			{
				get => _entityCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"EntityCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_entityCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota entity to alter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(params Func<EntityData, EntityData>[] createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(CreateEntityData()))
					.ToArray();
				return this;
			}

			internal EntityData CreateEntityData()
			{
				return new EntityData(Version);
			}

			public class EntityData : ISerialize
			{
				internal EntityData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						EntityType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						EntityName.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<EntityData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EntityData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EntityName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EntityData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await EntityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await EntityName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _entityType = String.Default;
				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String EntityType 
				{
					get => _entityType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EntityType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_entityType = value;
					}
				}

				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityType(String entityType)
				{
					EntityType = entityType;
					return this;
				}

				private String? _entityName;
				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? EntityName 
				{
					get => _entityName;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EntityName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"EntityName does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_entityName = value;
					}
				}

				/// <summary>
				/// <para>The name of the entity, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityName(String? entityName)
				{
					EntityName = entityName;
					return this;
				}
			}
		}
	}

	public class AlterConfigsRequest : Message, IRespond<AlterConfigsResponse>
	{
		public AlterConfigsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterConfigsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(33);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterConfigsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterConfigsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResourcesCollection = (await Array<AlterConfigsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.ResourceType);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterConfigsResource>.From(ResourcesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ValidateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<Int8, AlterConfigsResource> _resourcesCollection = new Dictionary<Int8, AlterConfigsResource>();
		/// <summary>
		/// <para>The updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<Int8, AlterConfigsResource> ResourcesCollection 
		{
			get => _resourcesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResourcesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>The updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsRequest WithResourcesCollection(params Func<AlterConfigsResource, AlterConfigsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(CreateAlterConfigsResource()))
				.ToDictionary(field => field.ResourceType);
			return this;
		}

		internal AlterConfigsResource CreateAlterConfigsResource()
		{
			return new AlterConfigsResource(Version);
		}

		public class AlterConfigsResource : ISerialize
		{
			internal AlterConfigsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<AlterableConfig>.From(ConfigsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterConfigsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResource(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ConfigsCollection = (await Array<AlterableConfig>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterableConfig.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResource is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<AlterableConfig>.From(ConfigsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Dictionary<String, AlterableConfig> _configsCollection = new Dictionary<String, AlterableConfig>();
			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<String, AlterableConfig> ConfigsCollection 
			{
				get => _configsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ConfigsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithConfigsCollection(params Func<AlterableConfig, AlterableConfig>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(CreateAlterableConfig()))
					.ToDictionary(field => field.Name);
				return this;
			}

			internal AlterableConfig CreateAlterableConfig()
			{
				return new AlterableConfig(Version);
			}

			public class AlterableConfig : ISerialize
			{
				internal AlterableConfig(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<AlterableConfig> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterableConfig(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterableConfig is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithName(String name)
				{
					Name = name;
					return this;
				}

				private String? _value;
				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithValue(String? value)
				{
					Value = value;
					return this;
				}
			}
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public AlterConfigsResponse Respond()
			=> new AlterConfigsResponse(Version);
	}

	public class AlterConfigsResponse : Message
	{
		public AlterConfigsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterConfigsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(33);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterConfigsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterConfigsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponsesCollection = await Array<AlterConfigsResourceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResourceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterConfigsResourceResponse>.From(ResponsesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private AlterConfigsResourceResponse[] _responsesCollection = Array.Empty<AlterConfigsResourceResponse>();
		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResourceResponse[] ResponsesCollection 
		{
			get => _responsesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResponse WithResponsesCollection(params Func<AlterConfigsResourceResponse, AlterConfigsResourceResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(CreateAlterConfigsResourceResponse()))
				.ToArray();
			return this;
		}

		internal AlterConfigsResourceResponse CreateAlterConfigsResourceResponse()
		{
			return new AlterConfigsResourceResponse(Version);
		}

		public class AlterConfigsResourceResponse : ISerialize
		{
			internal AlterConfigsResourceResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterConfigsResourceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResourceResponse(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResourceResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}
		}
	}

	public class AlterIsrRequest : Message, IRespond<AlterIsrResponse>
	{
		public AlterIsrRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterIsrRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(56);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterIsrRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterIsrRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterIsrRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterIsrRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The epoch of the requesting broker</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public AlterIsrRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterIsrRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic to alter ISRs for</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to alter ISRs for</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(NewIsrCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CurrentIsrVersion.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.NewIsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CurrentIsrVersion = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(NewIsrCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CurrentIsrVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch of this partition</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int32[] _newIsrCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The ISR for this partition</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] NewIsrCollection 
				{
					get => _newIsrCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"NewIsrCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_newIsrCollection = value;
					}
				}

				/// <summary>
				/// <para>The ISR for this partition</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithNewIsrCollection(Int32[] newIsrCollection)
				{
					NewIsrCollection = newIsrCollection;
					return this;
				}

				private Int32 _currentIsrVersion = Int32.Default;
				/// <summary>
				/// <para>The expected version of ISR which is being updated</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CurrentIsrVersion 
				{
					get => _currentIsrVersion;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CurrentIsrVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_currentIsrVersion = value;
					}
				}

				/// <summary>
				/// <para>The expected version of ISR which is being updated</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCurrentIsrVersion(Int32 currentIsrVersion)
				{
					CurrentIsrVersion = currentIsrVersion;
					return this;
				}
			}
		}

		public AlterIsrResponse Respond()
			=> new AlterIsrResponse(Version);
	}

	public class AlterIsrResponse : Message
	{
		public AlterIsrResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterIsrResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(56);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterIsrResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterIsrResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterIsrResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterIsrResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterIsrResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterIsrResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(IsrCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CurrentIsrVersion.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.IsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CurrentIsrVersion = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(IsrCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CurrentIsrVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition level error code</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition level error code</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The broker ID of the leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The broker ID of the leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int32[] _isrCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The in-sync replica IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] IsrCollection 
				{
					get => _isrCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"IsrCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_isrCollection = value;
					}
				}

				/// <summary>
				/// <para>The in-sync replica IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithIsrCollection(Int32[] isrCollection)
				{
					IsrCollection = isrCollection;
					return this;
				}

				private Int32 _currentIsrVersion = Int32.Default;
				/// <summary>
				/// <para>The current ISR version.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CurrentIsrVersion 
				{
					get => _currentIsrVersion;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CurrentIsrVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_currentIsrVersion = value;
					}
				}

				/// <summary>
				/// <para>The current ISR version.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCurrentIsrVersion(Int32 currentIsrVersion)
				{
					CurrentIsrVersion = currentIsrVersion;
					return this;
				}
			}
		}
	}

	public class AlterPartitionReassignmentsRequest : Message, IRespond<AlterPartitionReassignmentsResponse>
	{
		public AlterPartitionReassignmentsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterPartitionReassignmentsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(45);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterPartitionReassignmentsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterPartitionReassignmentsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<ReassignableTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignableTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterPartitionReassignmentsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ReassignableTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public AlterPartitionReassignmentsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private ReassignableTopic[] _topicsCollection = Array.Empty<ReassignableTopic>();
		/// <summary>
		/// <para>The topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReassignableTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsRequest WithTopicsCollection(params Func<ReassignableTopic, ReassignableTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateReassignableTopic()))
				.ToArray();
			return this;
		}

		internal ReassignableTopic CreateReassignableTopic()
		{
			return new ReassignableTopic(Version);
		}

		public class ReassignableTopic : ISerialize
		{
			internal ReassignableTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<ReassignablePartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ReassignableTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReassignableTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<ReassignablePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignablePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignableTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<ReassignablePartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private ReassignablePartition[] _partitionsCollection = Array.Empty<ReassignablePartition>();
			/// <summary>
			/// <para>The partitions to reassign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignablePartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to reassign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopic WithPartitionsCollection(params Func<ReassignablePartition, ReassignablePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateReassignablePartition()))
					.ToArray();
				return this;
			}

			internal ReassignablePartition CreateReassignablePartition()
			{
				return new ReassignablePartition(Version);
			}

			public class ReassignablePartition : ISerialize
			{
				internal ReassignablePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						NullableArray<Int32>.From(ReplicasCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<ReassignablePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ReassignablePartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ReplicasCollection = await NullableArray<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignablePartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await NullableArray<Int32>.From(ReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32[]? _replicasCollection;
				/// <summary>
				/// <para>The replicas to place the partitions on, or null to cancel a pending reassignment for this partition.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public Int32[]? ReplicasCollection 
				{
					get => _replicasCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ReplicasCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"ReplicasCollection does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_replicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The replicas to place the partitions on, or null to cancel a pending reassignment for this partition.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public ReassignablePartition WithReplicasCollection(Int32[]? replicasCollection)
				{
					ReplicasCollection = replicasCollection;
					return this;
				}
			}
		}

		public AlterPartitionReassignmentsResponse Respond()
			=> new AlterPartitionReassignmentsResponse(Version);
	}

	public class AlterPartitionReassignmentsResponse : Message
	{
		public AlterPartitionReassignmentsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterPartitionReassignmentsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(45);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterPartitionReassignmentsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterPartitionReassignmentsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponsesCollection = await Array<ReassignableTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignableTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterPartitionReassignmentsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ReassignableTopicResponse>.From(ResponsesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private ReassignableTopicResponse[] _responsesCollection = Array.Empty<ReassignableTopicResponse>();
		/// <summary>
		/// <para>The responses to topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReassignableTopicResponse[] ResponsesCollection 
		{
			get => _responsesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses to topics to reassign.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterPartitionReassignmentsResponse WithResponsesCollection(params Func<ReassignableTopicResponse, ReassignableTopicResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(CreateReassignableTopicResponse()))
				.ToArray();
			return this;
		}

		internal ReassignableTopicResponse CreateReassignableTopicResponse()
		{
			return new ReassignableTopicResponse(Version);
		}

		public class ReassignableTopicResponse : ISerialize
		{
			internal ReassignableTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<ReassignablePartitionResponse>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ReassignableTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReassignableTopicResponse(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<ReassignablePartitionResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReassignablePartitionResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignableTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<ReassignablePartitionResponse>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopicResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private ReassignablePartitionResponse[] _partitionsCollection = Array.Empty<ReassignablePartitionResponse>();
			/// <summary>
			/// <para>The responses to partitions to reassign</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignablePartitionResponse[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses to partitions to reassign</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReassignableTopicResponse WithPartitionsCollection(params Func<ReassignablePartitionResponse, ReassignablePartitionResponse>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateReassignablePartitionResponse()))
					.ToArray();
				return this;
			}

			internal ReassignablePartitionResponse CreateReassignablePartitionResponse()
			{
				return new ReassignablePartitionResponse(Version);
			}

			public class ReassignablePartitionResponse : ISerialize
			{
				internal ReassignablePartitionResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorMessage.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<ReassignablePartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ReassignablePartitionResponse(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ReassignablePartitionResponse is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartitionResponse WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code for this partition, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code for this partition, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartitionResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private String? _errorMessage;
				/// <summary>
				/// <para>The error message for this partition, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The error message for this partition, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReassignablePartitionResponse WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class AlterReplicaLogDirsRequest : Message, IRespond<AlterReplicaLogDirsResponse>
	{
		public AlterReplicaLogDirsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterReplicaLogDirsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(34);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterReplicaLogDirsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterReplicaLogDirsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.DirsCollection = (await Array<AlterReplicaLogDir>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDir.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Path);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterReplicaLogDir>.From(DirsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<String, AlterReplicaLogDir> _dirsCollection = new Dictionary<String, AlterReplicaLogDir>();
		/// <summary>
		/// <para>The alterations to make for each directory.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, AlterReplicaLogDir> DirsCollection 
		{
			get => _dirsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"DirsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_dirsCollection = value;
			}
		}

		/// <summary>
		/// <para>The alterations to make for each directory.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsRequest WithDirsCollection(params Func<AlterReplicaLogDir, AlterReplicaLogDir>[] createFields)
		{
			DirsCollection = createFields
				.Select(createField => createField(CreateAlterReplicaLogDir()))
				.ToDictionary(field => field.Path);
			return this;
		}

		internal AlterReplicaLogDir CreateAlterReplicaLogDir()
		{
			return new AlterReplicaLogDir(Version);
		}

		public class AlterReplicaLogDir : ISerialize
		{
			internal AlterReplicaLogDir(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Path.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<AlterReplicaLogDirTopic>.From(TopicsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterReplicaLogDir> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterReplicaLogDir(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Path = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicsCollection = (await Array<AlterReplicaLogDirTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDirTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDir is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Path.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<AlterReplicaLogDirTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _path = String.Default;
			/// <summary>
			/// <para>The absolute directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Path 
			{
				get => _path;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Path does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_path = value;
				}
			}

			/// <summary>
			/// <para>The absolute directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDir WithPath(String path)
			{
				Path = path;
				return this;
			}

			private Dictionary<String, AlterReplicaLogDirTopic> _topicsCollection = new Dictionary<String, AlterReplicaLogDirTopic>();
			/// <summary>
			/// <para>The topics to add to the directory.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<String, AlterReplicaLogDirTopic> TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The topics to add to the directory.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDir WithTopicsCollection(params Func<AlterReplicaLogDirTopic, AlterReplicaLogDirTopic>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateAlterReplicaLogDirTopic()))
					.ToDictionary(field => field.Name);
				return this;
			}

			internal AlterReplicaLogDirTopic CreateAlterReplicaLogDirTopic()
			{
				return new AlterReplicaLogDirTopic(Version);
			}

			public class AlterReplicaLogDirTopic : ISerialize
			{
				internal AlterReplicaLogDirTopic(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<AlterReplicaLogDirTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterReplicaLogDirTopic(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirTopic is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirTopic WithName(String name)
				{
					Name = name;
					return this;
				}

				private Int32[] _partitionsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The partition indexes.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] PartitionsCollection 
				{
					get => _partitionsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The partition indexes.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirTopic WithPartitionsCollection(Int32[] partitionsCollection)
				{
					PartitionsCollection = partitionsCollection;
					return this;
				}
			}
		}

		public AlterReplicaLogDirsResponse Respond()
			=> new AlterReplicaLogDirsResponse(Version);
	}

	public class AlterReplicaLogDirsResponse : Message
	{
		public AlterReplicaLogDirsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterReplicaLogDirsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(34);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterReplicaLogDirsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterReplicaLogDirsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<AlterReplicaLogDirTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDirTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterReplicaLogDirTopicResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private AlterReplicaLogDirTopicResult[] _resultsCollection = Array.Empty<AlterReplicaLogDirTopicResult>();
		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirTopicResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterReplicaLogDirsResponse WithResultsCollection(params Func<AlterReplicaLogDirTopicResult, AlterReplicaLogDirTopicResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateAlterReplicaLogDirTopicResult()))
				.ToArray();
			return this;
		}

		internal AlterReplicaLogDirTopicResult CreateAlterReplicaLogDirTopicResult()
		{
			return new AlterReplicaLogDirTopicResult(Version);
		}

		public class AlterReplicaLogDirTopicResult : ISerialize
		{
			internal AlterReplicaLogDirTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<AlterReplicaLogDirPartitionResult>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterReplicaLogDirTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterReplicaLogDirTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<AlterReplicaLogDirPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterReplicaLogDirPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<AlterReplicaLogDirPartitionResult>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDirTopicResult WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private AlterReplicaLogDirPartitionResult[] _partitionsCollection = Array.Empty<AlterReplicaLogDirPartitionResult>();
			/// <summary>
			/// <para>The results for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDirPartitionResult[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterReplicaLogDirTopicResult WithPartitionsCollection(params Func<AlterReplicaLogDirPartitionResult, AlterReplicaLogDirPartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateAlterReplicaLogDirPartitionResult()))
					.ToArray();
				return this;
			}

			internal AlterReplicaLogDirPartitionResult CreateAlterReplicaLogDirPartitionResult()
			{
				return new AlterReplicaLogDirPartitionResult(Version);
			}

			public class AlterReplicaLogDirPartitionResult : ISerialize
			{
				internal AlterReplicaLogDirPartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<AlterReplicaLogDirPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterReplicaLogDirPartitionResult(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterReplicaLogDirPartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirPartitionResult WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterReplicaLogDirPartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class AlterUserScramCredentialsRequest : Message, IRespond<AlterUserScramCredentialsResponse>
	{
		public AlterUserScramCredentialsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterUserScramCredentialsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(51);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterUserScramCredentialsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterUserScramCredentialsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.DeletionsCollection = await Array<ScramCredentialDeletion>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ScramCredentialDeletion.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.UpsertionsCollection = await Array<ScramCredentialUpsertion>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ScramCredentialUpsertion.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterUserScramCredentialsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ScramCredentialDeletion>.From(DeletionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ScramCredentialUpsertion>.From(UpsertionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private ScramCredentialDeletion[] _deletionsCollection = Array.Empty<ScramCredentialDeletion>();
		/// <summary>
		/// <para>The SCRAM credentials to remove.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ScramCredentialDeletion[] DeletionsCollection 
		{
			get => _deletionsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"DeletionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_deletionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The SCRAM credentials to remove.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsRequest WithDeletionsCollection(params Func<ScramCredentialDeletion, ScramCredentialDeletion>[] createFields)
		{
			DeletionsCollection = createFields
				.Select(createField => createField(CreateScramCredentialDeletion()))
				.ToArray();
			return this;
		}

		internal ScramCredentialDeletion CreateScramCredentialDeletion()
		{
			return new ScramCredentialDeletion(Version);
		}

		public class ScramCredentialDeletion : ISerialize
		{
			internal ScramCredentialDeletion(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Mechanism.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ScramCredentialDeletion> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ScramCredentialDeletion(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Mechanism = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ScramCredentialDeletion is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialDeletion WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int8 _mechanism = Int8.Default;
			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Mechanism 
			{
				get => _mechanism;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Mechanism does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_mechanism = value;
				}
			}

			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialDeletion WithMechanism(Int8 mechanism)
			{
				Mechanism = mechanism;
				return this;
			}
		}

		private ScramCredentialUpsertion[] _upsertionsCollection = Array.Empty<ScramCredentialUpsertion>();
		/// <summary>
		/// <para>The SCRAM credentials to update/insert.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ScramCredentialUpsertion[] UpsertionsCollection 
		{
			get => _upsertionsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"UpsertionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_upsertionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The SCRAM credentials to update/insert.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsRequest WithUpsertionsCollection(params Func<ScramCredentialUpsertion, ScramCredentialUpsertion>[] createFields)
		{
			UpsertionsCollection = createFields
				.Select(createField => createField(CreateScramCredentialUpsertion()))
				.ToArray();
			return this;
		}

		internal ScramCredentialUpsertion CreateScramCredentialUpsertion()
		{
			return new ScramCredentialUpsertion(Version);
		}

		public class ScramCredentialUpsertion : ISerialize
		{
			internal ScramCredentialUpsertion(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Mechanism.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Iterations.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Salt.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					SaltedPassword.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ScramCredentialUpsertion> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ScramCredentialUpsertion(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Mechanism = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Iterations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Salt = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.SaltedPassword = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ScramCredentialUpsertion is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Iterations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Salt.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await SaltedPassword.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int8 _mechanism = Int8.Default;
			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Mechanism 
			{
				get => _mechanism;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Mechanism does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_mechanism = value;
				}
			}

			/// <summary>
			/// <para>The SCRAM mechanism.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithMechanism(Int8 mechanism)
			{
				Mechanism = mechanism;
				return this;
			}

			private Int32 _iterations = Int32.Default;
			/// <summary>
			/// <para>The number of iterations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Iterations 
			{
				get => _iterations;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Iterations does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_iterations = value;
				}
			}

			/// <summary>
			/// <para>The number of iterations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithIterations(Int32 iterations)
			{
				Iterations = iterations;
				return this;
			}

			private Bytes _salt = Bytes.Default;
			/// <summary>
			/// <para>A random salt generated by the client.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Salt 
			{
				get => _salt;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Salt does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_salt = value;
				}
			}

			/// <summary>
			/// <para>A random salt generated by the client.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithSalt(Bytes salt)
			{
				Salt = salt;
				return this;
			}

			private Bytes _saltedPassword = Bytes.Default;
			/// <summary>
			/// <para>The salted password.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes SaltedPassword 
			{
				get => _saltedPassword;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"SaltedPassword does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_saltedPassword = value;
				}
			}

			/// <summary>
			/// <para>The salted password.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ScramCredentialUpsertion WithSaltedPassword(Bytes saltedPassword)
			{
				SaltedPassword = saltedPassword;
				return this;
			}
		}

		public AlterUserScramCredentialsResponse Respond()
			=> new AlterUserScramCredentialsResponse(Version);
	}

	public class AlterUserScramCredentialsResponse : Message
	{
		public AlterUserScramCredentialsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"AlterUserScramCredentialsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(51);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<AlterUserScramCredentialsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new AlterUserScramCredentialsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<AlterUserScramCredentialsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterUserScramCredentialsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterUserScramCredentialsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterUserScramCredentialsResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private AlterUserScramCredentialsResult[] _resultsCollection = Array.Empty<AlterUserScramCredentialsResult>();
		/// <summary>
		/// <para>The results for deletions and alterations, one per affected user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for deletions and alterations, one per affected user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterUserScramCredentialsResponse WithResultsCollection(params Func<AlterUserScramCredentialsResult, AlterUserScramCredentialsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateAlterUserScramCredentialsResult()))
				.ToArray();
			return this;
		}

		internal AlterUserScramCredentialsResult CreateAlterUserScramCredentialsResult()
		{
			return new AlterUserScramCredentialsResult(Version);
		}

		public class AlterUserScramCredentialsResult : ISerialize
		{
			internal AlterUserScramCredentialsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					User.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterUserScramCredentialsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterUserScramCredentialsResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.User = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterUserScramCredentialsResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await User.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _user = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String User 
			{
				get => _user;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"User does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_user = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterUserScramCredentialsResult WithUser(String user)
			{
				User = user;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterUserScramCredentialsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterUserScramCredentialsResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class ApiVersionsRequest : Message, IRespond<ApiVersionsResponse>
	{
		public ApiVersionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ApiVersionsRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(18);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ApiVersionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ApiVersionsRequest(version);
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ClientSoftwareName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ClientSoftwareVersion = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ApiVersionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(3, 2147483647)) 
			{
				await ClientSoftwareName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await ClientSoftwareVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _clientSoftwareName = String.Default;
		/// <summary>
		/// <para>The name of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String ClientSoftwareName 
		{
			get => _clientSoftwareName;
			set 
			{
				_clientSoftwareName = value;
			}
		}

		/// <summary>
		/// <para>The name of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsRequest WithClientSoftwareName(String clientSoftwareName)
		{
			ClientSoftwareName = clientSoftwareName;
			return this;
		}

		private String _clientSoftwareVersion = String.Default;
		/// <summary>
		/// <para>The version of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public String ClientSoftwareVersion 
		{
			get => _clientSoftwareVersion;
			set 
			{
				_clientSoftwareVersion = value;
			}
		}

		/// <summary>
		/// <para>The version of the client.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsRequest WithClientSoftwareVersion(String clientSoftwareVersion)
		{
			ClientSoftwareVersion = clientSoftwareVersion;
			return this;
		}

		public ApiVersionsResponse Respond()
			=> new ApiVersionsResponse(Version);
	}

	public class ApiVersionsResponse : Message
	{
		public ApiVersionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ApiVersionsResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(18);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ApiVersionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ApiVersionsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ApiKeysCollection = (await Array<ApiVersion>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ApiVersion.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.ApiKey);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version.InRange(3, 2147483647)) 
							{
								instance.SupportedFeaturesCollection = (await Array<SupportedFeatureKey>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => SupportedFeatureKey.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
							}
							else
								throw new InvalidOperationException($"Field SupportedFeaturesCollection is not supported for version {instance.Version}");
							break;

						case 1:
							if (instance.Version.InRange(3, 2147483647)) 
							{
								instance.FinalizedFeaturesEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							}
							else
								throw new InvalidOperationException($"Field FinalizedFeaturesEpoch is not supported for version {instance.Version}");
							break;

						case 2:
							if (instance.Version.InRange(3, 2147483647)) 
							{
								instance.FinalizedFeaturesCollection = (await Array<FinalizedFeatureKey>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FinalizedFeatureKey.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
							}
							else
								throw new InvalidOperationException($"Field FinalizedFeaturesCollection is not supported for version {instance.Version}");
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ApiVersionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ApiVersion>.From(ApiKeysCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await Array<SupportedFeatureKey>.From(SupportedFeaturesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await FinalizedFeaturesEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await Array<FinalizedFeatureKey>.From(FinalizedFeaturesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ApiVersionsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Dictionary<Int16, ApiVersion> _apiKeysCollection = new Dictionary<Int16, ApiVersion>();
		/// <summary>
		/// <para>The APIs supported by the broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<Int16, ApiVersion> ApiKeysCollection 
		{
			get => _apiKeysCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ApiKeysCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_apiKeysCollection = value;
			}
		}

		/// <summary>
		/// <para>The APIs supported by the broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ApiVersionsResponse WithApiKeysCollection(params Func<ApiVersion, ApiVersion>[] createFields)
		{
			ApiKeysCollection = createFields
				.Select(createField => createField(CreateApiVersion()))
				.ToDictionary(field => field.ApiKey);
			return this;
		}

		internal ApiVersion CreateApiVersion()
		{
			return new ApiVersion(Version);
		}

		public class ApiVersion : ISerialize
		{
			internal ApiVersion(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ApiKey.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MinVersion.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MaxVersion.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ApiVersion> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ApiVersion(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ApiKey = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MinVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MaxVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ApiVersion is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ApiKey.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MinVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MaxVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _apiKey = Int16.Default;
			/// <summary>
			/// <para>The API index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ApiKey 
			{
				get => _apiKey;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ApiKey does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_apiKey = value;
				}
			}

			/// <summary>
			/// <para>The API index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ApiVersion WithApiKey(Int16 apiKey)
			{
				ApiKey = apiKey;
				return this;
			}

			private Int16 _minVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MinVersion 
			{
				get => _minVersion;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MinVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_minVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ApiVersion WithMinVersion(Int16 minVersion)
			{
				MinVersion = minVersion;
				return this;
			}

			private Int16 _maxVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxVersion 
			{
				get => _maxVersion;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MaxVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_maxVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported version, inclusive.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ApiVersion WithMaxVersion(Int16 maxVersion)
			{
				MaxVersion = maxVersion;
				return this;
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ApiVersionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, SupportedFeatureKey> _supportedFeaturesCollection = new Dictionary<String, SupportedFeatureKey>();
		/// <summary>
		/// <para>Features supported by the broker.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Dictionary<String, SupportedFeatureKey> SupportedFeaturesCollection 
		{
			get => _supportedFeaturesCollection;
			set 
			{
				_supportedFeaturesCollection = value;
			}
		}

		/// <summary>
		/// <para>Features supported by the broker.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsResponse WithSupportedFeaturesCollection(params Func<SupportedFeatureKey, SupportedFeatureKey>[] createFields)
		{
			SupportedFeaturesCollection = createFields
				.Select(createField => createField(CreateSupportedFeatureKey()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal SupportedFeatureKey CreateSupportedFeatureKey()
		{
			return new SupportedFeatureKey(Version);
		}

		public class SupportedFeatureKey : ISerialize
		{
			internal SupportedFeatureKey(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(3, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					MinVersion.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					MaxVersion.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<SupportedFeatureKey> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new SupportedFeatureKey(version);
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.MinVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.MaxVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for SupportedFeatureKey is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(3, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await MinVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await MaxVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public SupportedFeatureKey WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _minVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MinVersion 
			{
				get => _minVersion;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MinVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_minVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public SupportedFeatureKey WithMinVersion(Int16 minVersion)
			{
				MinVersion = minVersion;
				return this;
			}

			private Int16 _maxVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MaxVersion 
			{
				get => _maxVersion;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MaxVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_maxVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported version for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public SupportedFeatureKey WithMaxVersion(Int16 maxVersion)
			{
				MaxVersion = maxVersion;
				return this;
			}
		}

		private Int64 _finalizedFeaturesEpoch = new Int64(-1);
		/// <summary>
		/// <para>The monotonically increasing epoch for the finalized features information. Valid values are >= 0. A value of -1 is special and represents unknown epoch.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 FinalizedFeaturesEpoch 
		{
			get => _finalizedFeaturesEpoch;
			set 
			{
				_finalizedFeaturesEpoch = value;
			}
		}

		/// <summary>
		/// <para>The monotonically increasing epoch for the finalized features information. Valid values are >= 0. A value of -1 is special and represents unknown epoch.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ApiVersionsResponse WithFinalizedFeaturesEpoch(Int64 finalizedFeaturesEpoch)
		{
			FinalizedFeaturesEpoch = finalizedFeaturesEpoch;
			return this;
		}

		private Dictionary<String, FinalizedFeatureKey> _finalizedFeaturesCollection = new Dictionary<String, FinalizedFeatureKey>();
		/// <summary>
		/// <para>List of cluster-wide finalized features. The information is valid only if FinalizedFeaturesEpoch >= 0.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Dictionary<String, FinalizedFeatureKey> FinalizedFeaturesCollection 
		{
			get => _finalizedFeaturesCollection;
			set 
			{
				_finalizedFeaturesCollection = value;
			}
		}

		/// <summary>
		/// <para>List of cluster-wide finalized features. The information is valid only if FinalizedFeaturesEpoch >= 0.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public ApiVersionsResponse WithFinalizedFeaturesCollection(params Func<FinalizedFeatureKey, FinalizedFeatureKey>[] createFields)
		{
			FinalizedFeaturesCollection = createFields
				.Select(createField => createField(CreateFinalizedFeatureKey()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal FinalizedFeatureKey CreateFinalizedFeatureKey()
		{
			return new FinalizedFeatureKey(Version);
		}

		public class FinalizedFeatureKey : ISerialize
		{
			internal FinalizedFeatureKey(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(3, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					MaxVersionLevel.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					MinVersionLevel.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<FinalizedFeatureKey> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FinalizedFeatureKey(version);
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.MaxVersionLevel = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.MinVersionLevel = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FinalizedFeatureKey is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(3, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await MaxVersionLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await MinVersionLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public FinalizedFeatureKey WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _maxVersionLevel = Int16.Default;
			/// <summary>
			/// <para>The cluster-wide finalized max version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MaxVersionLevel 
			{
				get => _maxVersionLevel;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MaxVersionLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_maxVersionLevel = value;
				}
			}

			/// <summary>
			/// <para>The cluster-wide finalized max version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public FinalizedFeatureKey WithMaxVersionLevel(Int16 maxVersionLevel)
			{
				MaxVersionLevel = maxVersionLevel;
				return this;
			}

			private Int16 _minVersionLevel = Int16.Default;
			/// <summary>
			/// <para>The cluster-wide finalized min version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 MinVersionLevel 
			{
				get => _minVersionLevel;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MinVersionLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_minVersionLevel = value;
				}
			}

			/// <summary>
			/// <para>The cluster-wide finalized min version level for the feature.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public FinalizedFeatureKey WithMinVersionLevel(Int16 minVersionLevel)
			{
				MinVersionLevel = minVersionLevel;
				return this;
			}
		}
	}

	public class BeginQuorumEpochRequest : Message, IRespond<BeginQuorumEpochResponse>
	{
		public BeginQuorumEpochRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"BeginQuorumEpochRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(53);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<BeginQuorumEpochRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BeginQuorumEpochRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BeginQuorumEpochRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _clusterId;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public BeginQuorumEpochRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, -1);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The epoch of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch of the newly elected leader</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}

		public BeginQuorumEpochResponse Respond()
			=> new BeginQuorumEpochResponse(Version);
	}

	public class BeginQuorumEpochResponse : Message
	{
		public BeginQuorumEpochResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"BeginQuorumEpochResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(53);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<BeginQuorumEpochResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BeginQuorumEpochResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BeginQuorumEpochResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BeginQuorumEpochResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, -1);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}
	}

	public class BrokerHeartbeatRequest : Message, IRespond<BrokerHeartbeatResponse>
	{
		public BrokerHeartbeatRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"BrokerHeartbeatRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(63);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<BrokerHeartbeatRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerHeartbeatRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.CurrentMetadataOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.WantFence = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.WantShutDown = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerHeartbeatRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await CurrentMetadataOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await WantFence.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await WantShutDown.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public BrokerHeartbeatRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Int64 _currentMetadataOffset = Int64.Default;
		/// <summary>
		/// <para>The highest metadata offset which the broker has reached.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 CurrentMetadataOffset 
		{
			get => _currentMetadataOffset;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"CurrentMetadataOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_currentMetadataOffset = value;
			}
		}

		/// <summary>
		/// <para>The highest metadata offset which the broker has reached.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithCurrentMetadataOffset(Int64 currentMetadataOffset)
		{
			CurrentMetadataOffset = currentMetadataOffset;
			return this;
		}

		private Boolean _wantFence = Boolean.Default;
		/// <summary>
		/// <para>True if the broker wants to be fenced, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean WantFence 
		{
			get => _wantFence;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"WantFence does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_wantFence = value;
			}
		}

		/// <summary>
		/// <para>True if the broker wants to be fenced, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithWantFence(Boolean wantFence)
		{
			WantFence = wantFence;
			return this;
		}

		private Boolean _wantShutDown = Boolean.Default;
		/// <summary>
		/// <para>True if the broker wants to be shut down, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean WantShutDown 
		{
			get => _wantShutDown;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"WantShutDown does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_wantShutDown = value;
			}
		}

		/// <summary>
		/// <para>True if the broker wants to be shut down, false otherwise.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatRequest WithWantShutDown(Boolean wantShutDown)
		{
			WantShutDown = wantShutDown;
			return this;
		}

		public BrokerHeartbeatResponse Respond()
			=> new BrokerHeartbeatResponse(Version);
	}

	public class BrokerHeartbeatResponse : Message
	{
		public BrokerHeartbeatResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"BrokerHeartbeatResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(63);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<BrokerHeartbeatResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerHeartbeatResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.IsCaughtUp = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.IsFenced = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ShouldShutDown = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerHeartbeatResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await IsCaughtUp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await IsFenced.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ShouldShutDown.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Boolean _isCaughtUp = new Boolean(false);
		/// <summary>
		/// <para>True if the broker has approximately caught up with the latest metadata.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IsCaughtUp 
		{
			get => _isCaughtUp;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IsCaughtUp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_isCaughtUp = value;
			}
		}

		/// <summary>
		/// <para>True if the broker has approximately caught up with the latest metadata.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: false</para>
		/// </summary>
		public BrokerHeartbeatResponse WithIsCaughtUp(Boolean isCaughtUp)
		{
			IsCaughtUp = isCaughtUp;
			return this;
		}

		private Boolean _isFenced = new Boolean(true);
		/// <summary>
		/// <para>True if the broker is fenced.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: true</para>
		/// </summary>
		public Boolean IsFenced 
		{
			get => _isFenced;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IsFenced does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_isFenced = value;
			}
		}

		/// <summary>
		/// <para>True if the broker is fenced.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: true</para>
		/// </summary>
		public BrokerHeartbeatResponse WithIsFenced(Boolean isFenced)
		{
			IsFenced = isFenced;
			return this;
		}

		private Boolean _shouldShutDown = Boolean.Default;
		/// <summary>
		/// <para>True if the broker should proceed with its shutdown.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ShouldShutDown 
		{
			get => _shouldShutDown;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ShouldShutDown does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_shouldShutDown = value;
			}
		}

		/// <summary>
		/// <para>True if the broker should proceed with its shutdown.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerHeartbeatResponse WithShouldShutDown(Boolean shouldShutDown)
		{
			ShouldShutDown = shouldShutDown;
			return this;
		}
	}

	public class BrokerRegistrationRequest : Message, IRespond<BrokerRegistrationResponse>
	{
		public BrokerRegistrationRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"BrokerRegistrationRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(62);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<BrokerRegistrationRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerRegistrationRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.IncarnationId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ListenersCollection = (await Array<Listener>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Listener.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.FeaturesCollection = (await Array<Feature>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Feature.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerRegistrationRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await IncarnationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<Listener>.From(ListenersCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<Feature>.From(FeaturesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>The cluster id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The cluster id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Uuid _incarnationId = Uuid.Default;
		/// <summary>
		/// <para>The incarnation id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Uuid IncarnationId 
		{
			get => _incarnationId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IncarnationId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_incarnationId = value;
			}
		}

		/// <summary>
		/// <para>The incarnation id of the broker process.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithIncarnationId(Uuid incarnationId)
		{
			IncarnationId = incarnationId;
			return this;
		}

		private Dictionary<String, Listener> _listenersCollection = new Dictionary<String, Listener>();
		/// <summary>
		/// <para>The listeners of this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, Listener> ListenersCollection 
		{
			get => _listenersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ListenersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_listenersCollection = value;
			}
		}

		/// <summary>
		/// <para>The listeners of this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithListenersCollection(params Func<Listener, Listener>[] createFields)
		{
			ListenersCollection = createFields
				.Select(createField => createField(CreateListener()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal Listener CreateListener()
		{
			return new Listener(Version);
		}

		public class Listener : ISerialize
		{
			internal Listener(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Host.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Port.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					SecurityProtocol.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<Listener> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Listener(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Port = await UInt16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.SecurityProtocol = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Listener is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await SecurityProtocol.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the endpoint.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the endpoint.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithName(String name)
			{
				Name = name;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_host = value;
				}
			}

			/// <summary>
			/// <para>The hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithHost(String host)
			{
				Host = host;
				return this;
			}

			private UInt16 _port = UInt16.Default;
			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UInt16 Port 
			{
				get => _port;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_port = value;
				}
			}

			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithPort(UInt16 port)
			{
				Port = port;
				return this;
			}

			private Int16 _securityProtocol = Int16.Default;
			/// <summary>
			/// <para>The security protocol.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 SecurityProtocol 
			{
				get => _securityProtocol;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"SecurityProtocol does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_securityProtocol = value;
				}
			}

			/// <summary>
			/// <para>The security protocol.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Listener WithSecurityProtocol(Int16 securityProtocol)
			{
				SecurityProtocol = securityProtocol;
				return this;
			}
		}

		private Dictionary<String, Feature> _featuresCollection = new Dictionary<String, Feature>();
		/// <summary>
		/// <para>The features on this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, Feature> FeaturesCollection 
		{
			get => _featuresCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"FeaturesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_featuresCollection = value;
			}
		}

		/// <summary>
		/// <para>The features on this broker</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithFeaturesCollection(params Func<Feature, Feature>[] createFields)
		{
			FeaturesCollection = createFields
				.Select(createField => createField(CreateFeature()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal Feature CreateFeature()
		{
			return new Feature(Version);
		}

		public class Feature : ISerialize
		{
			internal Feature(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MinSupportedVersion.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MaxSupportedVersion.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<Feature> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Feature(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MinSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MaxSupportedVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Feature is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MinSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MaxSupportedVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The feature name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The feature name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _minSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The minimum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MinSupportedVersion 
			{
				get => _minSupportedVersion;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MinSupportedVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_minSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The minimum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithMinSupportedVersion(Int16 minSupportedVersion)
			{
				MinSupportedVersion = minSupportedVersion;
				return this;
			}

			private Int16 _maxSupportedVersion = Int16.Default;
			/// <summary>
			/// <para>The maximum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxSupportedVersion 
			{
				get => _maxSupportedVersion;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MaxSupportedVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_maxSupportedVersion = value;
				}
			}

			/// <summary>
			/// <para>The maximum supported feature level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Feature WithMaxSupportedVersion(Int16 maxSupportedVersion)
			{
				MaxSupportedVersion = maxSupportedVersion;
				return this;
			}
		}

		private String? _rack;
		/// <summary>
		/// <para>The rack which this broker is in.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? Rack 
		{
			get => _rack;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Rack does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_rack = value;
			}
		}

		/// <summary>
		/// <para>The rack which this broker is in.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationRequest WithRack(String? rack)
		{
			Rack = rack;
			return this;
		}

		public BrokerRegistrationResponse Respond()
			=> new BrokerRegistrationResponse(Version);
	}

	public class BrokerRegistrationResponse : Message
	{
		public BrokerRegistrationResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"BrokerRegistrationResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(62);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<BrokerRegistrationResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new BrokerRegistrationResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for BrokerRegistrationResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public BrokerRegistrationResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker's assigned epoch, or -1 if none was assigned.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker's assigned epoch, or -1 if none was assigned.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public BrokerRegistrationResponse WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}
	}

	public class ConsumerProtocolAssignment : Message, IRespond<ProduceResponse>
	{
		public ConsumerProtocolAssignment(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ConsumerProtocolAssignment does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ConsumerProtocolAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ConsumerProtocolAssignment(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.AssignedPartitionsCollection = (await Array<TopicPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Topic);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.UserData = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerProtocolAssignment is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicPartition>.From(AssignedPartitionsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await UserData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<String, TopicPartition> _assignedPartitionsCollection = new Dictionary<String, TopicPartition>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, TopicPartition> AssignedPartitionsCollection 
		{
			get => _assignedPartitionsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"AssignedPartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_assignedPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerProtocolAssignment WithAssignedPartitionsCollection(params Func<TopicPartition, TopicPartition>[] createFields)
		{
			AssignedPartitionsCollection = createFields
				.Select(createField => createField(CreateTopicPartition()))
				.ToDictionary(field => field.Topic);
			return this;
		}

		internal TopicPartition CreateTopicPartition()
		{
			return new TopicPartition(Version);
		}

		public class TopicPartition : ISerialize
		{
			internal TopicPartition(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartition(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartition is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartition WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Int32[] _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartition WithPartitionsCollection(Int32[] partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private Bytes? _userData;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Bytes? UserData 
		{
			get => _userData;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"UserData does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"UserData does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_userData = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerProtocolAssignment WithUserData(Bytes? userData)
		{
			UserData = userData;
			return this;
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class ConsumerProtocolSubscription : Message, IRespond<ProduceResponse>
	{
		public ConsumerProtocolSubscription(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ConsumerProtocolSubscription does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ConsumerProtocolSubscription> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ConsumerProtocolSubscription(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.UserData = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.OwnedPartitionsCollection = (await Array<TopicPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Topic);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ConsumerProtocolSubscription is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await UserData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await Array<TopicPartition>.From(OwnedPartitionsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String[] _topicsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ConsumerProtocolSubscription WithTopicsCollection(String[] topicsCollection)
		{
			TopicsCollection = topicsCollection;
			return this;
		}

		private Bytes? _userData;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Bytes? UserData 
		{
			get => _userData;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"UserData does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"UserData does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_userData = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ConsumerProtocolSubscription WithUserData(Bytes? userData)
		{
			UserData = userData;
			return this;
		}

		private Dictionary<String, TopicPartition> _ownedPartitionsCollection = new Dictionary<String, TopicPartition>();
		/// <summary>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Dictionary<String, TopicPartition> OwnedPartitionsCollection 
		{
			get => _ownedPartitionsCollection;
			set 
			{
				_ownedPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ConsumerProtocolSubscription WithOwnedPartitionsCollection(params Func<TopicPartition, TopicPartition>[] createFields)
		{
			OwnedPartitionsCollection = createFields
				.Select(createField => createField(CreateTopicPartition()))
				.ToDictionary(field => field.Topic);
			return this;
		}

		internal TopicPartition CreateTopicPartition()
		{
			return new TopicPartition(Version);
		}

		public class TopicPartition : ISerialize
		{
			internal TopicPartition(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(1, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartition(version);
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartition is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(1, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(1, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public TopicPartition WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Int32[] _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public Int32[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(1, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 1+</para>
			/// </summary>
			public TopicPartition WithPartitionsCollection(Int32[] partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class ControlledShutdownRequest : Message, IRespond<ControlledShutdownResponse>
	{
		public ControlledShutdownRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ControlledShutdownRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(7);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ControlledShutdownRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ControlledShutdownRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ControlledShutdownRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The id of the broker for which controlled shutdown has been requested.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The id of the broker for which controlled shutdown has been requested.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public ControlledShutdownRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		public ControlledShutdownResponse Respond()
			=> new ControlledShutdownResponse(Version);
	}

	public class ControlledShutdownResponse : Message
	{
		public ControlledShutdownResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ControlledShutdownResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(7);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ControlledShutdownResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ControlledShutdownResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RemainingPartitionsCollection = (await Array<RemainingPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => RemainingPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.TopicName);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ControlledShutdownResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<RemainingPartition>.From(RemainingPartitionsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Dictionary<String, RemainingPartition> _remainingPartitionsCollection = new Dictionary<String, RemainingPartition>();
		/// <summary>
		/// <para>The partitions that the broker still leads.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, RemainingPartition> RemainingPartitionsCollection 
		{
			get => _remainingPartitionsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RemainingPartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_remainingPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions that the broker still leads.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ControlledShutdownResponse WithRemainingPartitionsCollection(params Func<RemainingPartition, RemainingPartition>[] createFields)
		{
			RemainingPartitionsCollection = createFields
				.Select(createField => createField(CreateRemainingPartition()))
				.ToDictionary(field => field.TopicName);
			return this;
		}

		internal RemainingPartition CreateRemainingPartition()
		{
			return new RemainingPartition(Version);
		}

		public class RemainingPartition : ISerialize
		{
			internal RemainingPartition(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PartitionIndex.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<RemainingPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new RemainingPartition(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for RemainingPartition is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public RemainingPartition WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The index of the partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The index of the partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public RemainingPartition WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}
		}
	}

	public class CreateAclsRequest : Message, IRespond<CreateAclsResponse>
	{
		public CreateAclsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreateAclsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(30);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreateAclsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateAclsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.CreationsCollection = await Array<AclCreation>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AclCreation.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateAclsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AclCreation>.From(CreationsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private AclCreation[] _creationsCollection = Array.Empty<AclCreation>();
		/// <summary>
		/// <para>The ACLs that we want to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AclCreation[] CreationsCollection 
		{
			get => _creationsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"CreationsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_creationsCollection = value;
			}
		}

		/// <summary>
		/// <para>The ACLs that we want to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsRequest WithCreationsCollection(params Func<AclCreation, AclCreation>[] createFields)
		{
			CreationsCollection = createFields
				.Select(createField => createField(CreateAclCreation()))
				.ToArray();
			return this;
		}

		internal AclCreation CreateAclCreation()
		{
			return new AclCreation(Version);
		}

		public class AclCreation : ISerialize
		{
			internal AclCreation(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					ResourcePatternType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Principal.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Host.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Operation.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PermissionType.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AclCreation> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AclCreation(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.ResourcePatternType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Principal = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AclCreation is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await ResourcePatternType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Principal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PermissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The type of the resource.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The type of the resource.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Int8 _resourcePatternType = new Int8(3);
			/// <summary>
			/// <para>The pattern type for the ACL.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public Int8 ResourcePatternType 
			{
				get => _resourcePatternType;
				set 
				{
					if (Version.InRange(1, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourcePatternType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
					}

					_resourcePatternType = value;
				}
			}

			/// <summary>
			/// <para>The pattern type for the ACL.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public AclCreation WithResourcePatternType(Int8 resourcePatternType)
			{
				ResourcePatternType = resourcePatternType;
				return this;
			}

			private String _principal = String.Default;
			/// <summary>
			/// <para>The principal for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Principal 
			{
				get => _principal;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Principal does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principal = value;
				}
			}

			/// <summary>
			/// <para>The principal for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithPrincipal(String principal)
			{
				Principal = principal;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The host for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_host = value;
				}
			}

			/// <summary>
			/// <para>The host for the ACL.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int8 _operation = Int8.Default;
			/// <summary>
			/// <para>The operation type for the ACL (read, write, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Operation 
			{
				get => _operation;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Operation does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_operation = value;
				}
			}

			/// <summary>
			/// <para>The operation type for the ACL (read, write, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithOperation(Int8 operation)
			{
				Operation = operation;
				return this;
			}

			private Int8 _permissionType = Int8.Default;
			/// <summary>
			/// <para>The permission type for the ACL (allow, deny, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 PermissionType 
			{
				get => _permissionType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PermissionType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_permissionType = value;
				}
			}

			/// <summary>
			/// <para>The permission type for the ACL (allow, deny, etc.).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreation WithPermissionType(Int8 permissionType)
			{
				PermissionType = permissionType;
				return this;
			}
		}

		public CreateAclsResponse Respond()
			=> new CreateAclsResponse(Version);
	}

	public class CreateAclsResponse : Message
	{
		public CreateAclsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreateAclsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(30);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreateAclsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateAclsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<AclCreationResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AclCreationResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateAclsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AclCreationResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private AclCreationResult[] _resultsCollection = Array.Empty<AclCreationResult>();
		/// <summary>
		/// <para>The results for each ACL creation.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AclCreationResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each ACL creation.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateAclsResponse WithResultsCollection(params Func<AclCreationResult, AclCreationResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateAclCreationResult()))
				.ToArray();
			return this;
		}

		internal AclCreationResult CreateAclCreationResult()
		{
			return new AclCreationResult(Version);
		}

		public class AclCreationResult : ISerialize
		{
			internal AclCreationResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AclCreationResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AclCreationResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AclCreationResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreationResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclCreationResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class CreateDelegationTokenRequest : Message, IRespond<CreateDelegationTokenResponse>
	{
		public CreateDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreateDelegationTokenRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(38);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreateDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateDelegationTokenRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RenewersCollection = await Array<CreatableRenewers>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableRenewers.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MaxLifetimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<CreatableRenewers>.From(RenewersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MaxLifetimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private CreatableRenewers[] _renewersCollection = Array.Empty<CreatableRenewers>();
		/// <summary>
		/// <para>A list of those who are allowed to renew this token before it expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatableRenewers[] RenewersCollection 
		{
			get => _renewersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RenewersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_renewersCollection = value;
			}
		}

		/// <summary>
		/// <para>A list of those who are allowed to renew this token before it expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithRenewersCollection(params Func<CreatableRenewers, CreatableRenewers>[] createFields)
		{
			RenewersCollection = createFields
				.Select(createField => createField(CreateCreatableRenewers()))
				.ToArray();
			return this;
		}

		internal CreatableRenewers CreateCreatableRenewers()
		{
			return new CreatableRenewers(Version);
		}

		public class CreatableRenewers : ISerialize
		{
			internal CreatableRenewers(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					PrincipalType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PrincipalName.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<CreatableRenewers> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatableRenewers(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableRenewers is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _principalType = String.Default;
			/// <summary>
			/// <para>The type of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalType 
			{
				get => _principalType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principalType = value;
				}
			}

			/// <summary>
			/// <para>The type of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableRenewers WithPrincipalType(String principalType)
			{
				PrincipalType = principalType;
				return this;
			}

			private String _principalName = String.Default;
			/// <summary>
			/// <para>The name of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalName 
			{
				get => _principalName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principalName = value;
				}
			}

			/// <summary>
			/// <para>The name of the Kafka principal.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableRenewers WithPrincipalName(String principalName)
			{
				PrincipalName = principalName;
				return this;
			}
		}

		private Int64 _maxLifetimeMs = Int64.Default;
		/// <summary>
		/// <para>The maximum lifetime of the token in milliseconds, or -1 to use the server side default.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 MaxLifetimeMs 
		{
			get => _maxLifetimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MaxLifetimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_maxLifetimeMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum lifetime of the token in milliseconds, or -1 to use the server side default.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenRequest WithMaxLifetimeMs(Int64 maxLifetimeMs)
		{
			MaxLifetimeMs = maxLifetimeMs;
			return this;
		}

		public CreateDelegationTokenResponse Respond()
			=> new CreateDelegationTokenResponse(Version);
	}

	public class CreateDelegationTokenResponse : Message
	{
		public CreateDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreateDelegationTokenResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(38);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreateDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateDelegationTokenResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.IssueTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ExpiryTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MaxTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TokenId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await PrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await PrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await IssueTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ExpiryTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MaxTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TokenId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error, or zero if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error, or zero if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String _principalType = String.Default;
		/// <summary>
		/// <para>The principal type of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String PrincipalType 
		{
			get => _principalType;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"PrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_principalType = value;
			}
		}

		/// <summary>
		/// <para>The principal type of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithPrincipalType(String principalType)
		{
			PrincipalType = principalType;
			return this;
		}

		private String _principalName = String.Default;
		/// <summary>
		/// <para>The name of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String PrincipalName 
		{
			get => _principalName;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"PrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_principalName = value;
			}
		}

		/// <summary>
		/// <para>The name of the token owner.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithPrincipalName(String principalName)
		{
			PrincipalName = principalName;
			return this;
		}

		private Int64 _issueTimestampMs = Int64.Default;
		/// <summary>
		/// <para>When this token was generated.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 IssueTimestampMs 
		{
			get => _issueTimestampMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IssueTimestampMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_issueTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>When this token was generated.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithIssueTimestampMs(Int64 issueTimestampMs)
		{
			IssueTimestampMs = issueTimestampMs;
			return this;
		}

		private Int64 _expiryTimestampMs = Int64.Default;
		/// <summary>
		/// <para>When this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimestampMs 
		{
			get => _expiryTimestampMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ExpiryTimestampMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_expiryTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>When this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithExpiryTimestampMs(Int64 expiryTimestampMs)
		{
			ExpiryTimestampMs = expiryTimestampMs;
			return this;
		}

		private Int64 _maxTimestampMs = Int64.Default;
		/// <summary>
		/// <para>The maximum lifetime of this token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 MaxTimestampMs 
		{
			get => _maxTimestampMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MaxTimestampMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_maxTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum lifetime of this token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithMaxTimestampMs(Int64 maxTimestampMs)
		{
			MaxTimestampMs = maxTimestampMs;
			return this;
		}

		private String _tokenId = String.Default;
		/// <summary>
		/// <para>The token UUID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TokenId 
		{
			get => _tokenId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TokenId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_tokenId = value;
			}
		}

		/// <summary>
		/// <para>The token UUID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithTokenId(String tokenId)
		{
			TokenId = tokenId;
			return this;
		}

		private Bytes _hmac = Bytes.Default;
		/// <summary>
		/// <para>HMAC of the delegation token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Hmac 
		{
			get => _hmac;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Hmac does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_hmac = value;
			}
		}

		/// <summary>
		/// <para>HMAC of the delegation token.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithHmac(Bytes hmac)
		{
			Hmac = hmac;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class CreatePartitionsRequest : Message, IRespond<CreatePartitionsResponse>
	{
		public CreatePartitionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreatePartitionsRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(37);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreatePartitionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreatePartitionsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<CreatePartitionsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatePartitionsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<CreatePartitionsTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ValidateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<String, CreatePartitionsTopic> _topicsCollection = new Dictionary<String, CreatePartitionsTopic>();
		/// <summary>
		/// <para>Each topic that we want to create new partitions inside.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, CreatePartitionsTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to create new partitions inside.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithTopicsCollection(params Func<CreatePartitionsTopic, CreatePartitionsTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateCreatePartitionsTopic()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal CreatePartitionsTopic CreateCreatePartitionsTopic()
		{
			return new CreatePartitionsTopic(Version);
		}

		public class CreatePartitionsTopic : ISerialize
		{
			internal CreatePartitionsTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Count.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					NullableArray<CreatePartitionsAssignment>.From(AssignmentsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<CreatePartitionsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatePartitionsTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Count = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.AssignmentsCollection = await NullableArray<CreatePartitionsAssignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatePartitionsAssignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Count.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await NullableArray<CreatePartitionsAssignment>.From(AssignmentsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32 _count = Int32.Default;
			/// <summary>
			/// <para>The new partition count.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Count 
			{
				get => _count;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Count does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_count = value;
				}
			}

			/// <summary>
			/// <para>The new partition count.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithCount(Int32 count)
			{
				Count = count;
				return this;
			}

			private CreatePartitionsAssignment[]? _assignmentsCollection = Array.Empty<CreatePartitionsAssignment>();
			/// <summary>
			/// <para>The new partition assignments.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsAssignment[]? AssignmentsCollection 
			{
				get => _assignmentsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"AssignmentsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"AssignmentsCollection does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_assignmentsCollection = value;
				}
			}

			/// <summary>
			/// <para>The new partition assignments.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopic WithAssignmentsCollection(params Func<CreatePartitionsAssignment, CreatePartitionsAssignment>[] createFields)
			{
				AssignmentsCollection = createFields
					.Select(createField => createField(CreateCreatePartitionsAssignment()))
					.ToArray();
				return this;
			}

			internal CreatePartitionsAssignment CreateCreatePartitionsAssignment()
			{
				return new CreatePartitionsAssignment(Version);
			}

			public class CreatePartitionsAssignment : ISerialize
			{
				internal CreatePartitionsAssignment(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(BrokerIdsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<CreatePartitionsAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreatePartitionsAssignment(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.BrokerIdsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsAssignment is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(BrokerIdsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32[] _brokerIdsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The assigned broker IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] BrokerIdsCollection 
				{
					get => _brokerIdsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"BrokerIdsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_brokerIdsCollection = value;
					}
				}

				/// <summary>
				/// <para>The assigned broker IDs.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreatePartitionsAssignment WithBrokerIdsCollection(Int32[] brokerIdsCollection)
				{
					BrokerIdsCollection = brokerIdsCollection;
					return this;
				}
			}
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>The time in ms to wait for the partitions to be created.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the partitions to be created.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>If true, then validate the request, but don't actually increase the number of partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>If true, then validate the request, but don't actually increase the number of partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public CreatePartitionsResponse Respond()
			=> new CreatePartitionsResponse(Version);
	}

	public class CreatePartitionsResponse : Message
	{
		public CreatePartitionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreatePartitionsResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(37);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreatePartitionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreatePartitionsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<CreatePartitionsTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatePartitionsTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<CreatePartitionsTopicResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private CreatePartitionsTopicResult[] _resultsCollection = Array.Empty<CreatePartitionsTopicResult>();
		/// <summary>
		/// <para>The partition creation results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsTopicResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partition creation results for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreatePartitionsResponse WithResultsCollection(params Func<CreatePartitionsTopicResult, CreatePartitionsTopicResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateCreatePartitionsTopicResult()))
				.ToArray();
			return this;
		}

		internal CreatePartitionsTopicResult CreateCreatePartitionsTopicResult()
		{
			return new CreatePartitionsTopicResult(Version);
		}

		public class CreatePartitionsTopicResult : ISerialize
		{
			internal CreatePartitionsTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<CreatePartitionsTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatePartitionsTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatePartitionsTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The result error, or zero if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatePartitionsTopicResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The result message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public CreatePartitionsTopicResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class CreateTopicsRequest : Message, IRespond<CreateTopicsResponse>
	{
		public CreateTopicsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreateTopicsRequest does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(5, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(19);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreateTopicsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateTopicsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<CreatableTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateTopicsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<CreatableTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await ValidateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<String, CreatableTopic> _topicsCollection = new Dictionary<String, CreatableTopic>();
		/// <summary>
		/// <para>The topics to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, CreatableTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateTopicsRequest WithTopicsCollection(params Func<CreatableTopic, CreatableTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateCreatableTopic()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal CreatableTopic CreateCreatableTopic()
		{
			return new CreatableTopic(Version);
		}

		public class CreatableTopic : ISerialize
		{
			internal CreatableTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(5, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					NumPartitions.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ReplicationFactor.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<CreatableReplicaAssignment>.From(AssignmentsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<CreateableTopicConfig>.From(ConfigsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<CreatableTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatableTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.NumPartitions = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ReplicationFactor = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.AssignmentsCollection = (await Array<CreatableReplicaAssignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableReplicaAssignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.PartitionIndex);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ConfigsCollection = (await Array<CreateableTopicConfig>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreateableTopicConfig.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await NumPartitions.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ReplicationFactor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<CreatableReplicaAssignment>.From(AssignmentsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<CreateableTopicConfig>.From(ConfigsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32 _numPartitions = Int32.Default;
			/// <summary>
			/// <para>The number of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 NumPartitions 
			{
				get => _numPartitions;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"NumPartitions does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_numPartitions = value;
				}
			}

			/// <summary>
			/// <para>The number of partitions to create in the topic, or -1 if we are either specifying a manual partition assignment or using the default partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithNumPartitions(Int32 numPartitions)
			{
				NumPartitions = numPartitions;
				return this;
			}

			private Int16 _replicationFactor = Int16.Default;
			/// <summary>
			/// <para>The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ReplicationFactor 
			{
				get => _replicationFactor;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ReplicationFactor does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_replicationFactor = value;
				}
			}

			/// <summary>
			/// <para>The number of replicas to create for each partition in the topic, or -1 if we are either specifying a manual partition assignment or using the default replication factor.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithReplicationFactor(Int16 replicationFactor)
			{
				ReplicationFactor = replicationFactor;
				return this;
			}

			private Dictionary<Int32, CreatableReplicaAssignment> _assignmentsCollection = new Dictionary<Int32, CreatableReplicaAssignment>();
			/// <summary>
			/// <para>The manual partition assignment, or the empty array if we are using automatic assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<Int32, CreatableReplicaAssignment> AssignmentsCollection 
			{
				get => _assignmentsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"AssignmentsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_assignmentsCollection = value;
				}
			}

			/// <summary>
			/// <para>The manual partition assignment, or the empty array if we are using automatic assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithAssignmentsCollection(params Func<CreatableReplicaAssignment, CreatableReplicaAssignment>[] createFields)
			{
				AssignmentsCollection = createFields
					.Select(createField => createField(CreateCreatableReplicaAssignment()))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			internal CreatableReplicaAssignment CreateCreatableReplicaAssignment()
			{
				return new CreatableReplicaAssignment(Version);
			}

			public class CreatableReplicaAssignment : ISerialize
			{
				internal CreatableReplicaAssignment(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(5, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(BrokerIdsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<CreatableReplicaAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreatableReplicaAssignment(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.BrokerIdsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableReplicaAssignment is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(BrokerIdsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreatableReplicaAssignment WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32[] _brokerIdsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The brokers to place the partition on.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] BrokerIdsCollection 
				{
					get => _brokerIdsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"BrokerIdsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_brokerIdsCollection = value;
					}
				}

				/// <summary>
				/// <para>The brokers to place the partition on.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreatableReplicaAssignment WithBrokerIdsCollection(Int32[] brokerIdsCollection)
				{
					BrokerIdsCollection = brokerIdsCollection;
					return this;
				}
			}

			private Dictionary<String, CreateableTopicConfig> _configsCollection = new Dictionary<String, CreateableTopicConfig>();
			/// <summary>
			/// <para>The custom topic configurations to set.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<String, CreateableTopicConfig> ConfigsCollection 
			{
				get => _configsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ConfigsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>The custom topic configurations to set.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopic WithConfigsCollection(params Func<CreateableTopicConfig, CreateableTopicConfig>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(CreateCreateableTopicConfig()))
					.ToDictionary(field => field.Name);
				return this;
			}

			internal CreateableTopicConfig CreateCreateableTopicConfig()
			{
				return new CreateableTopicConfig(Version);
			}

			public class CreateableTopicConfig : ISerialize
			{
				internal CreateableTopicConfig(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(5, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<CreateableTopicConfig> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreateableTopicConfig(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateableTopicConfig is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreateableTopicConfig WithName(String name)
				{
					Name = name;
					return this;
				}

				private String? _value;
				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CreateableTopicConfig WithValue(String? value)
				{
					Value = value;
					return this;
				}
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public CreateTopicsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Boolean _validateOnly = new Boolean(false);
		/// <summary>
		/// <para>If true, check that the topics can be created as specified, but don't create anything.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			set 
			{
				if (Version.InRange(1, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
				}

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>If true, check that the topics can be created as specified, but don't create anything.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public CreateTopicsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public CreateTopicsResponse Respond()
			=> new CreateTopicsResponse(Version);
	}

	public class CreateTopicsResponse : Message
	{
		public CreateTopicsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"CreateTopicsResponse does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(5, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(19);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<CreateTopicsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new CreateTopicsResponse(version);
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<CreatableTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for CreateTopicsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(2, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<CreatableTopicResult>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public CreateTopicsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, CreatableTopicResult> _topicsCollection = new Dictionary<String, CreatableTopicResult>();
		/// <summary>
		/// <para>Results for each topic we tried to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, CreatableTopicResult> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Results for each topic we tried to create.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public CreateTopicsResponse WithTopicsCollection(params Func<CreatableTopicResult, CreatableTopicResult>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateCreatableTopicResult()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal CreatableTopicResult CreateCreatableTopicResult()
		{
			return new CreatableTopicResult(Version);
		}

		public class CreatableTopicResult : ISerialize
		{
			internal CreatableTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(5, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(7, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					TopicConfigErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					NumPartitions.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					ReplicationFactor.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					NullableArray<CreatableTopicConfigs>.From(ConfigsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<CreatableTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new CreatableTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(7, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.NumPartitions = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.ReplicationFactor = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.ConfigsCollection = await NullableArray<CreatableTopicConfigs>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CreatableTopicConfigs.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							case 0:
								if (instance.Version.InRange(5, 2147483647)) 
								{
									instance.TopicConfigErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
								}
								else
									throw new InvalidOperationException($"Field TopicConfigErrorCode is not supported for version {instance.Version}");
								break;
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(7, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await TopicConfigErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await NumPartitions.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await ReplicationFactor.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await NullableArray<CreatableTopicConfigs>.From(ConfigsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public CreatableTopicResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CreatableTopicResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public CreatableTopicResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int16 _topicConfigErrorCode = Int16.Default;
			/// <summary>
			/// <para>Optional topic config error returned if configs are not returned in the response.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Int16 TopicConfigErrorCode 
			{
				get => _topicConfigErrorCode;
				set 
				{
					_topicConfigErrorCode = value;
				}
			}

			/// <summary>
			/// <para>Optional topic config error returned if configs are not returned in the response.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public CreatableTopicResult WithTopicConfigErrorCode(Int16 topicConfigErrorCode)
			{
				TopicConfigErrorCode = topicConfigErrorCode;
				return this;
			}

			private Int32 _numPartitions = new Int32(-1);
			/// <summary>
			/// <para>Number of partitions of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int32 NumPartitions 
			{
				get => _numPartitions;
				set 
				{
					_numPartitions = value;
				}
			}

			/// <summary>
			/// <para>Number of partitions of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public CreatableTopicResult WithNumPartitions(Int32 numPartitions)
			{
				NumPartitions = numPartitions;
				return this;
			}

			private Int16 _replicationFactor = new Int16(-1);
			/// <summary>
			/// <para>Replication factor of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public Int16 ReplicationFactor 
			{
				get => _replicationFactor;
				set 
				{
					_replicationFactor = value;
				}
			}

			/// <summary>
			/// <para>Replication factor of the topic.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: -1</para>
			/// </summary>
			public CreatableTopicResult WithReplicationFactor(Int16 replicationFactor)
			{
				ReplicationFactor = replicationFactor;
				return this;
			}

			private CreatableTopicConfigs[]? _configsCollection = Array.Empty<CreatableTopicConfigs>();
			/// <summary>
			/// <para>Configuration of the topic.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public CreatableTopicConfigs[]? ConfigsCollection 
			{
				get => _configsCollection;
				set 
				{
					if (Version.InRange(5, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ConfigsCollection does not support null for version {Version}. Supported versions for null value: 5+");
					}

					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>Configuration of the topic.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public CreatableTopicResult WithConfigsCollection(params Func<CreatableTopicConfigs, CreatableTopicConfigs>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(CreateCreatableTopicConfigs()))
					.ToArray();
				return this;
			}

			internal CreatableTopicConfigs CreateCreatableTopicConfigs()
			{
				return new CreatableTopicConfigs(Version);
			}

			public class CreatableTopicConfigs : ISerialize
			{
				internal CreatableTopicConfigs(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(5, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(5, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						ReadOnly.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						ConfigSource.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						IsSensitive.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<CreatableTopicConfigs> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CreatableTopicConfigs(version);
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.ReadOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.ConfigSource = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.IsSensitive = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CreatableTopicConfigs is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(5, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await ReadOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await ConfigSource.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await IsSensitive.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(5, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithName(String name)
				{
					Name = name;
					return this;
				}

				private String? _value;
				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(5, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
						}

						if (Version.InRange(5, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 5+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithValue(String? value)
				{
					Value = value;
					return this;
				}

				private Boolean _readOnly = Boolean.Default;
				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public Boolean ReadOnly 
				{
					get => _readOnly;
					set 
					{
						if (Version.InRange(5, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ReadOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
						}

						_readOnly = value;
					}
				}

				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithReadOnly(Boolean readOnly)
				{
					ReadOnly = readOnly;
					return this;
				}

				private Int8 _configSource = new Int8(-1);
				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int8 ConfigSource 
				{
					get => _configSource;
					set 
					{
						_configSource = value;
					}
				}

				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public CreatableTopicConfigs WithConfigSource(Int8 configSource)
				{
					ConfigSource = configSource;
					return this;
				}

				private Boolean _isSensitive = Boolean.Default;
				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public Boolean IsSensitive 
				{
					get => _isSensitive;
					set 
					{
						if (Version.InRange(5, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"IsSensitive does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
						}

						_isSensitive = value;
					}
				}

				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public CreatableTopicConfigs WithIsSensitive(Boolean isSensitive)
				{
					IsSensitive = isSensitive;
					return this;
				}
			}
		}
	}

	public class DefaultPrincipalData : Message, IRespond<ProduceResponse>
	{
		public DefaultPrincipalData(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DefaultPrincipalData does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DefaultPrincipalData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DefaultPrincipalData(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Type = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TokenAuthenticated = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DefaultPrincipalData is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Type.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TokenAuthenticated.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _type = String.Default;
		/// <summary>
		/// <para>The principal type</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Type 
		{
			get => _type;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Type does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_type = value;
			}
		}

		/// <summary>
		/// <para>The principal type</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DefaultPrincipalData WithType(String type)
		{
			Type = type;
			return this;
		}

		private String _name = String.Default;
		/// <summary>
		/// <para>The principal name</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Name 
		{
			get => _name;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_name = value;
			}
		}

		/// <summary>
		/// <para>The principal name</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DefaultPrincipalData WithName(String name)
		{
			Name = name;
			return this;
		}

		private Boolean _tokenAuthenticated = Boolean.Default;
		/// <summary>
		/// <para>Whether the principal was authenticated by a delegation token on the forwarding broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean TokenAuthenticated 
		{
			get => _tokenAuthenticated;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TokenAuthenticated does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_tokenAuthenticated = value;
			}
		}

		/// <summary>
		/// <para>Whether the principal was authenticated by a delegation token on the forwarding broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DefaultPrincipalData WithTokenAuthenticated(Boolean tokenAuthenticated)
		{
			TokenAuthenticated = tokenAuthenticated;
			return this;
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class DeleteAclsRequest : Message, IRespond<DeleteAclsResponse>
	{
		public DeleteAclsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteAclsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(31);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteAclsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteAclsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.FiltersCollection = await Array<DeleteAclsFilter>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteAclsFilter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DeleteAclsFilter>.From(FiltersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private DeleteAclsFilter[] _filtersCollection = Array.Empty<DeleteAclsFilter>();
		/// <summary>
		/// <para>The filters to use when deleting ACLs.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsFilter[] FiltersCollection 
		{
			get => _filtersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"FiltersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_filtersCollection = value;
			}
		}

		/// <summary>
		/// <para>The filters to use when deleting ACLs.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsRequest WithFiltersCollection(params Func<DeleteAclsFilter, DeleteAclsFilter>[] createFields)
		{
			FiltersCollection = createFields
				.Select(createField => createField(CreateDeleteAclsFilter()))
				.ToArray();
			return this;
		}

		internal DeleteAclsFilter CreateDeleteAclsFilter()
		{
			return new DeleteAclsFilter(Version);
		}

		public class DeleteAclsFilter : ISerialize
		{
			internal DeleteAclsFilter(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ResourceTypeFilter.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceNameFilter.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					PatternTypeFilter.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PrincipalFilter.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					HostFilter.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Operation.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PermissionType.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeleteAclsFilter> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteAclsFilter(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceNameFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.PatternTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.HostFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsFilter is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceNameFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await PatternTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await HostFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PermissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int8 _resourceTypeFilter = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceTypeFilter 
			{
				get => _resourceTypeFilter;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceTypeFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceTypeFilter = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithResourceTypeFilter(Int8 resourceTypeFilter)
			{
				ResourceTypeFilter = resourceTypeFilter;
				return this;
			}

			private String? _resourceNameFilter;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ResourceNameFilter 
			{
				get => _resourceNameFilter;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceNameFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ResourceNameFilter does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_resourceNameFilter = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithResourceNameFilter(String? resourceNameFilter)
			{
				ResourceNameFilter = resourceNameFilter;
				return this;
			}

			private Int8 _patternTypeFilter = new Int8(3);
			/// <summary>
			/// <para>The pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public Int8 PatternTypeFilter 
			{
				get => _patternTypeFilter;
				set 
				{
					if (Version.InRange(1, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PatternTypeFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
					}

					_patternTypeFilter = value;
				}
			}

			/// <summary>
			/// <para>The pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public DeleteAclsFilter WithPatternTypeFilter(Int8 patternTypeFilter)
			{
				PatternTypeFilter = patternTypeFilter;
				return this;
			}

			private String? _principalFilter;
			/// <summary>
			/// <para>The principal filter, or null to accept all principals.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? PrincipalFilter 
			{
				get => _principalFilter;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"PrincipalFilter does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_principalFilter = value;
				}
			}

			/// <summary>
			/// <para>The principal filter, or null to accept all principals.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithPrincipalFilter(String? principalFilter)
			{
				PrincipalFilter = principalFilter;
				return this;
			}

			private String? _hostFilter;
			/// <summary>
			/// <para>The host filter, or null to accept all hosts.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? HostFilter 
			{
				get => _hostFilter;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"HostFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"HostFilter does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_hostFilter = value;
				}
			}

			/// <summary>
			/// <para>The host filter, or null to accept all hosts.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithHostFilter(String? hostFilter)
			{
				HostFilter = hostFilter;
				return this;
			}

			private Int8 _operation = Int8.Default;
			/// <summary>
			/// <para>The ACL operation.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 Operation 
			{
				get => _operation;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Operation does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_operation = value;
				}
			}

			/// <summary>
			/// <para>The ACL operation.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithOperation(Int8 operation)
			{
				Operation = operation;
				return this;
			}

			private Int8 _permissionType = Int8.Default;
			/// <summary>
			/// <para>The permission type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 PermissionType 
			{
				get => _permissionType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PermissionType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_permissionType = value;
				}
			}

			/// <summary>
			/// <para>The permission type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilter WithPermissionType(Int8 permissionType)
			{
				PermissionType = permissionType;
				return this;
			}
		}

		public DeleteAclsResponse Respond()
			=> new DeleteAclsResponse(Version);
	}

	public class DeleteAclsResponse : Message
	{
		public DeleteAclsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteAclsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(31);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteAclsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteAclsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.FilterResultsCollection = await Array<DeleteAclsFilterResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteAclsFilterResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DeleteAclsFilterResult>.From(FilterResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private DeleteAclsFilterResult[] _filterResultsCollection = Array.Empty<DeleteAclsFilterResult>();
		/// <summary>
		/// <para>The results for each filter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsFilterResult[] FilterResultsCollection 
		{
			get => _filterResultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"FilterResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_filterResultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each filter.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteAclsResponse WithFilterResultsCollection(params Func<DeleteAclsFilterResult, DeleteAclsFilterResult>[] createFields)
		{
			FilterResultsCollection = createFields
				.Select(createField => createField(CreateDeleteAclsFilterResult()))
				.ToArray();
			return this;
		}

		internal DeleteAclsFilterResult CreateDeleteAclsFilterResult()
		{
			return new DeleteAclsFilterResult(Version);
		}

		public class DeleteAclsFilterResult : ISerialize
		{
			internal DeleteAclsFilterResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DeleteAclsMatchingAcl>.From(MatchingAclsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeleteAclsFilterResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteAclsFilterResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MatchingAclsCollection = await Array<DeleteAclsMatchingAcl>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteAclsMatchingAcl.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsFilterResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DeleteAclsMatchingAcl>.From(MatchingAclsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, or null if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if the filter succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private DeleteAclsMatchingAcl[] _matchingAclsCollection = Array.Empty<DeleteAclsMatchingAcl>();
			/// <summary>
			/// <para>The ACLs which matched this filter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsMatchingAcl[] MatchingAclsCollection 
			{
				get => _matchingAclsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MatchingAclsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_matchingAclsCollection = value;
				}
			}

			/// <summary>
			/// <para>The ACLs which matched this filter.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteAclsFilterResult WithMatchingAclsCollection(params Func<DeleteAclsMatchingAcl, DeleteAclsMatchingAcl>[] createFields)
			{
				MatchingAclsCollection = createFields
					.Select(createField => createField(CreateDeleteAclsMatchingAcl()))
					.ToArray();
				return this;
			}

			internal DeleteAclsMatchingAcl CreateDeleteAclsMatchingAcl()
			{
				return new DeleteAclsMatchingAcl(Version);
			}

			public class DeleteAclsMatchingAcl : ISerialize
			{
				internal DeleteAclsMatchingAcl(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorMessage.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ResourceType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ResourceName.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						PatternType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Principal.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Host.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Operation.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						PermissionType.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DeleteAclsMatchingAcl> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DeleteAclsMatchingAcl(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.PatternType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Principal = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteAclsMatchingAcl is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await PatternType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Principal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await PermissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private String? _errorMessage;
				/// <summary>
				/// <para>The deletion error message, or null if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The deletion error message, or null if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private Int8 _resourceType = Int8.Default;
				/// <summary>
				/// <para>The ACL resource type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 ResourceType 
				{
					get => _resourceType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_resourceType = value;
					}
				}

				/// <summary>
				/// <para>The ACL resource type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithResourceType(Int8 resourceType)
				{
					ResourceType = resourceType;
					return this;
				}

				private String _resourceName = String.Default;
				/// <summary>
				/// <para>The ACL resource name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ResourceName 
				{
					get => _resourceName;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_resourceName = value;
					}
				}

				/// <summary>
				/// <para>The ACL resource name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithResourceName(String resourceName)
				{
					ResourceName = resourceName;
					return this;
				}

				private Int8 _patternType = new Int8(3);
				/// <summary>
				/// <para>The ACL resource pattern type.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 3</para>
				/// </summary>
				public Int8 PatternType 
				{
					get => _patternType;
					set 
					{
						if (Version.InRange(1, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PatternType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
						}

						_patternType = value;
					}
				}

				/// <summary>
				/// <para>The ACL resource pattern type.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: 3</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithPatternType(Int8 patternType)
				{
					PatternType = patternType;
					return this;
				}

				private String _principal = String.Default;
				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Principal 
				{
					get => _principal;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Principal does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_principal = value;
					}
				}

				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithPrincipal(String principal)
				{
					Principal = principal;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_host = value;
					}
				}

				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithHost(String host)
				{
					Host = host;
					return this;
				}

				private Int8 _operation = Int8.Default;
				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 Operation 
				{
					get => _operation;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Operation does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_operation = value;
					}
				}

				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithOperation(Int8 operation)
				{
					Operation = operation;
					return this;
				}

				private Int8 _permissionType = Int8.Default;
				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 PermissionType 
				{
					get => _permissionType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PermissionType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_permissionType = value;
					}
				}

				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteAclsMatchingAcl WithPermissionType(Int8 permissionType)
				{
					PermissionType = permissionType;
					return this;
				}
			}
		}
	}

	public class DeleteGroupsRequest : Message, IRespond<DeleteGroupsResponse>
	{
		public DeleteGroupsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteGroupsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(42);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteGroupsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteGroupsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupsNamesCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteGroupsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(GroupsNamesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String[] _groupsNamesCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The group names to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] GroupsNamesCollection 
		{
			get => _groupsNamesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupsNamesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupsNamesCollection = value;
			}
		}

		/// <summary>
		/// <para>The group names to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsRequest WithGroupsNamesCollection(String[] groupsNamesCollection)
		{
			GroupsNamesCollection = groupsNamesCollection;
			return this;
		}

		public DeleteGroupsResponse Respond()
			=> new DeleteGroupsResponse(Version);
	}

	public class DeleteGroupsResponse : Message
	{
		public DeleteGroupsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteGroupsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(42);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteGroupsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteGroupsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = (await Array<DeletableGroupResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeletableGroupResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.GroupId);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteGroupsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DeletableGroupResult>.From(ResultsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, DeletableGroupResult> _resultsCollection = new Dictionary<String, DeletableGroupResult>();
		/// <summary>
		/// <para>The deletion results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, DeletableGroupResult> ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The deletion results</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteGroupsResponse WithResultsCollection(params Func<DeletableGroupResult, DeletableGroupResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateDeletableGroupResult()))
				.ToDictionary(field => field.GroupId);
			return this;
		}

		internal DeletableGroupResult CreateDeletableGroupResult()
		{
			return new DeletableGroupResult(Version);
		}

		public class DeletableGroupResult : ISerialize
		{
			internal DeletableGroupResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					GroupId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeletableGroupResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeletableGroupResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeletableGroupResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group id</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group id</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableGroupResult WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableGroupResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class DeleteRecordsRequest : Message, IRespond<DeleteRecordsResponse>
	{
		public DeleteRecordsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteRecordsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(21);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteRecordsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteRecordsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<DeleteRecordsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DeleteRecordsTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private DeleteRecordsTopic[] _topicsCollection = Array.Empty<DeleteRecordsTopic>();
		/// <summary>
		/// <para>Each topic that we want to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsRequest WithTopicsCollection(params Func<DeleteRecordsTopic, DeleteRecordsTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateDeleteRecordsTopic()))
				.ToArray();
			return this;
		}

		internal DeleteRecordsTopic CreateDeleteRecordsTopic()
		{
			return new DeleteRecordsTopic(Version);
		}

		public class DeleteRecordsTopic : ISerialize
		{
			internal DeleteRecordsTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DeleteRecordsPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeleteRecordsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteRecordsTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<DeleteRecordsPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DeleteRecordsPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private DeleteRecordsPartition[] _partitionsCollection = Array.Empty<DeleteRecordsPartition>();
			/// <summary>
			/// <para>Each partition that we want to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition that we want to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopic WithPartitionsCollection(params Func<DeleteRecordsPartition, DeleteRecordsPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateDeleteRecordsPartition()))
					.ToArray();
				return this;
			}

			internal DeleteRecordsPartition CreateDeleteRecordsPartition()
			{
				return new DeleteRecordsPartition(Version);
			}

			public class DeleteRecordsPartition : ISerialize
			{
				internal DeleteRecordsPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Offset.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DeleteRecordsPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DeleteRecordsPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Offset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Offset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _offset = Int64.Default;
				/// <summary>
				/// <para>The deletion offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Offset 
				{
					get => _offset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Offset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_offset = value;
					}
				}

				/// <summary>
				/// <para>The deletion offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartition WithOffset(Int64 offset)
				{
					Offset = offset;
					return this;
				}
			}
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>How long to wait for the deletion to complete, in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>How long to wait for the deletion to complete, in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		public DeleteRecordsResponse Respond()
			=> new DeleteRecordsResponse(Version);
	}

	public class DeleteRecordsResponse : Message
	{
		public DeleteRecordsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteRecordsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(21);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteRecordsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteRecordsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<DeleteRecordsTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DeleteRecordsTopicResult>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, DeleteRecordsTopicResult> _topicsCollection = new Dictionary<String, DeleteRecordsTopicResult>();
		/// <summary>
		/// <para>Each topic that we wanted to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, DeleteRecordsTopicResult> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we wanted to delete records from.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteRecordsResponse WithTopicsCollection(params Func<DeleteRecordsTopicResult, DeleteRecordsTopicResult>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateDeleteRecordsTopicResult()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal DeleteRecordsTopicResult CreateDeleteRecordsTopicResult()
		{
			return new DeleteRecordsTopicResult(Version);
		}

		public class DeleteRecordsTopicResult : ISerialize
		{
			internal DeleteRecordsTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DeleteRecordsPartitionResult>.From(PartitionsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeleteRecordsTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteRecordsTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = (await Array<DeleteRecordsPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteRecordsPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.PartitionIndex);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DeleteRecordsPartitionResult>.From(PartitionsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopicResult WithName(String name)
			{
				Name = name;
				return this;
			}

			private Dictionary<Int32, DeleteRecordsPartitionResult> _partitionsCollection = new Dictionary<Int32, DeleteRecordsPartitionResult>();
			/// <summary>
			/// <para>Each partition that we wanted to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<Int32, DeleteRecordsPartitionResult> PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition that we wanted to delete records from.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeleteRecordsTopicResult WithPartitionsCollection(params Func<DeleteRecordsPartitionResult, DeleteRecordsPartitionResult>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateDeleteRecordsPartitionResult()))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			internal DeleteRecordsPartitionResult CreateDeleteRecordsPartitionResult()
			{
				return new DeleteRecordsPartitionResult(Version);
			}

			public class DeleteRecordsPartitionResult : ISerialize
			{
				internal DeleteRecordsPartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LowWatermark.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DeleteRecordsPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DeleteRecordsPartitionResult(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LowWatermark = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteRecordsPartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LowWatermark.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartitionResult WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _lowWatermark = Int64.Default;
				/// <summary>
				/// <para>The partition low water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 LowWatermark 
				{
					get => _lowWatermark;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LowWatermark does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_lowWatermark = value;
					}
				}

				/// <summary>
				/// <para>The partition low water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartitionResult WithLowWatermark(Int64 lowWatermark)
				{
					LowWatermark = lowWatermark;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The deletion error code, or 0 if the deletion succeeded.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DeleteRecordsPartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class DeleteTopicsRequest : Message, IRespond<DeleteTopicsResponse>
	{
		public DeleteTopicsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteTopicsRequest does not support version {version}. Valid versions are: 0-6");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(20);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteTopicsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteTopicsRequest(version);
			if (instance.Version.InRange(6, 2147483647)) 
			{
				instance.TopicsCollection = await Array<DeleteTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeleteTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 5)) 
			{
				instance.TopicNamesCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteTopicsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(6, 2147483647)) 
			{
				await Array<DeleteTopicState>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 5)) 
			{
				await Array<String>.From(TopicNamesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private DeleteTopicState[] _topicsCollection = Array.Empty<DeleteTopicState>();
		/// <summary>
		/// <para>The name or topic ID of the topic</para>
		/// <para>Versions: 6+</para>
		/// </summary>
		public DeleteTopicState[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(6, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The name or topic ID of the topic</para>
		/// <para>Versions: 6+</para>
		/// </summary>
		public DeleteTopicsRequest WithTopicsCollection(params Func<DeleteTopicState, DeleteTopicState>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateDeleteTopicState()))
				.ToArray();
			return this;
		}

		internal DeleteTopicState CreateDeleteTopicState()
		{
			return new DeleteTopicState(Version);
		}

		public class DeleteTopicState : ISerialize
		{
			internal DeleteTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(6, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(6, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeleteTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeleteTopicState(version);
				if (instance.Version.InRange(6, 2147483647)) 
				{
					instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(6, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteTopicState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(6, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(6, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String? _name;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 6+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(6, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");
					}

					if (Version.InRange(6, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 6+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 6+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DeleteTopicState WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					if (Version.InRange(6, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicId does not support version {Version} and has been defined as not ignorable. Supported versions: 6+");
					}

					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public DeleteTopicState WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}
		}

		private String[] _topicNamesCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The names of the topics to delete</para>
		/// <para>Versions: 0-5</para>
		/// </summary>
		public String[] TopicNamesCollection 
		{
			get => _topicNamesCollection;
			set 
			{
				_topicNamesCollection = value;
			}
		}

		/// <summary>
		/// <para>The names of the topics to delete</para>
		/// <para>Versions: 0-5</para>
		/// </summary>
		public DeleteTopicsRequest WithTopicNamesCollection(String[] topicNamesCollection)
		{
			TopicNamesCollection = topicNamesCollection;
			return this;
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>The length of time in milliseconds to wait for the deletions to complete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The length of time in milliseconds to wait for the deletions to complete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteTopicsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		public DeleteTopicsResponse Respond()
			=> new DeleteTopicsResponse(Version);
	}

	public class DeleteTopicsResponse : Message
	{
		public DeleteTopicsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DeleteTopicsResponse does not support version {version}. Valid versions are: 0-6");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(20);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(6);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DeleteTopicsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DeleteTopicsResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponsesCollection = (await Array<DeletableTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DeletableTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DeleteTopicsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DeletableTopicResult>.From(ResponsesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public DeleteTopicsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String?, DeletableTopicResult> _responsesCollection = new Dictionary<String?, DeletableTopicResult>();
		/// <summary>
		/// <para>The results for each topic we tried to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String?, DeletableTopicResult> ResponsesCollection 
		{
			get => _responsesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each topic we tried to delete.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DeleteTopicsResponse WithResponsesCollection(params Func<DeletableTopicResult, DeletableTopicResult>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(CreateDeletableTopicResult()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal DeletableTopicResult CreateDeletableTopicResult()
		{
			return new DeletableTopicResult(Version);
		}

		public class DeletableTopicResult : ISerialize
		{
			internal DeletableTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(6, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DeletableTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DeletableTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(6, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DeletableTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(6, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String? _name;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(6, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 6+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableTopicResult WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>the unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>the unique topic ID</para>
			/// <para>Versions: 6+</para>
			/// </summary>
			public DeletableTopicResult WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The deletion error, or 0 if the deletion succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DeletableTopicResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(5, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 5+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DeletableTopicResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class DescribeAclsRequest : Message, IRespond<DescribeAclsResponse>
	{
		public DescribeAclsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeAclsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(29);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeAclsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeAclsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResourceTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResourceNameFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.PatternTypeFilter = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.PrincipalFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.HostFilter = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeAclsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ResourceTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ResourceNameFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await PatternTypeFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await PrincipalFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await HostFilter.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await PermissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int8 _resourceTypeFilter = Int8.Default;
		/// <summary>
		/// <para>The resource type.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 ResourceTypeFilter 
		{
			get => _resourceTypeFilter;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResourceTypeFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resourceTypeFilter = value;
			}
		}

		/// <summary>
		/// <para>The resource type.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithResourceTypeFilter(Int8 resourceTypeFilter)
		{
			ResourceTypeFilter = resourceTypeFilter;
			return this;
		}

		private String? _resourceNameFilter;
		/// <summary>
		/// <para>The resource name, or null to match any resource name.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ResourceNameFilter 
		{
			get => _resourceNameFilter;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResourceNameFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ResourceNameFilter does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_resourceNameFilter = value;
			}
		}

		/// <summary>
		/// <para>The resource name, or null to match any resource name.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithResourceNameFilter(String? resourceNameFilter)
		{
			ResourceNameFilter = resourceNameFilter;
			return this;
		}

		private Int8 _patternTypeFilter = new Int8(3);
		/// <summary>
		/// <para>The resource pattern to match.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 3</para>
		/// </summary>
		public Int8 PatternTypeFilter 
		{
			get => _patternTypeFilter;
			set 
			{
				if (Version.InRange(1, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"PatternTypeFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
				}

				_patternTypeFilter = value;
			}
		}

		/// <summary>
		/// <para>The resource pattern to match.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 3</para>
		/// </summary>
		public DescribeAclsRequest WithPatternTypeFilter(Int8 patternTypeFilter)
		{
			PatternTypeFilter = patternTypeFilter;
			return this;
		}

		private String? _principalFilter;
		/// <summary>
		/// <para>The principal to match, or null to match any principal.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? PrincipalFilter 
		{
			get => _principalFilter;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"PrincipalFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"PrincipalFilter does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_principalFilter = value;
			}
		}

		/// <summary>
		/// <para>The principal to match, or null to match any principal.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithPrincipalFilter(String? principalFilter)
		{
			PrincipalFilter = principalFilter;
			return this;
		}

		private String? _hostFilter;
		/// <summary>
		/// <para>The host to match, or null to match any host.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? HostFilter 
		{
			get => _hostFilter;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"HostFilter does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"HostFilter does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_hostFilter = value;
			}
		}

		/// <summary>
		/// <para>The host to match, or null to match any host.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithHostFilter(String? hostFilter)
		{
			HostFilter = hostFilter;
			return this;
		}

		private Int8 _operation = Int8.Default;
		/// <summary>
		/// <para>The operation to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 Operation 
		{
			get => _operation;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Operation does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_operation = value;
			}
		}

		/// <summary>
		/// <para>The operation to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithOperation(Int8 operation)
		{
			Operation = operation;
			return this;
		}

		private Int8 _permissionType = Int8.Default;
		/// <summary>
		/// <para>The permission type to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int8 PermissionType 
		{
			get => _permissionType;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"PermissionType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_permissionType = value;
			}
		}

		/// <summary>
		/// <para>The permission type to match.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsRequest WithPermissionType(Int8 permissionType)
		{
			PermissionType = permissionType;
			return this;
		}

		public DescribeAclsResponse Respond()
			=> new DescribeAclsResponse(Version);
	}

	public class DescribeAclsResponse : Message
	{
		public DescribeAclsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeAclsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(29);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeAclsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeAclsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResourcesCollection = await Array<DescribeAclsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeAclsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeAclsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribeAclsResource>.From(ResourcesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private DescribeAclsResource[] _resourcesCollection = Array.Empty<DescribeAclsResource>();
		/// <summary>
		/// <para>Each Resource that is referenced in an ACL.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResource[] ResourcesCollection 
		{
			get => _resourcesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResourcesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each Resource that is referenced in an ACL.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeAclsResponse WithResourcesCollection(params Func<DescribeAclsResource, DescribeAclsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(CreateDescribeAclsResource()))
				.ToArray();
			return this;
		}

		internal DescribeAclsResource CreateDescribeAclsResource()
		{
			return new DescribeAclsResource(Version);
		}

		public class DescribeAclsResource : ISerialize
		{
			internal DescribeAclsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					PatternType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<AclDescription>.From(AclsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeAclsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeAclsResource(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.PatternType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.AclsCollection = await Array<AclDescription>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AclDescription.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeAclsResource is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await PatternType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<AclDescription>.From(AclsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Int8 _patternType = new Int8(3);
			/// <summary>
			/// <para>The resource pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public Int8 PatternType 
			{
				get => _patternType;
				set 
				{
					if (Version.InRange(1, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PatternType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
					}

					_patternType = value;
				}
			}

			/// <summary>
			/// <para>The resource pattern type.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: 3</para>
			/// </summary>
			public DescribeAclsResource WithPatternType(Int8 patternType)
			{
				PatternType = patternType;
				return this;
			}

			private AclDescription[] _aclsCollection = Array.Empty<AclDescription>();
			/// <summary>
			/// <para>The ACLs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AclDescription[] AclsCollection 
			{
				get => _aclsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"AclsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_aclsCollection = value;
				}
			}

			/// <summary>
			/// <para>The ACLs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeAclsResource WithAclsCollection(params Func<AclDescription, AclDescription>[] createFields)
			{
				AclsCollection = createFields
					.Select(createField => createField(CreateAclDescription()))
					.ToArray();
				return this;
			}

			internal AclDescription CreateAclDescription()
			{
				return new AclDescription(Version);
			}

			public class AclDescription : ISerialize
			{
				internal AclDescription(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Principal.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Host.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Operation.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						PermissionType.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<AclDescription> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AclDescription(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Principal = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Operation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PermissionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AclDescription is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Principal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Operation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await PermissionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _principal = String.Default;
				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Principal 
				{
					get => _principal;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Principal does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_principal = value;
					}
				}

				/// <summary>
				/// <para>The ACL principal.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithPrincipal(String principal)
				{
					Principal = principal;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_host = value;
					}
				}

				/// <summary>
				/// <para>The ACL host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithHost(String host)
				{
					Host = host;
					return this;
				}

				private Int8 _operation = Int8.Default;
				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 Operation 
				{
					get => _operation;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Operation does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_operation = value;
					}
				}

				/// <summary>
				/// <para>The ACL operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithOperation(Int8 operation)
				{
					Operation = operation;
					return this;
				}

				private Int8 _permissionType = Int8.Default;
				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 PermissionType 
				{
					get => _permissionType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PermissionType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_permissionType = value;
					}
				}

				/// <summary>
				/// <para>The ACL permission type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AclDescription WithPermissionType(Int8 permissionType)
				{
					PermissionType = permissionType;
					return this;
				}
			}
		}
	}

	public class DescribeClientQuotasRequest : Message, IRespond<DescribeClientQuotasResponse>
	{
		public DescribeClientQuotasRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeClientQuotasRequest does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(48);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeClientQuotasRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClientQuotasRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ComponentsCollection = await Array<ComponentData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ComponentData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Strict = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClientQuotasRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ComponentData>.From(ComponentsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Strict.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private ComponentData[] _componentsCollection = Array.Empty<ComponentData>();
		/// <summary>
		/// <para>Filter components to apply to quota entities.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ComponentData[] ComponentsCollection 
		{
			get => _componentsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ComponentsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_componentsCollection = value;
			}
		}

		/// <summary>
		/// <para>Filter components to apply to quota entities.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasRequest WithComponentsCollection(params Func<ComponentData, ComponentData>[] createFields)
		{
			ComponentsCollection = createFields
				.Select(createField => createField(CreateComponentData()))
				.ToArray();
			return this;
		}

		internal ComponentData CreateComponentData()
		{
			return new ComponentData(Version);
		}

		public class ComponentData : ISerialize
		{
			internal ComponentData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					EntityType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MatchType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Match.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ComponentData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ComponentData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MatchType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Match = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ComponentData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await EntityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MatchType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Match.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _entityType = String.Default;
			/// <summary>
			/// <para>The entity type that the filter component applies to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String EntityType 
			{
				get => _entityType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"EntityType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_entityType = value;
				}
			}

			/// <summary>
			/// <para>The entity type that the filter component applies to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ComponentData WithEntityType(String entityType)
			{
				EntityType = entityType;
				return this;
			}

			private Int8 _matchType = Int8.Default;
			/// <summary>
			/// <para>How to match the entity {0 = exact name, 1 = default name, 2 = any specified name}.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 MatchType 
			{
				get => _matchType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MatchType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_matchType = value;
				}
			}

			/// <summary>
			/// <para>How to match the entity {0 = exact name, 1 = default name, 2 = any specified name}.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ComponentData WithMatchType(Int8 matchType)
			{
				MatchType = matchType;
				return this;
			}

			private String? _match;
			/// <summary>
			/// <para>The string to match against, or null if unused for the match type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Match 
			{
				get => _match;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Match does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Match does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_match = value;
				}
			}

			/// <summary>
			/// <para>The string to match against, or null if unused for the match type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ComponentData WithMatch(String? match)
			{
				Match = match;
				return this;
			}
		}

		private Boolean _strict = Boolean.Default;
		/// <summary>
		/// <para>Whether the match is strict, i.e. should exclude entities with unspecified entity types.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean Strict 
		{
			get => _strict;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Strict does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_strict = value;
			}
		}

		/// <summary>
		/// <para>Whether the match is strict, i.e. should exclude entities with unspecified entity types.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasRequest WithStrict(Boolean strict)
		{
			Strict = strict;
			return this;
		}

		public DescribeClientQuotasResponse Respond()
			=> new DescribeClientQuotasResponse(Version);
	}

	public class DescribeClientQuotasResponse : Message
	{
		public DescribeClientQuotasResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeClientQuotasResponse does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(48);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeClientQuotasResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClientQuotasResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.EntriesCollection = await NullableArray<EntryData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntryData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClientQuotasResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<EntryData>.From(EntriesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or `0` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or `0` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The error message, or `null` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or `null` if the quota description succeeded.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private EntryData[]? _entriesCollection = Array.Empty<EntryData>();
		/// <summary>
		/// <para>A result entry.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EntryData[]? EntriesCollection 
		{
			get => _entriesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"EntriesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"EntriesCollection does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_entriesCollection = value;
			}
		}

		/// <summary>
		/// <para>A result entry.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClientQuotasResponse WithEntriesCollection(params Func<EntryData, EntryData>[] createFields)
		{
			EntriesCollection = createFields
				.Select(createField => createField(CreateEntryData()))
				.ToArray();
			return this;
		}

		internal EntryData CreateEntryData()
		{
			return new EntryData(Version);
		}

		public class EntryData : ISerialize
		{
			internal EntryData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Array<EntityData>.From(EntityCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<ValueData>.From(ValuesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<EntryData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new EntryData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.EntityCollection = await Array<EntityData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EntityData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ValuesCollection = await Array<ValueData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ValueData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for EntryData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<EntityData>.From(EntityCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<ValueData>.From(ValuesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private EntityData[] _entityCollection = Array.Empty<EntityData>();
			/// <summary>
			/// <para>The quota entity description.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntityData[] EntityCollection 
			{
				get => _entityCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"EntityCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_entityCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota entity description.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithEntityCollection(params Func<EntityData, EntityData>[] createFields)
			{
				EntityCollection = createFields
					.Select(createField => createField(CreateEntityData()))
					.ToArray();
				return this;
			}

			internal EntityData CreateEntityData()
			{
				return new EntityData(Version);
			}

			public class EntityData : ISerialize
			{
				internal EntityData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						EntityType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						EntityName.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<EntityData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EntityData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EntityType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EntityName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EntityData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await EntityType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await EntityName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _entityType = String.Default;
				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String EntityType 
				{
					get => _entityType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EntityType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_entityType = value;
					}
				}

				/// <summary>
				/// <para>The entity type.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityType(String entityType)
				{
					EntityType = entityType;
					return this;
				}

				private String? _entityName;
				/// <summary>
				/// <para>The entity name, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? EntityName 
				{
					get => _entityName;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EntityName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"EntityName does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_entityName = value;
					}
				}

				/// <summary>
				/// <para>The entity name, or null if the default.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EntityData WithEntityName(String? entityName)
				{
					EntityName = entityName;
					return this;
				}
			}

			private ValueData[] _valuesCollection = Array.Empty<ValueData>();
			/// <summary>
			/// <para>The quota values for the entity.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ValueData[] ValuesCollection 
			{
				get => _valuesCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ValuesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_valuesCollection = value;
				}
			}

			/// <summary>
			/// <para>The quota values for the entity.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EntryData WithValuesCollection(params Func<ValueData, ValueData>[] createFields)
			{
				ValuesCollection = createFields
					.Select(createField => createField(CreateValueData()))
					.ToArray();
				return this;
			}

			internal ValueData CreateValueData()
			{
				return new ValueData(Version);
			}

			public class ValueData : ISerialize
			{
				internal ValueData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Key.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<ValueData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ValueData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Value = await Float64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ValueData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _key = String.Default;
				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Key 
				{
					get => _key;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Key does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_key = value;
					}
				}

				/// <summary>
				/// <para>The quota configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ValueData WithKey(String key)
				{
					Key = key;
					return this;
				}

				private Float64 _value = Float64.Default;
				/// <summary>
				/// <para>The quota configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Float64 Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The quota configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ValueData WithValue(Float64 value)
				{
					Value = value;
					return this;
				}
			}
		}
	}

	public class DescribeClusterRequest : Message, IRespond<DescribeClusterResponse>
	{
		public DescribeClusterRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeClusterRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(60);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeClusterRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClusterRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.IncludeClusterAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClusterRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await IncludeClusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Boolean _includeClusterAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean IncludeClusterAuthorizedOperations 
		{
			get => _includeClusterAuthorizedOperations;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IncludeClusterAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_includeClusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterRequest WithIncludeClusterAuthorizedOperations(Boolean includeClusterAuthorizedOperations)
		{
			IncludeClusterAuthorizedOperations = includeClusterAuthorizedOperations;
			return this;
		}

		public DescribeClusterResponse Respond()
			=> new DescribeClusterResponse(Version);
	}

	public class DescribeClusterResponse : Message
	{
		public DescribeClusterResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeClusterResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(60);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeClusterResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeClusterResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClusterId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokersCollection = (await Array<DescribeClusterBroker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeClusterBroker.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.BrokerId);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClusterAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClusterResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribeClusterBroker>.From(BrokersCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public DescribeClusterResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private String _clusterId = String.Default;
		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithClusterId(String clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _controllerId = new Int32(-1);
		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public DescribeClusterResponse WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Dictionary<Int32, DescribeClusterBroker> _brokersCollection = new Dictionary<Int32, DescribeClusterBroker>();
		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<Int32, DescribeClusterBroker> BrokersCollection 
		{
			get => _brokersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokersCollection = value;
			}
		}

		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeClusterResponse WithBrokersCollection(params Func<DescribeClusterBroker, DescribeClusterBroker>[] createFields)
		{
			BrokersCollection = createFields
				.Select(createField => createField(CreateDescribeClusterBroker()))
				.ToDictionary(field => field.BrokerId);
			return this;
		}

		internal DescribeClusterBroker CreateDescribeClusterBroker()
		{
			return new DescribeClusterBroker(Version);
		}

		public class DescribeClusterBroker : ISerialize
		{
			internal DescribeClusterBroker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					BrokerId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Host.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Port.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Rack.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeClusterBroker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeClusterBroker(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeClusterBroker is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int32 _brokerId = Int32.Default;
			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 BrokerId 
			{
				get => _brokerId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_brokerId = value;
				}
			}

			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeClusterBroker WithBrokerId(Int32 brokerId)
			{
				BrokerId = brokerId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_host = value;
				}
			}

			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeClusterBroker WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_port = value;
				}
			}

			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeClusterBroker WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private String? _rack;
			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Rack does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 0+</para>
			/// <para>Default: null</para>
			/// </summary>
			public DescribeClusterBroker WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}

		private Int32 _clusterAuthorizedOperations = new Int32(-2147483648);
		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public Int32 ClusterAuthorizedOperations 
		{
			get => _clusterAuthorizedOperations;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_clusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public DescribeClusterResponse WithClusterAuthorizedOperations(Int32 clusterAuthorizedOperations)
		{
			ClusterAuthorizedOperations = clusterAuthorizedOperations;
			return this;
		}
	}

	public class DescribeConfigsRequest : Message, IRespond<DescribeConfigsResponse>
	{
		public DescribeConfigsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeConfigsRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(32);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeConfigsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeConfigsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResourcesCollection = await Array<DescribeConfigsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.IncludeSynonyms = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.IncludeDocumentation = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribeConfigsResource>.From(ResourcesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await IncludeSynonyms.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await IncludeDocumentation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private DescribeConfigsResource[] _resourcesCollection = Array.Empty<DescribeConfigsResource>();
		/// <summary>
		/// <para>The resources whose configurations we want to describe.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResource[] ResourcesCollection 
		{
			get => _resourcesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResourcesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>The resources whose configurations we want to describe.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsRequest WithResourcesCollection(params Func<DescribeConfigsResource, DescribeConfigsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(CreateDescribeConfigsResource()))
				.ToArray();
			return this;
		}

		internal DescribeConfigsResource CreateDescribeConfigsResource()
		{
			return new DescribeConfigsResource(Version);
		}

		public class DescribeConfigsResource : ISerialize
		{
			internal DescribeConfigsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					NullableArray<String>.From(ConfigurationKeysCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeConfigsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeConfigsResource(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ConfigurationKeysCollection = await NullableArray<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResource is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await NullableArray<String>.From(ConfigurationKeysCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private String[]? _configurationKeysCollection = Array.Empty<String>();
			/// <summary>
			/// <para>The configuration keys to list, or null to list all configuration keys.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String[]? ConfigurationKeysCollection 
			{
				get => _configurationKeysCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ConfigurationKeysCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ConfigurationKeysCollection does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_configurationKeysCollection = value;
				}
			}

			/// <summary>
			/// <para>The configuration keys to list, or null to list all configuration keys.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResource WithConfigurationKeysCollection(String[]? configurationKeysCollection)
			{
				ConfigurationKeysCollection = configurationKeysCollection;
				return this;
			}
		}

		private Boolean _includeSynonyms = new Boolean(false);
		/// <summary>
		/// <para>True if we should include all synonyms.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IncludeSynonyms 
		{
			get => _includeSynonyms;
			set 
			{
				if (Version.InRange(1, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IncludeSynonyms does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
				}

				_includeSynonyms = value;
			}
		}

		/// <summary>
		/// <para>True if we should include all synonyms.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: false</para>
		/// </summary>
		public DescribeConfigsRequest WithIncludeSynonyms(Boolean includeSynonyms)
		{
			IncludeSynonyms = includeSynonyms;
			return this;
		}

		private Boolean _includeDocumentation = new Boolean(false);
		/// <summary>
		/// <para>True if we should include configuration documentation.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean IncludeDocumentation 
		{
			get => _includeDocumentation;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IncludeDocumentation does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_includeDocumentation = value;
			}
		}

		/// <summary>
		/// <para>True if we should include configuration documentation.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: false</para>
		/// </summary>
		public DescribeConfigsRequest WithIncludeDocumentation(Boolean includeDocumentation)
		{
			IncludeDocumentation = includeDocumentation;
			return this;
		}

		public DescribeConfigsResponse Respond()
			=> new DescribeConfigsResponse(Version);
	}

	public class DescribeConfigsResponse : Message
	{
		public DescribeConfigsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeConfigsResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(32);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeConfigsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeConfigsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<DescribeConfigsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribeConfigsResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private DescribeConfigsResult[] _resultsCollection = Array.Empty<DescribeConfigsResult>();
		/// <summary>
		/// <para>The results for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeConfigsResponse WithResultsCollection(params Func<DescribeConfigsResult, DescribeConfigsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateDescribeConfigsResult()))
				.ToArray();
			return this;
		}

		internal DescribeConfigsResult CreateDescribeConfigsResult()
		{
			return new DescribeConfigsResult(Version);
		}

		public class DescribeConfigsResult : ISerialize
		{
			internal DescribeConfigsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DescribeConfigsResourceResult>.From(ConfigsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeConfigsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeConfigsResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ConfigsCollection = await Array<DescribeConfigsResourceResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsResourceResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DescribeConfigsResourceResult>.From(ConfigsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, or null if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if we were able to successfully describe the configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private DescribeConfigsResourceResult[] _configsCollection = Array.Empty<DescribeConfigsResourceResult>();
			/// <summary>
			/// <para>Each listed configuration.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResourceResult[] ConfigsCollection 
			{
				get => _configsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ConfigsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each listed configuration.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeConfigsResult WithConfigsCollection(params Func<DescribeConfigsResourceResult, DescribeConfigsResourceResult>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(CreateDescribeConfigsResourceResult()))
					.ToArray();
				return this;
			}

			internal DescribeConfigsResourceResult CreateDescribeConfigsResourceResult()
			{
				return new DescribeConfigsResourceResult(Version);
			}

			public class DescribeConfigsResourceResult : ISerialize
			{
				internal DescribeConfigsResourceResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(4, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ReadOnly.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 0) ? 
						IsDefault.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						ConfigSource.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						IsSensitive.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						Array<DescribeConfigsSynonym>.From(SynonymsCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(3, 2147483647) ? 
						ConfigType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(3, 2147483647) ? 
						Documentation.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DescribeConfigsResourceResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribeConfigsResourceResult(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ReadOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 0)) 
					{
						instance.IsDefault = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.ConfigSource = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.IsSensitive = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.SynonymsCollection = await Array<DescribeConfigsSynonym>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeConfigsSynonym.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(3, 2147483647)) 
					{
						instance.ConfigType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(3, 2147483647)) 
					{
						instance.Documentation = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsResourceResult is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ReadOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 0)) 
					{
						await IsDefault.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await ConfigSource.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await IsSensitive.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await Array<DescribeConfigsSynonym>.From(SynonymsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(3, 2147483647)) 
					{
						await ConfigType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(3, 2147483647)) 
					{
						await Documentation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithName(String name)
				{
					Name = name;
					return this;
				}

				private String? _value;
				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The configuration value.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithValue(String? value)
				{
					Value = value;
					return this;
				}

				private Boolean _readOnly = Boolean.Default;
				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean ReadOnly 
				{
					get => _readOnly;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ReadOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_readOnly = value;
					}
				}

				/// <summary>
				/// <para>True if the configuration is read-only.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithReadOnly(Boolean readOnly)
				{
					ReadOnly = readOnly;
					return this;
				}

				private Boolean _isDefault = Boolean.Default;
				/// <summary>
				/// <para>True if the configuration is not set.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public Boolean IsDefault 
				{
					get => _isDefault;
					set 
					{
						if (Version.InRange(0, 0) == false) 
						{
							throw new UnsupportedVersionException($"IsDefault does not support version {Version} and has been defined as not ignorable. Supported versions: 0");
						}

						_isDefault = value;
					}
				}

				/// <summary>
				/// <para>True if the configuration is not set.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public DescribeConfigsResourceResult WithIsDefault(Boolean isDefault)
				{
					IsDefault = isDefault;
					return this;
				}

				private Int8 _configSource = new Int8(-1);
				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int8 ConfigSource 
				{
					get => _configSource;
					set 
					{
						_configSource = value;
					}
				}

				/// <summary>
				/// <para>The configuration source.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public DescribeConfigsResourceResult WithConfigSource(Int8 configSource)
				{
					ConfigSource = configSource;
					return this;
				}

				private Boolean _isSensitive = Boolean.Default;
				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean IsSensitive 
				{
					get => _isSensitive;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"IsSensitive does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_isSensitive = value;
					}
				}

				/// <summary>
				/// <para>True if this configuration is sensitive.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithIsSensitive(Boolean isSensitive)
				{
					IsSensitive = isSensitive;
					return this;
				}

				private DescribeConfigsSynonym[] _synonymsCollection = Array.Empty<DescribeConfigsSynonym>();
				/// <summary>
				/// <para>The synonyms for this configuration key.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public DescribeConfigsSynonym[] SynonymsCollection 
				{
					get => _synonymsCollection;
					set 
					{
						_synonymsCollection = value;
					}
				}

				/// <summary>
				/// <para>The synonyms for this configuration key.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithSynonymsCollection(params Func<DescribeConfigsSynonym, DescribeConfigsSynonym>[] createFields)
				{
					SynonymsCollection = createFields
						.Select(createField => createField(CreateDescribeConfigsSynonym()))
						.ToArray();
					return this;
				}

				internal DescribeConfigsSynonym CreateDescribeConfigsSynonym()
				{
					return new DescribeConfigsSynonym(Version);
				}

				public class DescribeConfigsSynonym : ISerialize
				{
					internal DescribeConfigsSynonym(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(4, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(1, 2147483647) ? 
							Name.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(1, 2147483647) ? 
							Value.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(1, 2147483647) ? 
							Source.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<DescribeConfigsSynonym> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new DescribeConfigsSynonym(version);
						if (instance.Version.InRange(1, 2147483647)) 
						{
							instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(1, 2147483647)) 
						{
							instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(1, 2147483647)) 
						{
							instance.Source = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeConfigsSynonym is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(1, 2147483647)) 
						{
							await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(1, 2147483647)) 
						{
							await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(1, 2147483647)) 
						{
							await Source.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private String _name = String.Default;
					/// <summary>
					/// <para>The synonym name.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public String Name 
					{
						get => _name;
						set 
						{
							if (Version.InRange(1, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
							}

							_name = value;
						}
					}

					/// <summary>
					/// <para>The synonym name.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public DescribeConfigsSynonym WithName(String name)
					{
						Name = name;
						return this;
					}

					private String? _value;
					/// <summary>
					/// <para>The synonym value.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public String? Value 
					{
						get => _value;
						set 
						{
							if (Version.InRange(1, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
							}

							if (Version.InRange(0, 2147483647) == false &&
								value == null) 
							{
								throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 0+");
							}

							_value = value;
						}
					}

					/// <summary>
					/// <para>The synonym value.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public DescribeConfigsSynonym WithValue(String? value)
					{
						Value = value;
						return this;
					}

					private Int8 _source = Int8.Default;
					/// <summary>
					/// <para>The synonym source.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public Int8 Source 
					{
						get => _source;
						set 
						{
							if (Version.InRange(1, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Source does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
							}

							_source = value;
						}
					}

					/// <summary>
					/// <para>The synonym source.</para>
					/// <para>Versions: 1+</para>
					/// </summary>
					public DescribeConfigsSynonym WithSource(Int8 source)
					{
						Source = source;
						return this;
					}
				}

				private Int8 _configType = new Int8(0);
				/// <summary>
				/// <para>The configuration data type. Type can be one of the following values - BOOLEAN, STRING, INT, SHORT, LONG, DOUBLE, LIST, CLASS, PASSWORD</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public Int8 ConfigType 
				{
					get => _configType;
					set 
					{
						_configType = value;
					}
				}

				/// <summary>
				/// <para>The configuration data type. Type can be one of the following values - BOOLEAN, STRING, INT, SHORT, LONG, DOUBLE, LIST, CLASS, PASSWORD</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: 0</para>
				/// </summary>
				public DescribeConfigsResourceResult WithConfigType(Int8 configType)
				{
					ConfigType = configType;
					return this;
				}

				private String? _documentation;
				/// <summary>
				/// <para>The configuration documentation.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public String? Documentation 
				{
					get => _documentation;
					set 
					{
						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Documentation does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_documentation = value;
					}
				}

				/// <summary>
				/// <para>The configuration documentation.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public DescribeConfigsResourceResult WithDocumentation(String? documentation)
				{
					Documentation = documentation;
					return this;
				}
			}
		}
	}

	public class DescribeDelegationTokenRequest : Message, IRespond<DescribeDelegationTokenResponse>
	{
		public DescribeDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeDelegationTokenRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(41);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeDelegationTokenRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.OwnersCollection = await NullableArray<DescribeDelegationTokenOwner>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeDelegationTokenOwner.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<DescribeDelegationTokenOwner>.From(OwnersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private DescribeDelegationTokenOwner[]? _ownersCollection = Array.Empty<DescribeDelegationTokenOwner>();
		/// <summary>
		/// <para>Each owner that we want to describe delegation tokens for, or null to describe all tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenOwner[]? OwnersCollection 
		{
			get => _ownersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"OwnersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"OwnersCollection does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_ownersCollection = value;
			}
		}

		/// <summary>
		/// <para>Each owner that we want to describe delegation tokens for, or null to describe all tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenRequest WithOwnersCollection(params Func<DescribeDelegationTokenOwner, DescribeDelegationTokenOwner>[] createFields)
		{
			OwnersCollection = createFields
				.Select(createField => createField(CreateDescribeDelegationTokenOwner()))
				.ToArray();
			return this;
		}

		internal DescribeDelegationTokenOwner CreateDescribeDelegationTokenOwner()
		{
			return new DescribeDelegationTokenOwner(Version);
		}

		public class DescribeDelegationTokenOwner : ISerialize
		{
			internal DescribeDelegationTokenOwner(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					PrincipalType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PrincipalName.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeDelegationTokenOwner> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeDelegationTokenOwner(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeDelegationTokenOwner is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _principalType = String.Default;
			/// <summary>
			/// <para>The owner principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalType 
			{
				get => _principalType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principalType = value;
				}
			}

			/// <summary>
			/// <para>The owner principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeDelegationTokenOwner WithPrincipalType(String principalType)
			{
				PrincipalType = principalType;
				return this;
			}

			private String _principalName = String.Default;
			/// <summary>
			/// <para>The owner principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalName 
			{
				get => _principalName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principalName = value;
				}
			}

			/// <summary>
			/// <para>The owner principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeDelegationTokenOwner WithPrincipalName(String principalName)
			{
				PrincipalName = principalName;
				return this;
			}
		}

		public DescribeDelegationTokenResponse Respond()
			=> new DescribeDelegationTokenResponse(Version);
	}

	public class DescribeDelegationTokenResponse : Message
	{
		public DescribeDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeDelegationTokenResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(41);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeDelegationTokenResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TokensCollection = await Array<DescribedDelegationToken>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedDelegationToken.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribedDelegationToken>.From(TokensCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private DescribedDelegationToken[] _tokensCollection = Array.Empty<DescribedDelegationToken>();
		/// <summary>
		/// <para>The tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribedDelegationToken[] TokensCollection 
		{
			get => _tokensCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TokensCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_tokensCollection = value;
			}
		}

		/// <summary>
		/// <para>The tokens.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithTokensCollection(params Func<DescribedDelegationToken, DescribedDelegationToken>[] createFields)
		{
			TokensCollection = createFields
				.Select(createField => createField(CreateDescribedDelegationToken()))
				.ToArray();
			return this;
		}

		internal DescribedDelegationToken CreateDescribedDelegationToken()
		{
			return new DescribedDelegationToken(Version);
		}

		public class DescribedDelegationToken : ISerialize
		{
			internal DescribedDelegationToken(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					PrincipalType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PrincipalName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					IssueTimestamp.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ExpiryTimestamp.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MaxTimestamp.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TokenId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Hmac.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DescribedDelegationTokenRenewer>.From(RenewersCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribedDelegationToken> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribedDelegationToken(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.IssueTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ExpiryTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MaxTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TokenId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.RenewersCollection = await Array<DescribedDelegationTokenRenewer>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedDelegationTokenRenewer.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedDelegationToken is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await IssueTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ExpiryTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MaxTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TokenId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DescribedDelegationTokenRenewer>.From(RenewersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _principalType = String.Default;
			/// <summary>
			/// <para>The token principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalType 
			{
				get => _principalType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principalType = value;
				}
			}

			/// <summary>
			/// <para>The token principal type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithPrincipalType(String principalType)
			{
				PrincipalType = principalType;
				return this;
			}

			private String _principalName = String.Default;
			/// <summary>
			/// <para>The token principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String PrincipalName 
			{
				get => _principalName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_principalName = value;
				}
			}

			/// <summary>
			/// <para>The token principal name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithPrincipalName(String principalName)
			{
				PrincipalName = principalName;
				return this;
			}

			private Int64 _issueTimestamp = Int64.Default;
			/// <summary>
			/// <para>The token issue timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 IssueTimestamp 
			{
				get => _issueTimestamp;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"IssueTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_issueTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The token issue timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithIssueTimestamp(Int64 issueTimestamp)
			{
				IssueTimestamp = issueTimestamp;
				return this;
			}

			private Int64 _expiryTimestamp = Int64.Default;
			/// <summary>
			/// <para>The token expiry timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ExpiryTimestamp 
			{
				get => _expiryTimestamp;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ExpiryTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_expiryTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The token expiry timestamp in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithExpiryTimestamp(Int64 expiryTimestamp)
			{
				ExpiryTimestamp = expiryTimestamp;
				return this;
			}

			private Int64 _maxTimestamp = Int64.Default;
			/// <summary>
			/// <para>The token maximum timestamp length in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 MaxTimestamp 
			{
				get => _maxTimestamp;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MaxTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_maxTimestamp = value;
				}
			}

			/// <summary>
			/// <para>The token maximum timestamp length in milliseconds.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithMaxTimestamp(Int64 maxTimestamp)
			{
				MaxTimestamp = maxTimestamp;
				return this;
			}

			private String _tokenId = String.Default;
			/// <summary>
			/// <para>The token ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TokenId 
			{
				get => _tokenId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TokenId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_tokenId = value;
				}
			}

			/// <summary>
			/// <para>The token ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithTokenId(String tokenId)
			{
				TokenId = tokenId;
				return this;
			}

			private Bytes _hmac = Bytes.Default;
			/// <summary>
			/// <para>The token HMAC.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Hmac 
			{
				get => _hmac;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Hmac does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_hmac = value;
				}
			}

			/// <summary>
			/// <para>The token HMAC.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithHmac(Bytes hmac)
			{
				Hmac = hmac;
				return this;
			}

			private DescribedDelegationTokenRenewer[] _renewersCollection = Array.Empty<DescribedDelegationTokenRenewer>();
			/// <summary>
			/// <para>Those who are able to renew this token before it expires.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationTokenRenewer[] RenewersCollection 
			{
				get => _renewersCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"RenewersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_renewersCollection = value;
				}
			}

			/// <summary>
			/// <para>Those who are able to renew this token before it expires.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedDelegationToken WithRenewersCollection(params Func<DescribedDelegationTokenRenewer, DescribedDelegationTokenRenewer>[] createFields)
			{
				RenewersCollection = createFields
					.Select(createField => createField(CreateDescribedDelegationTokenRenewer()))
					.ToArray();
				return this;
			}

			internal DescribedDelegationTokenRenewer CreateDescribedDelegationTokenRenewer()
			{
				return new DescribedDelegationTokenRenewer(Version);
			}

			public class DescribedDelegationTokenRenewer : ISerialize
			{
				internal DescribedDelegationTokenRenewer(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PrincipalType.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						PrincipalName.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DescribedDelegationTokenRenewer> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribedDelegationTokenRenewer(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PrincipalType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PrincipalName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedDelegationTokenRenewer is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PrincipalType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await PrincipalName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _principalType = String.Default;
				/// <summary>
				/// <para>The renewer principal type</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String PrincipalType 
				{
					get => _principalType;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PrincipalType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_principalType = value;
					}
				}

				/// <summary>
				/// <para>The renewer principal type</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedDelegationTokenRenewer WithPrincipalType(String principalType)
				{
					PrincipalType = principalType;
					return this;
				}

				private String _principalName = String.Default;
				/// <summary>
				/// <para>The renewer principal name</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String PrincipalName 
				{
					get => _principalName;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PrincipalName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_principalName = value;
					}
				}

				/// <summary>
				/// <para>The renewer principal name</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedDelegationTokenRenewer WithPrincipalName(String principalName)
				{
					PrincipalName = principalName;
					return this;
				}
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class DescribeGroupsRequest : Message, IRespond<DescribeGroupsResponse>
	{
		public DescribeGroupsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeGroupsRequest does not support version {version}. Valid versions are: 0-5");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(5, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(15);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeGroupsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeGroupsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.IncludeAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeGroupsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(GroupsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await IncludeAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String[] _groupsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The names of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] GroupsCollection 
		{
			get => _groupsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>The names of the groups to describe</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeGroupsRequest WithGroupsCollection(String[] groupsCollection)
		{
			GroupsCollection = groupsCollection;
			return this;
		}

		private Boolean _includeAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Boolean IncludeAuthorizedOperations 
		{
			get => _includeAuthorizedOperations;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IncludeAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_includeAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include authorized operations.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public DescribeGroupsRequest WithIncludeAuthorizedOperations(Boolean includeAuthorizedOperations)
		{
			IncludeAuthorizedOperations = includeAuthorizedOperations;
			return this;
		}

		public DescribeGroupsResponse Respond()
			=> new DescribeGroupsResponse(Version);
	}

	public class DescribeGroupsResponse : Message
	{
		public DescribeGroupsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeGroupsResponse does not support version {version}. Valid versions are: 0-5");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(5, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(15);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeGroupsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeGroupsResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupsCollection = await Array<DescribedGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeGroupsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribedGroup>.From(GroupsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public DescribeGroupsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private DescribedGroup[] _groupsCollection = Array.Empty<DescribedGroup>();
		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribedGroup[] GroupsCollection 
		{
			get => _groupsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each described group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeGroupsResponse WithGroupsCollection(params Func<DescribedGroup, DescribedGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(CreateDescribedGroup()))
				.ToArray();
			return this;
		}

		internal DescribedGroup CreateDescribedGroup()
		{
			return new DescribedGroup(Version);
		}

		public class DescribedGroup : ISerialize
		{
			internal DescribedGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(5, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					GroupId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					GroupState.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProtocolType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProtocolData.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DescribedGroupMember>.From(MembersCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					AuthorizedOperations.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribedGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribedGroup(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.GroupState = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProtocolType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProtocolData = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MembersCollection = await Array<DescribedGroupMember>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribedGroupMember.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.AuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedGroup is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await GroupState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProtocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProtocolData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DescribedGroupMember>.From(MembersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await AuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The describe error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private String _groupState = String.Default;
			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupState 
			{
				get => _groupState;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupState does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_groupState = value;
				}
			}

			/// <summary>
			/// <para>The group state string, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithGroupState(String groupState)
			{
				GroupState = groupState;
				return this;
			}

			private String _protocolType = String.Default;
			/// <summary>
			/// <para>The group protocol type, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ProtocolType 
			{
				get => _protocolType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProtocolType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_protocolType = value;
				}
			}

			/// <summary>
			/// <para>The group protocol type, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithProtocolType(String protocolType)
			{
				ProtocolType = protocolType;
				return this;
			}

			private String _protocolData = String.Default;
			/// <summary>
			/// <para>The group protocol data, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ProtocolData 
			{
				get => _protocolData;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProtocolData does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_protocolData = value;
				}
			}

			/// <summary>
			/// <para>The group protocol data, or the empty string.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithProtocolData(String protocolData)
			{
				ProtocolData = protocolData;
				return this;
			}

			private DescribedGroupMember[] _membersCollection = Array.Empty<DescribedGroupMember>();
			/// <summary>
			/// <para>The group members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroupMember[] MembersCollection 
			{
				get => _membersCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MembersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_membersCollection = value;
				}
			}

			/// <summary>
			/// <para>The group members.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribedGroup WithMembersCollection(params Func<DescribedGroupMember, DescribedGroupMember>[] createFields)
			{
				MembersCollection = createFields
					.Select(createField => createField(CreateDescribedGroupMember()))
					.ToArray();
				return this;
			}

			internal DescribedGroupMember CreateDescribedGroupMember()
			{
				return new DescribedGroupMember(Version);
			}

			public class DescribedGroupMember : ISerialize
			{
				internal DescribedGroupMember(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(5, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						MemberId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(4, 2147483647) ? 
						GroupInstanceId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ClientId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ClientHost.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						MemberMetadata.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						MemberAssignment.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DescribedGroupMember> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribedGroupMember(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(4, 2147483647)) 
					{
						instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ClientId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ClientHost = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.MemberMetadata = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.MemberAssignment = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribedGroupMember is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(4, 2147483647)) 
					{
						await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ClientId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ClientHost.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await MemberMetadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await MemberAssignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _memberId = String.Default;
				/// <summary>
				/// <para>The member ID assigned by the group coordinator.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String MemberId 
				{
					get => _memberId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_memberId = value;
					}
				}

				/// <summary>
				/// <para>The member ID assigned by the group coordinator.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithMemberId(String memberId)
				{
					MemberId = memberId;
					return this;
				}

				private String? _groupInstanceId;
				/// <summary>
				/// <para>The unique identifier of the consumer instance provided by end user.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? GroupInstanceId 
				{
					get => _groupInstanceId;
					set 
					{
						if (Version.InRange(4, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 4+");
						}

						_groupInstanceId = value;
					}
				}

				/// <summary>
				/// <para>The unique identifier of the consumer instance provided by end user.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: null</para>
				/// </summary>
				public DescribedGroupMember WithGroupInstanceId(String? groupInstanceId)
				{
					GroupInstanceId = groupInstanceId;
					return this;
				}

				private String _clientId = String.Default;
				/// <summary>
				/// <para>The client ID used in the member's latest join group request.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientId 
				{
					get => _clientId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ClientId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_clientId = value;
					}
				}

				/// <summary>
				/// <para>The client ID used in the member's latest join group request.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithClientId(String clientId)
				{
					ClientId = clientId;
					return this;
				}

				private String _clientHost = String.Default;
				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String ClientHost 
				{
					get => _clientHost;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ClientHost does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_clientHost = value;
					}
				}

				/// <summary>
				/// <para>The client host.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithClientHost(String clientHost)
				{
					ClientHost = clientHost;
					return this;
				}

				private Bytes _memberMetadata = Bytes.Default;
				/// <summary>
				/// <para>The metadata corresponding to the current group protocol in use.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Bytes MemberMetadata 
				{
					get => _memberMetadata;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"MemberMetadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_memberMetadata = value;
					}
				}

				/// <summary>
				/// <para>The metadata corresponding to the current group protocol in use.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithMemberMetadata(Bytes memberMetadata)
				{
					MemberMetadata = memberMetadata;
					return this;
				}

				private Bytes _memberAssignment = Bytes.Default;
				/// <summary>
				/// <para>The current assignment provided by the group leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Bytes MemberAssignment 
				{
					get => _memberAssignment;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"MemberAssignment does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_memberAssignment = value;
					}
				}

				/// <summary>
				/// <para>The current assignment provided by the group leader.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribedGroupMember WithMemberAssignment(Bytes memberAssignment)
				{
					MemberAssignment = memberAssignment;
					return this;
				}
			}

			private Int32 _authorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 AuthorizedOperations 
			{
				get => _authorizedOperations;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"AuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_authorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public DescribedGroup WithAuthorizedOperations(Int32 authorizedOperations)
			{
				AuthorizedOperations = authorizedOperations;
				return this;
			}
		}
	}

	public class DescribeLogDirsRequest : Message, IRespond<DescribeLogDirsResponse>
	{
		public DescribeLogDirsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeLogDirsRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(35);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeLogDirsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeLogDirsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await NullableArray<DescribableLogDirTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribableLogDirTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value?.ToDictionary(field => field.Topic);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<DescribableLogDirTopic>.From(TopicsCollection?.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<String, DescribableLogDirTopic>? _topicsCollection = new Dictionary<String, DescribableLogDirTopic>();
		/// <summary>
		/// <para>Each topic that we want to describe log directories for, or null for all topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, DescribableLogDirTopic>? TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to describe log directories for, or null for all topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsRequest WithTopicsCollection(params Func<DescribableLogDirTopic, DescribableLogDirTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateDescribableLogDirTopic()))
				.ToDictionary(field => field.Topic);
			return this;
		}

		internal DescribableLogDirTopic CreateDescribableLogDirTopic()
		{
			return new DescribableLogDirTopic(Version);
		}

		public class DescribableLogDirTopic : ISerialize
		{
			internal DescribableLogDirTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribableLogDirTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribableLogDirTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribableLogDirTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribableLogDirTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Int32[] _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indxes.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indxes.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribableLogDirTopic WithPartitionsCollection(Int32[] partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		public DescribeLogDirsResponse Respond()
			=> new DescribeLogDirsResponse(Version);
	}

	public class DescribeLogDirsResponse : Message
	{
		public DescribeLogDirsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeLogDirsResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(35);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeLogDirsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeLogDirsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<DescribeLogDirsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeLogDirsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribeLogDirsResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private DescribeLogDirsResult[] _resultsCollection = Array.Empty<DescribeLogDirsResult>();
		/// <summary>
		/// <para>The log directories.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The log directories.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeLogDirsResponse WithResultsCollection(params Func<DescribeLogDirsResult, DescribeLogDirsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateDescribeLogDirsResult()))
				.ToArray();
			return this;
		}

		internal DescribeLogDirsResult CreateDescribeLogDirsResult()
		{
			return new DescribeLogDirsResult(Version);
		}

		public class DescribeLogDirsResult : ISerialize
		{
			internal DescribeLogDirsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					LogDir.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<DescribeLogDirsTopic>.From(TopicsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeLogDirsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeLogDirsResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.LogDir = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicsCollection = await Array<DescribeLogDirsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeLogDirsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await LogDir.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<DescribeLogDirsTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String _logDir = String.Default;
			/// <summary>
			/// <para>The absolute log directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String LogDir 
			{
				get => _logDir;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"LogDir does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_logDir = value;
				}
			}

			/// <summary>
			/// <para>The absolute log directory path.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithLogDir(String logDir)
			{
				LogDir = logDir;
				return this;
			}

			private DescribeLogDirsTopic[] _topicsCollection = Array.Empty<DescribeLogDirsTopic>();
			/// <summary>
			/// <para>Each topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsTopic[] TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeLogDirsResult WithTopicsCollection(params Func<DescribeLogDirsTopic, DescribeLogDirsTopic>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateDescribeLogDirsTopic()))
					.ToArray();
				return this;
			}

			internal DescribeLogDirsTopic CreateDescribeLogDirsTopic()
			{
				return new DescribeLogDirsTopic(Version);
			}

			public class DescribeLogDirsTopic : ISerialize
			{
				internal DescribeLogDirsTopic(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<DescribeLogDirsPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<DescribeLogDirsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new DescribeLogDirsTopic(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionsCollection = await Array<DescribeLogDirsPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeLogDirsPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsTopic is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<DescribeLogDirsPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeLogDirsTopic WithName(String name)
				{
					Name = name;
					return this;
				}

				private DescribeLogDirsPartition[] _partitionsCollection = Array.Empty<DescribeLogDirsPartition>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeLogDirsPartition[] PartitionsCollection 
				{
					get => _partitionsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public DescribeLogDirsTopic WithPartitionsCollection(params Func<DescribeLogDirsPartition, DescribeLogDirsPartition>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(CreateDescribeLogDirsPartition()))
						.ToArray();
					return this;
				}

				internal DescribeLogDirsPartition CreateDescribeLogDirsPartition()
				{
					return new DescribeLogDirsPartition(Version);
				}

				public class DescribeLogDirsPartition : ISerialize
				{
					internal DescribeLogDirsPartition(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(2, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							PartitionIndex.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							PartitionSize.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							OffsetLag.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							IsFutureKey.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<DescribeLogDirsPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new DescribeLogDirsPartition(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.PartitionSize = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.OffsetLag = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.IsFutureKey = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeLogDirsPartition is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await PartitionSize.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await OffsetLag.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await IsFutureKey.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int64 _partitionSize = Int64.Default;
					/// <summary>
					/// <para>The size of the log segments in this partition in bytes.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 PartitionSize 
					{
						get => _partitionSize;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"PartitionSize does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_partitionSize = value;
						}
					}

					/// <summary>
					/// <para>The size of the log segments in this partition in bytes.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithPartitionSize(Int64 partitionSize)
					{
						PartitionSize = partitionSize;
						return this;
					}

					private Int64 _offsetLag = Int64.Default;
					/// <summary>
					/// <para>The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 OffsetLag 
					{
						get => _offsetLag;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"OffsetLag does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_offsetLag = value;
						}
					}

					/// <summary>
					/// <para>The lag of the log's LEO w.r.t. partition's HW (if it is the current log for the partition) or current replica's LEO (if it is the future log for the partition)</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithOffsetLag(Int64 offsetLag)
					{
						OffsetLag = offsetLag;
						return this;
					}

					private Boolean _isFutureKey = Boolean.Default;
					/// <summary>
					/// <para>True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Boolean IsFutureKey 
					{
						get => _isFutureKey;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"IsFutureKey does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_isFutureKey = value;
						}
					}

					/// <summary>
					/// <para>True if this log is created by AlterReplicaLogDirsRequest and will replace the current log of the replica in the future.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public DescribeLogDirsPartition WithIsFutureKey(Boolean isFutureKey)
					{
						IsFutureKey = isFutureKey;
						return this;
					}
				}
			}
		}
	}

	public class DescribeProducersRequest : Message, IRespond<DescribeProducersResponse>
	{
		public DescribeProducersRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeProducersRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(61);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeProducersRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeProducersRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicRequest>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicRequest.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeProducersRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicRequest>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private TopicRequest[] _topicsCollection = Array.Empty<TopicRequest>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicRequest[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersRequest WithTopicsCollection(params Func<TopicRequest, TopicRequest>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicRequest()))
				.ToArray();
			return this;
		}

		internal TopicRequest CreateTopicRequest()
		{
			return new TopicRequest(Version);
		}

		public class TopicRequest : ISerialize
		{
			internal TopicRequest(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(PartitionIndexesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicRequest(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicRequest is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(PartitionIndexesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicRequest WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32[] _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The indexes of the partitions to list producers for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The indexes of the partitions to list producers for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicRequest WithPartitionIndexesCollection(Int32[] partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		public DescribeProducersResponse Respond()
			=> new DescribeProducersResponse(Version);
	}

	public class DescribeProducersResponse : Message
	{
		public DescribeProducersResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeProducersResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(61);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeProducersResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeProducersResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeProducersResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicResponse>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private TopicResponse[] _topicsCollection = Array.Empty<TopicResponse>();
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicResponse[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeProducersResponse WithTopicsCollection(params Func<TopicResponse, TopicResponse>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicResponse()))
				.ToArray();
			return this;
		}

		internal TopicResponse CreateTopicResponse()
		{
			return new TopicResponse(Version);
		}

		public class TopicResponse : ISerialize
		{
			internal TopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionResponse>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicResponse(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionResponse>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionResponse[] _partitionsCollection = Array.Empty<PartitionResponse>();
			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionResponse[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicResponse WithPartitionsCollection(params Func<PartitionResponse, PartitionResponse>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionResponse()))
					.ToArray();
				return this;
			}

			internal PartitionResponse CreatePartitionResponse()
			{
				return new PartitionResponse(Version);
			}

			public class PartitionResponse : ISerialize
			{
				internal PartitionResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorMessage.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<ProducerState>.From(ActiveProducersCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResponse(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ActiveProducersCollection = await Array<ProducerState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ProducerState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResponse is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<ProducerState>.From(ActiveProducersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private String? _errorMessage;
				/// <summary>
				/// <para>The partition error message, which may be null if no additional details are available</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The partition error message, which may be null if no additional details are available</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionResponse WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}

				private ProducerState[] _activeProducersCollection = Array.Empty<ProducerState>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ProducerState[] ActiveProducersCollection 
				{
					get => _activeProducersCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ActiveProducersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_activeProducersCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResponse WithActiveProducersCollection(params Func<ProducerState, ProducerState>[] createFields)
				{
					ActiveProducersCollection = createFields
						.Select(createField => createField(CreateProducerState()))
						.ToArray();
					return this;
				}

				internal ProducerState CreateProducerState()
				{
					return new ProducerState(Version);
				}

				public class ProducerState : ISerialize
				{
					internal ProducerState(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(0, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							ProducerId.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							ProducerEpoch.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							LastSequence.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							LastTimestamp.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							CoordinatorEpoch.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							CurrentTxnStartOffset.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<ProducerState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new ProducerState(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.ProducerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.LastSequence = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.LastTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.CoordinatorEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.CurrentTxnStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for ProducerState is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await LastSequence.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await LastTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await CoordinatorEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await CurrentTxnStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int64 _producerId = Int64.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 ProducerId 
					{
						get => _producerId;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_producerId = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public ProducerState WithProducerId(Int64 producerId)
					{
						ProducerId = producerId;
						return this;
					}

					private Int32 _producerEpoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 ProducerEpoch 
					{
						get => _producerEpoch;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_producerEpoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public ProducerState WithProducerEpoch(Int32 producerEpoch)
					{
						ProducerEpoch = producerEpoch;
						return this;
					}

					private Int32 _lastSequence = new Int32(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LastSequence 
					{
						get => _lastSequence;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"LastSequence does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_lastSequence = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public ProducerState WithLastSequence(Int32 lastSequence)
					{
						LastSequence = lastSequence;
						return this;
					}

					private Int64 _lastTimestamp = new Int64(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 LastTimestamp 
					{
						get => _lastTimestamp;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"LastTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_lastTimestamp = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public ProducerState WithLastTimestamp(Int64 lastTimestamp)
					{
						LastTimestamp = lastTimestamp;
						return this;
					}

					private Int32 _coordinatorEpoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 CoordinatorEpoch 
					{
						get => _coordinatorEpoch;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"CoordinatorEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_coordinatorEpoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public ProducerState WithCoordinatorEpoch(Int32 coordinatorEpoch)
					{
						CoordinatorEpoch = coordinatorEpoch;
						return this;
					}

					private Int64 _currentTxnStartOffset = new Int64(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 CurrentTxnStartOffset 
					{
						get => _currentTxnStartOffset;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"CurrentTxnStartOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_currentTxnStartOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public ProducerState WithCurrentTxnStartOffset(Int64 currentTxnStartOffset)
					{
						CurrentTxnStartOffset = currentTxnStartOffset;
						return this;
					}
				}
			}
		}
	}

	public class DescribeQuorumRequest : Message, IRespond<DescribeQuorumResponse>
	{
		public DescribeQuorumRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeQuorumRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(55);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeQuorumRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeQuorumRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeQuorumRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}
			}
		}

		public DescribeQuorumResponse Respond()
			=> new DescribeQuorumResponse(Version);
	}

	public class DescribeQuorumResponse : Message
	{
		public DescribeQuorumResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeQuorumResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(55);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeQuorumResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeQuorumResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeQuorumResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeQuorumResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						HighWatermark.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<ReplicaState>.From(CurrentVotersCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<ReplicaState>.From(ObserversCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.HighWatermark = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CurrentVotersCollection = await Array<ReplicaState>.FromReaderAsync(() => ReplicaState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ObserversCollection = await Array<ReplicaState>.FromReaderAsync(() => ReplicaState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await HighWatermark.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<ReplicaState>.From(CurrentVotersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<ReplicaState>.From(ObserversCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int64 _highWatermark = Int64.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 HighWatermark 
				{
					get => _highWatermark;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"HighWatermark does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_highWatermark = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithHighWatermark(Int64 highWatermark)
				{
					HighWatermark = highWatermark;
					return this;
				}

				private ReplicaState[] _currentVotersCollection = Array.Empty<ReplicaState>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReplicaState[] CurrentVotersCollection 
				{
					get => _currentVotersCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CurrentVotersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_currentVotersCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCurrentVotersCollection(ReplicaState[] currentVotersCollection)
				{
					CurrentVotersCollection = currentVotersCollection;
					return this;
				}

				private ReplicaState[] _observersCollection = Array.Empty<ReplicaState>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ReplicaState[] ObserversCollection 
				{
					get => _observersCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ObserversCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_observersCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithObserversCollection(ReplicaState[] observersCollection)
				{
					ObserversCollection = observersCollection;
					return this;
				}
			}
		}

		public class ReplicaState : ISerialize
		{
			internal ReplicaState(Int16 version)
			{
				if (version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ReplicaState does not support version {version}. Valid versions are: 0+");
				}

				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ReplicaId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					LogEndOffset.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ReplicaState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReplicaState(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.LogEndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReplicaState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ReplicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await LogEndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int32 _replicaId = Int32.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ReplicaId 
			{
				get => _replicaId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ReplicaId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_replicaId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaState WithReplicaId(Int32 replicaId)
			{
				ReplicaId = replicaId;
				return this;
			}

			private Int64 _logEndOffset = Int64.Default;
			/// <summary>
			/// <para>The last known log end offset of the follower or -1 if it is unknown</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 LogEndOffset 
			{
				get => _logEndOffset;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"LogEndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_logEndOffset = value;
				}
			}

			/// <summary>
			/// <para>The last known log end offset of the follower or -1 if it is unknown</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaState WithLogEndOffset(Int64 logEndOffset)
			{
				LogEndOffset = logEndOffset;
				return this;
			}
		}
	}

	public class DescribeTransactionsRequest : Message, IRespond<DescribeTransactionsResponse>
	{
		public DescribeTransactionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeTransactionsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(65);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeTransactionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeTransactionsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionalIdsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTransactionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(TransactionalIdsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String[] _transactionalIdsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Array of transactionalIds to include in describe results. If empty, then no results will be returned.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] TransactionalIdsCollection 
		{
			get => _transactionalIdsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalIdsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionalIdsCollection = value;
			}
		}

		/// <summary>
		/// <para>Array of transactionalIds to include in describe results. If empty, then no results will be returned.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsRequest WithTransactionalIdsCollection(String[] transactionalIdsCollection)
		{
			TransactionalIdsCollection = transactionalIdsCollection;
			return this;
		}

		public DescribeTransactionsResponse Respond()
			=> new DescribeTransactionsResponse(Version);
	}

	public class DescribeTransactionsResponse : Message
	{
		public DescribeTransactionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeTransactionsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(65);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeTransactionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeTransactionsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionStatesCollection = await Array<TransactionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TransactionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeTransactionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TransactionState>.From(TransactionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private TransactionState[] _transactionStatesCollection = Array.Empty<TransactionState>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TransactionState[] TransactionStatesCollection 
		{
			get => _transactionStatesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeTransactionsResponse WithTransactionStatesCollection(params Func<TransactionState, TransactionState>[] createFields)
		{
			TransactionStatesCollection = createFields
				.Select(createField => createField(CreateTransactionState()))
				.ToArray();
			return this;
		}

		internal TransactionState CreateTransactionState()
		{
			return new TransactionState(Version);
		}

		public class TransactionState : ISerialize
		{
			internal TransactionState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TransactionalId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TransactionState_.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TransactionTimeoutMs.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TransactionStartTimeMs.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProducerId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProducerEpoch.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<TopicData>.From(TopicsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TransactionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TransactionState(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionState_ = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionStartTimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicsCollection = (await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Topic);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TransactionState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionState_.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionStartTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<TopicData>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String _transactionalId = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionalId 
			{
				get => _transactionalId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionalId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionalId(String transactionalId)
			{
				TransactionalId = transactionalId;
				return this;
			}

			private String _transactionState = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionState_ 
			{
				get => _transactionState;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionState_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionState = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionState_(String transactionState)
			{
				TransactionState_ = transactionState;
				return this;
			}

			private Int32 _transactionTimeoutMs = Int32.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 TransactionTimeoutMs 
			{
				get => _transactionTimeoutMs;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionTimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionTimeoutMs = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionTimeoutMs(Int32 transactionTimeoutMs)
			{
				TransactionTimeoutMs = transactionTimeoutMs;
				return this;
			}

			private Int64 _transactionStartTimeMs = Int64.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 TransactionStartTimeMs 
			{
				get => _transactionStartTimeMs;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionStartTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionStartTimeMs = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionStartTimeMs(Int64 transactionStartTimeMs)
			{
				TransactionStartTimeMs = transactionStartTimeMs;
				return this;
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_producerId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private Int16 _producerEpoch = Int16.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ProducerEpoch 
			{
				get => _producerEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_producerEpoch = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithProducerEpoch(Int16 producerEpoch)
			{
				ProducerEpoch = producerEpoch;
				return this;
			}

			private Dictionary<String, TopicData> _topicsCollection = new Dictionary<String, TopicData>();
			/// <summary>
			/// <para>The set of partitions included in the current transaction (if active). When a transaction is preparing to commit or abort, this will include only partitions which do not have markers.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<String, TopicData> TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The set of partitions included in the current transaction (if active). When a transaction is preparing to commit or abort, this will include only partitions which do not have markers.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateTopicData()))
					.ToDictionary(field => field.Topic);
				return this;
			}

			internal TopicData CreateTopicData()
			{
				return new TopicData(Version);
			}

			public class TopicData : ISerialize
			{
				internal TopicData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Topic.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TopicData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _topic = String.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Topic 
				{
					get => _topic;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_topic = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithTopic(String topic)
				{
					Topic = topic;
					return this;
				}

				private Int32[] _partitionsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] PartitionsCollection 
				{
					get => _partitionsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TopicData WithPartitionsCollection(Int32[] partitionsCollection)
				{
					PartitionsCollection = partitionsCollection;
					return this;
				}
			}
		}
	}

	public class DescribeUserScramCredentialsRequest : Message, IRespond<DescribeUserScramCredentialsResponse>
	{
		public DescribeUserScramCredentialsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeUserScramCredentialsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(50);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeUserScramCredentialsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeUserScramCredentialsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.UsersCollection = await NullableArray<UserName>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UserName.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeUserScramCredentialsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<UserName>.From(UsersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private UserName[]? _usersCollection = Array.Empty<UserName>();
		/// <summary>
		/// <para>The users to describe, or null/empty to describe all users.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UserName[]? UsersCollection 
		{
			get => _usersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"UsersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"UsersCollection does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_usersCollection = value;
			}
		}

		/// <summary>
		/// <para>The users to describe, or null/empty to describe all users.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsRequest WithUsersCollection(params Func<UserName, UserName>[] createFields)
		{
			UsersCollection = createFields
				.Select(createField => createField(CreateUserName()))
				.ToArray();
			return this;
		}

		internal UserName CreateUserName()
		{
			return new UserName(Version);
		}

		public class UserName : ISerialize
		{
			internal UserName(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<UserName> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UserName(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UserName is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UserName WithName(String name)
			{
				Name = name;
				return this;
			}
		}

		public DescribeUserScramCredentialsResponse Respond()
			=> new DescribeUserScramCredentialsResponse(Version);
	}

	public class DescribeUserScramCredentialsResponse : Message
	{
		public DescribeUserScramCredentialsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"DescribeUserScramCredentialsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(50);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<DescribeUserScramCredentialsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new DescribeUserScramCredentialsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = await Array<DescribeUserScramCredentialsResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => DescribeUserScramCredentialsResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeUserScramCredentialsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<DescribeUserScramCredentialsResult>.From(ResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The message-level error code, 0 except for user authorization or infrastructure issues.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The message-level error code, 0 except for user authorization or infrastructure issues.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The message-level error message, if any.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The message-level error message, if any.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private DescribeUserScramCredentialsResult[] _resultsCollection = Array.Empty<DescribeUserScramCredentialsResult>();
		/// <summary>
		/// <para>The results for descriptions, one per user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResult[] ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for descriptions, one per user.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public DescribeUserScramCredentialsResponse WithResultsCollection(params Func<DescribeUserScramCredentialsResult, DescribeUserScramCredentialsResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateDescribeUserScramCredentialsResult()))
				.ToArray();
			return this;
		}

		internal DescribeUserScramCredentialsResult CreateDescribeUserScramCredentialsResult()
		{
			return new DescribeUserScramCredentialsResult(Version);
		}

		public class DescribeUserScramCredentialsResult : ISerialize
		{
			internal DescribeUserScramCredentialsResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					User.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<CredentialInfo>.From(CredentialInfosCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<DescribeUserScramCredentialsResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new DescribeUserScramCredentialsResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.User = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.CredentialInfosCollection = await Array<CredentialInfo>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => CredentialInfo.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for DescribeUserScramCredentialsResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await User.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<CredentialInfo>.From(CredentialInfosCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _user = String.Default;
			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String User 
			{
				get => _user;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"User does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_user = value;
				}
			}

			/// <summary>
			/// <para>The user name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithUser(String user)
			{
				User = user;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The user-level error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The user-level error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The user-level error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The user-level error message, if any.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private CredentialInfo[] _credentialInfosCollection = Array.Empty<CredentialInfo>();
			/// <summary>
			/// <para>The mechanism and related information associated with the user's SCRAM credentials.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public CredentialInfo[] CredentialInfosCollection 
			{
				get => _credentialInfosCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"CredentialInfosCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_credentialInfosCollection = value;
				}
			}

			/// <summary>
			/// <para>The mechanism and related information associated with the user's SCRAM credentials.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public DescribeUserScramCredentialsResult WithCredentialInfosCollection(params Func<CredentialInfo, CredentialInfo>[] createFields)
			{
				CredentialInfosCollection = createFields
					.Select(createField => createField(CreateCredentialInfo()))
					.ToArray();
				return this;
			}

			internal CredentialInfo CreateCredentialInfo()
			{
				return new CredentialInfo(Version);
			}

			public class CredentialInfo : ISerialize
			{
				internal CredentialInfo(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Mechanism.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Iterations.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<CredentialInfo> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new CredentialInfo(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Mechanism = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Iterations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for CredentialInfo is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Iterations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int8 _mechanism = Int8.Default;
				/// <summary>
				/// <para>The SCRAM mechanism.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 Mechanism 
				{
					get => _mechanism;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Mechanism does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_mechanism = value;
					}
				}

				/// <summary>
				/// <para>The SCRAM mechanism.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CredentialInfo WithMechanism(Int8 mechanism)
				{
					Mechanism = mechanism;
					return this;
				}

				private Int32 _iterations = Int32.Default;
				/// <summary>
				/// <para>The number of iterations used in the SCRAM credential.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Iterations 
				{
					get => _iterations;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Iterations does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_iterations = value;
					}
				}

				/// <summary>
				/// <para>The number of iterations used in the SCRAM credential.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public CredentialInfo WithIterations(Int32 iterations)
				{
					Iterations = iterations;
					return this;
				}
			}
		}
	}

	public class ElectLeadersRequest : Message, IRespond<ElectLeadersResponse>
	{
		public ElectLeadersRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ElectLeadersRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(43);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ElectLeadersRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ElectLeadersRequest(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ElectionType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicPartitionsCollection = (await NullableArray<TopicPartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicPartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value?.ToDictionary(field => field.Topic);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ElectLeadersRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ElectionType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<TopicPartitions>.From(TopicPartitionsCollection?.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int8 _electionType = Int8.Default;
		/// <summary>
		/// <para>Type of elections to conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int8 ElectionType 
		{
			get => _electionType;
			set 
			{
				if (Version.InRange(1, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ElectionType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
				}

				_electionType = value;
			}
		}

		/// <summary>
		/// <para>Type of elections to conduct for the partition. A value of '0' elects the preferred replica. A value of '1' elects the first live replica if there are no in-sync replica.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ElectLeadersRequest WithElectionType(Int8 electionType)
		{
			ElectionType = electionType;
			return this;
		}

		private Dictionary<String, TopicPartitions>? _topicPartitionsCollection = new Dictionary<String, TopicPartitions>();
		/// <summary>
		/// <para>The topic partitions to elect leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, TopicPartitions>? TopicPartitionsCollection 
		{
			get => _topicPartitionsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicPartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TopicPartitionsCollection does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_topicPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topic partitions to elect leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersRequest WithTopicPartitionsCollection(params Func<TopicPartitions, TopicPartitions>[] createFields)
		{
			TopicPartitionsCollection = createFields
				.Select(createField => createField(CreateTopicPartitions()))
				.ToDictionary(field => field.Topic);
			return this;
		}

		internal TopicPartitions CreateTopicPartitions()
		{
			return new TopicPartitions(Version);
		}

		public class TopicPartitions : ISerialize
		{
			internal TopicPartitions(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicPartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicPartitions(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicPartitions is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The name of a topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>The name of a topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Int32[] _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions of this topic whose leader should be elected.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions of this topic whose leader should be elected.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicPartitions WithPartitionsCollection(Int32[] partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>The time in ms to wait for the election to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the election to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public ElectLeadersRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		public ElectLeadersResponse Respond()
			=> new ElectLeadersResponse(Version);
	}

	public class ElectLeadersResponse : Message
	{
		public ElectLeadersResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ElectLeadersResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(43);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ElectLeadersResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ElectLeadersResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ReplicaElectionResultsCollection = await Array<ReplicaElectionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ReplicaElectionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ElectLeadersResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ReplicaElectionResult>.From(ReplicaElectionResultsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(1, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ElectLeadersResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private ReplicaElectionResult[] _replicaElectionResultsCollection = Array.Empty<ReplicaElectionResult>();
		/// <summary>
		/// <para>The election results, or an empty array if the requester did not have permission and the request asks for all partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ReplicaElectionResult[] ReplicaElectionResultsCollection 
		{
			get => _replicaElectionResultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ReplicaElectionResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_replicaElectionResultsCollection = value;
			}
		}

		/// <summary>
		/// <para>The election results, or an empty array if the requester did not have permission and the request asks for all partitions.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ElectLeadersResponse WithReplicaElectionResultsCollection(params Func<ReplicaElectionResult, ReplicaElectionResult>[] createFields)
		{
			ReplicaElectionResultsCollection = createFields
				.Select(createField => createField(CreateReplicaElectionResult()))
				.ToArray();
			return this;
		}

		internal ReplicaElectionResult CreateReplicaElectionResult()
		{
			return new ReplicaElectionResult(Version);
		}

		public class ReplicaElectionResult : ISerialize
		{
			internal ReplicaElectionResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionResult>.From(PartitionResultCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ReplicaElectionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ReplicaElectionResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionResultCollection = await Array<PartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ReplicaElectionResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionResult>.From(PartitionResultCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaElectionResult WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private PartitionResult[] _partitionResultCollection = Array.Empty<PartitionResult>();
			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionResult[] PartitionResultCollection 
			{
				get => _partitionResultCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionResultCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionResultCollection = value;
				}
			}

			/// <summary>
			/// <para>The results for each partition</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ReplicaElectionResult WithPartitionResultCollection(params Func<PartitionResult, PartitionResult>[] createFields)
			{
				PartitionResultCollection = createFields
					.Select(createField => createField(CreatePartitionResult()))
					.ToArray();
				return this;
			}

			internal PartitionResult CreatePartitionResult()
			{
				return new PartitionResult(Version);
			}

			public class PartitionResult : ISerialize
			{
				internal PartitionResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorMessage.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionResult(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionResult is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionId = Int32.Default;
				/// <summary>
				/// <para>The partition id</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionId 
				{
					get => _partitionId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionId = value;
					}
				}

				/// <summary>
				/// <para>The partition id</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithPartitionId(Int32 partitionId)
				{
					PartitionId = partitionId;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The result error, or zero if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The result error, or zero if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private String? _errorMessage;
				/// <summary>
				/// <para>The result message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The result message, or null if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionResult WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}
	}

	public class EndQuorumEpochRequest : Message, IRespond<EndQuorumEpochResponse>
	{
		public EndQuorumEpochRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"EndQuorumEpochRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(54);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<EndQuorumEpochRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndQuorumEpochRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndQuorumEpochRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _clusterId;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public EndQuorumEpochRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, -1);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(PreferredSuccessorsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PreferredSuccessorsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(PreferredSuccessorsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The current leader ID that is resigning</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The current leader ID that is resigning</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The current epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int32[] _preferredSuccessorsCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>A sorted list of preferred successors to start the election</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] PreferredSuccessorsCollection 
				{
					get => _preferredSuccessorsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PreferredSuccessorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_preferredSuccessorsCollection = value;
					}
				}

				/// <summary>
				/// <para>A sorted list of preferred successors to start the election</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPreferredSuccessorsCollection(Int32[] preferredSuccessorsCollection)
				{
					PreferredSuccessorsCollection = preferredSuccessorsCollection;
					return this;
				}
			}
		}

		public EndQuorumEpochResponse Respond()
			=> new EndQuorumEpochResponse(Version);
	}

	public class EndQuorumEpochResponse : Message
	{
		public EndQuorumEpochResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"EndQuorumEpochResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(54);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<EndQuorumEpochResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndQuorumEpochResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndQuorumEpochResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndQuorumEpochResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, -1);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}
	}

	public class EndTxnRequest : Message, IRespond<EndTxnResponse>
	{
		public EndTxnRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"EndTxnRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(26);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<EndTxnRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndTxnRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Committed = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndTxnRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Committed.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The ID of the transaction to end.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the transaction to end.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>The producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>The current epoch associated with the producer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current epoch associated with the producer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private Boolean _committed = Boolean.Default;
		/// <summary>
		/// <para>True if the transaction was committed, false if it was aborted.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean Committed 
		{
			get => _committed;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Committed does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_committed = value;
			}
		}

		/// <summary>
		/// <para>True if the transaction was committed, false if it was aborted.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnRequest WithCommitted(Boolean committed)
		{
			Committed = committed;
			return this;
		}

		public EndTxnResponse Respond()
			=> new EndTxnResponse(Version);
	}

	public class EndTxnResponse : Message
	{
		public EndTxnResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"EndTxnResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(26);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<EndTxnResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EndTxnResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EndTxnResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EndTxnResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class EnvelopeRequest : Message, IRespond<EnvelopeResponse>
	{
		public EnvelopeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"EnvelopeRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(58);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<EnvelopeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EnvelopeRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RequestData = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RequestPrincipal = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClientHostAddress = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EnvelopeRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await RequestData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await RequestPrincipal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ClientHostAddress.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Bytes _requestData = Bytes.Default;
		/// <summary>
		/// <para>The embedded request header and data.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes RequestData 
		{
			get => _requestData;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RequestData does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_requestData = value;
			}
		}

		/// <summary>
		/// <para>The embedded request header and data.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeRequest WithRequestData(Bytes requestData)
		{
			RequestData = requestData;
			return this;
		}

		private Bytes? _requestPrincipal;
		/// <summary>
		/// <para>Value of the initial client principal when the request is redirected by a broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes? RequestPrincipal 
		{
			get => _requestPrincipal;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RequestPrincipal does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"RequestPrincipal does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_requestPrincipal = value;
			}
		}

		/// <summary>
		/// <para>Value of the initial client principal when the request is redirected by a broker.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeRequest WithRequestPrincipal(Bytes? requestPrincipal)
		{
			RequestPrincipal = requestPrincipal;
			return this;
		}

		private Bytes _clientHostAddress = Bytes.Default;
		/// <summary>
		/// <para>The original client's address in bytes.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes ClientHostAddress 
		{
			get => _clientHostAddress;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClientHostAddress does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_clientHostAddress = value;
			}
		}

		/// <summary>
		/// <para>The original client's address in bytes.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeRequest WithClientHostAddress(Bytes clientHostAddress)
		{
			ClientHostAddress = clientHostAddress;
			return this;
		}

		public EnvelopeResponse Respond()
			=> new EnvelopeResponse(Version);
	}

	public class EnvelopeResponse : Message
	{
		public EnvelopeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"EnvelopeResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(58);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<EnvelopeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new EnvelopeResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponseData = await NullableBytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for EnvelopeResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ResponseData.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Bytes? _responseData;
		/// <summary>
		/// <para>The embedded response header and data.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public Bytes? ResponseData 
		{
			get => _responseData;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponseData does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ResponseData does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_responseData = value;
			}
		}

		/// <summary>
		/// <para>The embedded response header and data.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public EnvelopeResponse WithResponseData(Bytes? responseData)
		{
			ResponseData = responseData;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public EnvelopeResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class ExpireDelegationTokenRequest : Message, IRespond<ExpireDelegationTokenResponse>
	{
		public ExpireDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ExpireDelegationTokenRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(40);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ExpireDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ExpireDelegationTokenRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ExpiryTimePeriodMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ExpireDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ExpiryTimePeriodMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Bytes _hmac = Bytes.Default;
		/// <summary>
		/// <para>The HMAC of the delegation token to be expired.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Hmac 
		{
			get => _hmac;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Hmac does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_hmac = value;
			}
		}

		/// <summary>
		/// <para>The HMAC of the delegation token to be expired.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenRequest WithHmac(Bytes hmac)
		{
			Hmac = hmac;
			return this;
		}

		private Int64 _expiryTimePeriodMs = Int64.Default;
		/// <summary>
		/// <para>The expiry time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimePeriodMs 
		{
			get => _expiryTimePeriodMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ExpiryTimePeriodMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_expiryTimePeriodMs = value;
			}
		}

		/// <summary>
		/// <para>The expiry time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenRequest WithExpiryTimePeriodMs(Int64 expiryTimePeriodMs)
		{
			ExpiryTimePeriodMs = expiryTimePeriodMs;
			return this;
		}

		public ExpireDelegationTokenResponse Respond()
			=> new ExpireDelegationTokenResponse(Version);
	}

	public class ExpireDelegationTokenResponse : Message
	{
		public ExpireDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ExpireDelegationTokenResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(40);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ExpireDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ExpireDelegationTokenResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ExpiryTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ExpireDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ExpiryTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _expiryTimestampMs = Int64.Default;
		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimestampMs 
		{
			get => _expiryTimestampMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ExpiryTimestampMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_expiryTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenResponse WithExpiryTimestampMs(Int64 expiryTimestampMs)
		{
			ExpiryTimestampMs = expiryTimestampMs;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ExpireDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class FetchRequest : Message, IRespond<FetchResponse>
	{
		public FetchRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"FetchRequest does not support version {version}. Valid versions are: 0-13");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(12, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(1);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(13);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<FetchRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MaxWaitMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MinBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.MaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(4, 2147483647)) 
			{
				instance.IsolationLevel = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.SessionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.SessionEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<FetchTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.ForgottenTopicsDataCollection = await Array<ForgottenTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ForgottenTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(11, 2147483647)) 
			{
				instance.RackId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version.InRange(12, 2147483647)) 
							{
								instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							}
							else
								throw new InvalidOperationException($"Field ClusterId is not supported for version {instance.Version}");
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(12, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ReplicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MaxWaitMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MinBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await MaxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(4, 2147483647)) 
			{
				await IsolationLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await SessionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await SessionEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<FetchTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await Array<ForgottenTopic>.From(ForgottenTopicsDataCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(11, 2147483647)) 
			{
				await RackId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _clusterId;
		/// <summary>
		/// <para>The clusterId if known. This is used to validate metadata fetches prior to broker registration.</para>
		/// <para>Versions: 12+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(12, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 12+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The clusterId if known. This is used to validate metadata fetches prior to broker registration.</para>
		/// <para>Versions: 12+</para>
		/// <para>Default: null</para>
		/// </summary>
		public FetchRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _replicaId = Int32.Default;
		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ReplicaId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Int32 _maxWaitMs = Int32.Default;
		/// <summary>
		/// <para>The maximum time in milliseconds to wait for the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MaxWaitMs 
		{
			get => _maxWaitMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MaxWaitMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_maxWaitMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum time in milliseconds to wait for the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithMaxWaitMs(Int32 maxWaitMs)
		{
			MaxWaitMs = maxWaitMs;
			return this;
		}

		private Int32 _minBytes = Int32.Default;
		/// <summary>
		/// <para>The minimum bytes to accumulate in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 MinBytes 
		{
			get => _minBytes;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MinBytes does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_minBytes = value;
			}
		}

		/// <summary>
		/// <para>The minimum bytes to accumulate in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithMinBytes(Int32 minBytes)
		{
			MinBytes = minBytes;
			return this;
		}

		private Int32 _maxBytes = new Int32(0x7fffffff);
		/// <summary>
		/// <para>The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public Int32 MaxBytes 
		{
			get => _maxBytes;
			set 
			{
				_maxBytes = value;
			}
		}

		/// <summary>
		/// <para>The maximum bytes to fetch.  See KIP-74 for cases where this limit may not be honored.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public FetchRequest WithMaxBytes(Int32 maxBytes)
		{
			MaxBytes = maxBytes;
			return this;
		}

		private Int8 _isolationLevel = new Int8(0);
		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int8 IsolationLevel 
		{
			get => _isolationLevel;
			set 
			{
				_isolationLevel = value;
			}
		}

		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FetchRequest WithIsolationLevel(Int8 isolationLevel)
		{
			IsolationLevel = isolationLevel;
			return this;
		}

		private Int32 _sessionId = new Int32(0);
		/// <summary>
		/// <para>The fetch session ID.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int32 SessionId 
		{
			get => _sessionId;
			set 
			{
				_sessionId = value;
			}
		}

		/// <summary>
		/// <para>The fetch session ID.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FetchRequest WithSessionId(Int32 sessionId)
		{
			SessionId = sessionId;
			return this;
		}

		private Int32 _sessionEpoch = new Int32(-1);
		/// <summary>
		/// <para>The fetch session epoch, which is used for ordering requests in a session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 SessionEpoch 
		{
			get => _sessionEpoch;
			set 
			{
				_sessionEpoch = value;
			}
		}

		/// <summary>
		/// <para>The fetch session epoch, which is used for ordering requests in a session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public FetchRequest WithSessionEpoch(Int32 sessionEpoch)
		{
			SessionEpoch = sessionEpoch;
			return this;
		}

		private FetchTopic[] _topicsCollection = Array.Empty<FetchTopic>();
		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchRequest WithTopicsCollection(params Func<FetchTopic, FetchTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateFetchTopic()))
				.ToArray();
			return this;
		}

		internal FetchTopic CreateFetchTopic()
		{
			return new FetchTopic(Version);
		}

		public class FetchTopic : ISerialize
		{
			internal FetchTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(12, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 12) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(13, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<FetchPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<FetchTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FetchTopic(version);
				if (instance.Version.InRange(0, 12)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(13, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<FetchPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 12)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(13, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<FetchPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public FetchTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public FetchTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private FetchPartition[] _partitionsCollection = Array.Empty<FetchPartition>();
			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchTopic WithPartitionsCollection(params Func<FetchPartition, FetchPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateFetchPartition()))
					.ToArray();
				return this;
			}

			internal FetchPartition CreateFetchPartition()
			{
				return new FetchPartition(Version);
			}

			public class FetchPartition : ISerialize
			{
				internal FetchPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(12, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Partition.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(9, 2147483647) ? 
						CurrentLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						FetchOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(12, 2147483647) ? 
						LastFetchedEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						LogStartOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						PartitionMaxBytes.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<FetchPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new FetchPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(9, 2147483647)) 
					{
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.FetchOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(12, 2147483647)) 
					{
						instance.LastFetchedEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.LogStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionMaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(9, 2147483647)) 
					{
						await CurrentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await FetchOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(12, 2147483647)) 
					{
						await LastFetchedEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await LogStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionMaxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Partition does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _currentLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The current leader epoch of the partition.</para>
				/// <para>Versions: 9+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current leader epoch of the partition.</para>
				/// <para>Versions: 9+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public FetchPartition WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private Int64 _fetchOffset = Int64.Default;
				/// <summary>
				/// <para>The message offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 FetchOffset 
				{
					get => _fetchOffset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"FetchOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_fetchOffset = value;
					}
				}

				/// <summary>
				/// <para>The message offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithFetchOffset(Int64 fetchOffset)
				{
					FetchOffset = fetchOffset;
					return this;
				}

				private Int32 _lastFetchedEpoch = new Int32(-1);
				/// <summary>
				/// <para>The epoch of the last fetched record or -1 if there is none</para>
				/// <para>Versions: 12+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LastFetchedEpoch 
				{
					get => _lastFetchedEpoch;
					set 
					{
						if (Version.InRange(12, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LastFetchedEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
						}

						_lastFetchedEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch of the last fetched record or -1 if there is none</para>
				/// <para>Versions: 12+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public FetchPartition WithLastFetchedEpoch(Int32 lastFetchedEpoch)
				{
					LastFetchedEpoch = lastFetchedEpoch;
					return this;
				}

				private Int64 _logStartOffset = new Int64(-1);
				/// <summary>
				/// <para>The earliest available offset of the follower replica.  The field is only used when the request is sent by the follower.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogStartOffset 
				{
					get => _logStartOffset;
					set 
					{
						_logStartOffset = value;
					}
				}

				/// <summary>
				/// <para>The earliest available offset of the follower replica.  The field is only used when the request is sent by the follower.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public FetchPartition WithLogStartOffset(Int64 logStartOffset)
				{
					LogStartOffset = logStartOffset;
					return this;
				}

				private Int32 _partitionMaxBytes = Int32.Default;
				/// <summary>
				/// <para>The maximum bytes to fetch from this partition.  See KIP-74 for cases where this limit may not be honored.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionMaxBytes 
				{
					get => _partitionMaxBytes;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionMaxBytes does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionMaxBytes = value;
					}
				}

				/// <summary>
				/// <para>The maximum bytes to fetch from this partition.  See KIP-74 for cases where this limit may not be honored.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public FetchPartition WithPartitionMaxBytes(Int32 partitionMaxBytes)
				{
					PartitionMaxBytes = partitionMaxBytes;
					return this;
				}
			}
		}

		private ForgottenTopic[] _forgottenTopicsDataCollection = Array.Empty<ForgottenTopic>();
		/// <summary>
		/// <para>In an incremental fetch request, the partitions to remove.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public ForgottenTopic[] ForgottenTopicsDataCollection 
		{
			get => _forgottenTopicsDataCollection;
			set 
			{
				if (Version.InRange(7, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ForgottenTopicsDataCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");
				}

				_forgottenTopicsDataCollection = value;
			}
		}

		/// <summary>
		/// <para>In an incremental fetch request, the partitions to remove.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public FetchRequest WithForgottenTopicsDataCollection(params Func<ForgottenTopic, ForgottenTopic>[] createFields)
		{
			ForgottenTopicsDataCollection = createFields
				.Select(createField => createField(CreateForgottenTopic()))
				.ToArray();
			return this;
		}

		internal ForgottenTopic CreateForgottenTopic()
		{
			return new ForgottenTopic(Version);
		}

		public class ForgottenTopic : ISerialize
		{
			internal ForgottenTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(12, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(7, 12) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(13, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(7, 2147483647) ? 
					Array<Int32>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ForgottenTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ForgottenTopic(version);
				if (instance.Version.InRange(7, 12)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(13, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(7, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ForgottenTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(7, 12)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(13, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(7, 2147483647)) 
				{
					await Array<Int32>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The partition name.</para>
			/// <para>Versions: 7-12</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The partition name.</para>
			/// <para>Versions: 7-12</para>
			/// </summary>
			public ForgottenTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public ForgottenTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Int32[] _partitionsCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions indexes to forget.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public Int32[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(7, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions indexes to forget.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public ForgottenTopic WithPartitionsCollection(Int32[] partitionsCollection)
			{
				PartitionsCollection = partitionsCollection;
				return this;
			}
		}

		private String _rackId = new String();
		/// <summary>
		/// <para>Rack ID of the consumer making this request</para>
		/// <para>Versions: 11+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public String RackId 
		{
			get => _rackId;
			set 
			{
				_rackId = value;
			}
		}

		/// <summary>
		/// <para>Rack ID of the consumer making this request</para>
		/// <para>Versions: 11+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public FetchRequest WithRackId(String rackId)
		{
			RackId = rackId;
			return this;
		}

		public FetchResponse Respond()
			=> new FetchResponse(Version);
	}

	public class FetchResponse : Message
	{
		public FetchResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"FetchResponse does not support version {version}. Valid versions are: 0-13");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(12, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(1);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(13);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<FetchResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.SessionId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponsesCollection = await Array<FetchableTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FetchableTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await SessionId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<FetchableTopicResponse>.From(ResponsesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public FetchResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 7+</para>
		/// </summary>
		public FetchResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int32 _sessionId = new Int32(0);
		/// <summary>
		/// <para>The fetch session ID, or 0 if this is not part of a fetch session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int32 SessionId 
		{
			get => _sessionId;
			set 
			{
				if (Version.InRange(7, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"SessionId does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");
				}

				_sessionId = value;
			}
		}

		/// <summary>
		/// <para>The fetch session ID, or 0 if this is not part of a fetch session.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FetchResponse WithSessionId(Int32 sessionId)
		{
			SessionId = sessionId;
			return this;
		}

		private FetchableTopicResponse[] _responsesCollection = Array.Empty<FetchableTopicResponse>();
		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchableTopicResponse[] ResponsesCollection 
		{
			get => _responsesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The response topics.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchResponse WithResponsesCollection(params Func<FetchableTopicResponse, FetchableTopicResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(CreateFetchableTopicResponse()))
				.ToArray();
			return this;
		}

		internal FetchableTopicResponse CreateFetchableTopicResponse()
		{
			return new FetchableTopicResponse(Version);
		}

		public class FetchableTopicResponse : ISerialize
		{
			internal FetchableTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(12, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 12) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(13, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<FetchableTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FetchableTopicResponse(version);
				if (instance.Version.InRange(0, 12)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(13, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchableTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 12)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(13, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-12</para>
			/// </summary>
			public FetchableTopicResponse WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 13+</para>
			/// </summary>
			public FetchableTopicResponse WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The topic partitions.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FetchableTopicResponse WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(12, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						HighWatermark.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(4, 2147483647) ? 
						LastStableOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						LogStartOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(12, 2147483647) ? 
						DivergingEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(12, 2147483647) ? 
						CurrentLeader.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(12, 2147483647) ? 
						SnapshotId_.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(4, 2147483647) ? 
						NullableArray<AbortedTransaction>.From(AbortedTransactionsCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(11, 2147483647) ? 
						PreferredReadReplica.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Records.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.HighWatermark = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(4, 2147483647)) 
					{
						instance.LastStableOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.LogStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(4, 2147483647)) 
					{
						instance.AbortedTransactionsCollection = await NullableArray<AbortedTransaction>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AbortedTransaction.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(11, 2147483647)) 
					{
						instance.PreferredReadReplica = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Records = await NullableRecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								case 0:
									if (instance.Version.InRange(12, 2147483647)) 
									{
										instance.DivergingEpoch = await EpochEndOffset.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									}
									else
										throw new InvalidOperationException($"Field DivergingEpoch is not supported for version {instance.Version}");
									break;

								case 1:
									if (instance.Version.InRange(12, 2147483647)) 
									{
										instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									}
									else
										throw new InvalidOperationException($"Field CurrentLeader is not supported for version {instance.Version}");
									break;

								case 2:
									if (instance.Version.InRange(12, 2147483647)) 
									{
										instance.SnapshotId_ = await SnapshotId.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									}
									else
										throw new InvalidOperationException($"Field SnapshotId_ is not supported for version {instance.Version}");
									break;
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await HighWatermark.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(4, 2147483647)) 
					{
						await LastStableOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await LogStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(12, 2147483647)) 
					{
						await DivergingEpoch.WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(12, 2147483647)) 
					{
						await CurrentLeader.WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(12, 2147483647)) 
					{
						await SnapshotId_.WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(4, 2147483647)) 
					{
						await NullableArray<AbortedTransaction>.From(AbortedTransactionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(11, 2147483647)) 
					{
						await PreferredReadReplica.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Records.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int64 _highWatermark = Int64.Default;
				/// <summary>
				/// <para>The current high water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 HighWatermark 
				{
					get => _highWatermark;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"HighWatermark does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_highWatermark = value;
					}
				}

				/// <summary>
				/// <para>The current high water mark.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithHighWatermark(Int64 highWatermark)
				{
					HighWatermark = highWatermark;
					return this;
				}

				private Int64 _lastStableOffset = new Int64(-1);
				/// <summary>
				/// <para>The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LastStableOffset 
				{
					get => _lastStableOffset;
					set 
					{
						_lastStableOffset = value;
					}
				}

				/// <summary>
				/// <para>The last stable offset (or LSO) of the partition. This is the last offset such that the state of all transactional records prior to this offset have been decided (ABORTED or COMMITTED)</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionData WithLastStableOffset(Int64 lastStableOffset)
				{
					LastStableOffset = lastStableOffset;
					return this;
				}

				private Int64 _logStartOffset = new Int64(-1);
				/// <summary>
				/// <para>The current log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogStartOffset 
				{
					get => _logStartOffset;
					set 
					{
						_logStartOffset = value;
					}
				}

				/// <summary>
				/// <para>The current log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionData WithLogStartOffset(Int64 logStartOffset)
				{
					LogStartOffset = logStartOffset;
					return this;
				}

				private EpochEndOffset _divergingEpoch = default!;
				/// <summary>
				/// <para>In case divergence is detected based on the `LastFetchedEpoch` and `FetchOffset` in the request, this field indicates the largest epoch and its end offset such that subsequent records are known to diverge</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public EpochEndOffset DivergingEpoch 
				{
					get => _divergingEpoch;
					set 
					{
						if (Version.InRange(12, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"DivergingEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
						}

						_divergingEpoch = value;
					}
				}

				/// <summary>
				/// <para>In case divergence is detected based on the `LastFetchedEpoch` and `FetchOffset` in the request, this field indicates the largest epoch and its end offset such that subsequent records are known to diverge</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public PartitionData WithDivergingEpochs(Func<EpochEndOffset, EpochEndOffset> createField)
				{
					DivergingEpoch = createField(CreateEpochEndOffset());
					return this;
				}

				internal EpochEndOffset CreateEpochEndOffset()
				{
					return new EpochEndOffset(Version);
				}

				public class EpochEndOffset : ISerialize
				{
					internal EpochEndOffset(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(12, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(12, 2147483647) ? 
							Epoch.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(12, 2147483647) ? 
							EndOffset.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<EpochEndOffset> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new EpochEndOffset(version);
						if (instance.Version.InRange(12, 2147483647)) 
						{
							instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(12, 2147483647)) 
						{
							instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for EpochEndOffset is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(12, 2147483647)) 
						{
							await Epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(12, 2147483647)) 
						{
							await EndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _epoch = new Int32(-1);
					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						set 
						{
							if (Version.InRange(12, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Epoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
							}

							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public EpochEndOffset WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}

					private Int64 _endOffset = new Int64(-1);
					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						set 
						{
							if (Version.InRange(12, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"EndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
							}

							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public EpochEndOffset WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}
				}

				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 12+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					set 
					{
						if (Version.InRange(12, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CurrentLeader does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
						}

						_currentLeader = value;
					}
				}

				/// <summary>
				/// <para>Versions: 12+</para>
				/// </summary>
				public PartitionData WithCurrentLeaders(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(CreateLeaderIdAndEpoch());
					return this;
				}

				internal LeaderIdAndEpoch CreateLeaderIdAndEpoch()
				{
					return new LeaderIdAndEpoch(Version);
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(12, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(12, 2147483647) ? 
							LeaderId.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(12, 2147483647) ? 
							LeaderEpoch.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						if (instance.Version.InRange(12, 2147483647)) 
						{
							instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(12, 2147483647)) 
						{
							instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(12, 2147483647)) 
						{
							await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(12, 2147483647)) 
						{
							await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _leaderId = new Int32(-1);
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						set 
						{
							if (Version.InRange(12, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
							}

							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = new Int32(-1);
					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						set 
						{
							if (Version.InRange(12, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
							}

							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 12+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}

				private SnapshotId _snapshotId = default!;
				/// <summary>
				/// <para>In the case of fetching an offset less than the LogStartOffset, this is the end offset and epoch that should be used in the FetchSnapshot request.</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public SnapshotId SnapshotId_ 
				{
					get => _snapshotId;
					set 
					{
						if (Version.InRange(12, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"SnapshotId_ does not support version {Version} and has been defined as not ignorable. Supported versions: 12+");
						}

						_snapshotId = value;
					}
				}

				/// <summary>
				/// <para>In the case of fetching an offset less than the LogStartOffset, this is the end offset and epoch that should be used in the FetchSnapshot request.</para>
				/// <para>Versions: 12+</para>
				/// </summary>
				public PartitionData WithSnapshotId_s(Func<SnapshotId, SnapshotId> createField)
				{
					SnapshotId_ = createField(CreateSnapshotId());
					return this;
				}

				internal SnapshotId CreateSnapshotId()
				{
					return new SnapshotId(Version);
				}

				public class SnapshotId : ISerialize
				{
					internal SnapshotId(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(12, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							EndOffset.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							Epoch.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<SnapshotId> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new SnapshotId(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotId is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await EndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await Epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int64 _endOffset = new Int64(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"EndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public SnapshotId WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}

					private Int32 _epoch = new Int32(-1);
					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Epoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public SnapshotId WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}
				}

				private AbortedTransaction[]? _abortedTransactionsCollection = Array.Empty<AbortedTransaction>();
				/// <summary>
				/// <para>The aborted transactions.</para>
				/// <para>Versions: 4+</para>
				/// </summary>
				public AbortedTransaction[]? AbortedTransactionsCollection 
				{
					get => _abortedTransactionsCollection;
					set 
					{
						if (Version.InRange(4, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"AbortedTransactionsCollection does not support null for version {Version}. Supported versions for null value: 4+");
						}

						_abortedTransactionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The aborted transactions.</para>
				/// <para>Versions: 4+</para>
				/// </summary>
				public PartitionData WithAbortedTransactionsCollection(params Func<AbortedTransaction, AbortedTransaction>[] createFields)
				{
					AbortedTransactionsCollection = createFields
						.Select(createField => createField(CreateAbortedTransaction()))
						.ToArray();
					return this;
				}

				internal AbortedTransaction CreateAbortedTransaction()
				{
					return new AbortedTransaction(Version);
				}

				public class AbortedTransaction : ISerialize
				{
					internal AbortedTransaction(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(12, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(4, 2147483647) ? 
							ProducerId.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(4, 2147483647) ? 
							FirstOffset.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<AbortedTransaction> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new AbortedTransaction(version);
						if (instance.Version.InRange(4, 2147483647)) 
						{
							instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(4, 2147483647)) 
						{
							instance.FirstOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for AbortedTransaction is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(4, 2147483647)) 
						{
							await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(4, 2147483647)) 
						{
							await FirstOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int64 _producerId = Int64.Default;
					/// <summary>
					/// <para>The producer id associated with the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public Int64 ProducerId 
					{
						get => _producerId;
						set 
						{
							if (Version.InRange(4, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
							}

							_producerId = value;
						}
					}

					/// <summary>
					/// <para>The producer id associated with the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public AbortedTransaction WithProducerId(Int64 producerId)
					{
						ProducerId = producerId;
						return this;
					}

					private Int64 _firstOffset = Int64.Default;
					/// <summary>
					/// <para>The first offset in the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public Int64 FirstOffset 
					{
						get => _firstOffset;
						set 
						{
							if (Version.InRange(4, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"FirstOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
							}

							_firstOffset = value;
						}
					}

					/// <summary>
					/// <para>The first offset in the aborted transaction.</para>
					/// <para>Versions: 4+</para>
					/// </summary>
					public AbortedTransaction WithFirstOffset(Int64 firstOffset)
					{
						FirstOffset = firstOffset;
						return this;
					}
				}

				private Int32 _preferredReadReplica = new Int32(-1);
				/// <summary>
				/// <para>The preferred read replica for the consumer to use on its next fetch request</para>
				/// <para>Versions: 11+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 PreferredReadReplica 
				{
					get => _preferredReadReplica;
					set 
					{
						if (Version.InRange(11, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PreferredReadReplica does not support version {Version} and has been defined as not ignorable. Supported versions: 11+");
						}

						_preferredReadReplica = value;
					}
				}

				/// <summary>
				/// <para>The preferred read replica for the consumer to use on its next fetch request</para>
				/// <para>Versions: 11+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionData WithPreferredReadReplica(Int32 preferredReadReplica)
				{
					PreferredReadReplica = preferredReadReplica;
					return this;
				}

				private Records.RecordBatch? _records;
				/// <summary>
				/// <para>The record data.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Records.RecordBatch? Records 
				{
					get => _records;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Records does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Records does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_records = value;
					}
				}

				/// <summary>
				/// <para>The record data.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithRecords(Records.RecordBatch? records)
				{
					Records = records;
					return this;
				}
			}
		}
	}

	public class FetchSnapshotRequest : Message, IRespond<FetchSnapshotResponse>
	{
		public FetchSnapshotRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"FetchSnapshotRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(59);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<FetchSnapshotRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchSnapshotRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MaxBytes = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						case 0:
							if (instance.Version.InRange(0, 2147483647)) 
							{
								instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
							}
							else
								throw new InvalidOperationException($"Field ClusterId is not supported for version {instance.Version}");
							break;
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchSnapshotRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ReplicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MaxBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicSnapshot>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _clusterId;
		/// <summary>
		/// <para>The clusterId if known, this is used to validate metadata fetches prior to broker registration</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The clusterId if known, this is used to validate metadata fetches prior to broker registration</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public FetchSnapshotRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _replicaId = new Int32(-1);
		/// <summary>
		/// <para>The broker ID of the follower</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ReplicaId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the follower</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public FetchSnapshotRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Int32 _maxBytes = new Int32(0x7fffffff);
		/// <summary>
		/// <para>The maximum bytes to fetch from all of the snapshots</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public Int32 MaxBytes 
		{
			get => _maxBytes;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MaxBytes does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_maxBytes = value;
			}
		}

		/// <summary>
		/// <para>The maximum bytes to fetch from all of the snapshots</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 0x7fffffff</para>
		/// </summary>
		public FetchSnapshotRequest WithMaxBytes(Int32 maxBytes)
		{
			MaxBytes = maxBytes;
			return this;
		}

		private TopicSnapshot[] _topicsCollection = Array.Empty<TopicSnapshot>();
		/// <summary>
		/// <para>The topics to fetch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicSnapshot[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotRequest WithTopicsCollection(params Func<TopicSnapshot, TopicSnapshot>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicSnapshot()))
				.ToArray();
			return this;
		}

		internal TopicSnapshot CreateTopicSnapshot()
		{
			return new TopicSnapshot(Version);
		}

		public class TopicSnapshot : ISerialize
		{
			internal TopicSnapshot(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionSnapshot>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicSnapshot(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicSnapshot is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionSnapshot>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionSnapshot[] _partitionsCollection = Array.Empty<PartitionSnapshot>();
			/// <summary>
			/// <para>The partitions to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionSnapshot[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithPartitionsCollection(params Func<PartitionSnapshot, PartitionSnapshot>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionSnapshot()))
					.ToArray();
				return this;
			}

			internal PartitionSnapshot CreatePartitionSnapshot()
			{
				return new PartitionSnapshot(Version);
			}

			public class PartitionSnapshot : ISerialize
			{
				internal PartitionSnapshot(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Partition.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CurrentLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						SnapshotId_.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Position.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionSnapshot(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.SnapshotId_ = await SnapshotId.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Position = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionSnapshot is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CurrentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await SnapshotId_.WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Position.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Partition does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _currentLeaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The current leader epoch of the partition, -1 for unknown leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CurrentLeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current leader epoch of the partition, -1 for unknown leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private SnapshotId _snapshotId = default!;
				/// <summary>
				/// <para>The snapshot endOffset and epoch to fetch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public SnapshotId SnapshotId_ 
				{
					get => _snapshotId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"SnapshotId_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_snapshotId = value;
					}
				}

				/// <summary>
				/// <para>The snapshot endOffset and epoch to fetch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithSnapshotId_s(Func<SnapshotId, SnapshotId> createField)
				{
					SnapshotId_ = createField(CreateSnapshotId());
					return this;
				}

				internal SnapshotId CreateSnapshotId()
				{
					return new SnapshotId(Version);
				}

				public class SnapshotId : ISerialize
				{
					internal SnapshotId(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(0, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							EndOffset.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							Epoch.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<SnapshotId> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new SnapshotId(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotId is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await EndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await Epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int64 _endOffset = Int64.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"EndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}

					private Int32 _epoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Epoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}
				}

				private Int64 _position = Int64.Default;
				/// <summary>
				/// <para>The byte position within the snapshot to start fetching from</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Position 
				{
					get => _position;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Position does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_position = value;
					}
				}

				/// <summary>
				/// <para>The byte position within the snapshot to start fetching from</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithPosition(Int64 position)
				{
					Position = position;
					return this;
				}
			}
		}

		public FetchSnapshotResponse Respond()
			=> new FetchSnapshotResponse(Version);
	}

	public class FetchSnapshotResponse : Message
	{
		public FetchSnapshotResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"FetchSnapshotResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(59);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<FetchSnapshotResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FetchSnapshotResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FetchSnapshotResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicSnapshot>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level response error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private TopicSnapshot[] _topicsCollection = Array.Empty<TopicSnapshot>();
		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicSnapshot[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public FetchSnapshotResponse WithTopicsCollection(params Func<TopicSnapshot, TopicSnapshot>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicSnapshot()))
				.ToArray();
			return this;
		}

		internal TopicSnapshot CreateTopicSnapshot()
		{
			return new TopicSnapshot(Version);
		}

		public class TopicSnapshot : ISerialize
		{
			internal TopicSnapshot(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionSnapshot>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicSnapshot(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionSnapshot>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionSnapshot.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicSnapshot is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionSnapshot>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The name of the topic to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionSnapshot[] _partitionsCollection = Array.Empty<PartitionSnapshot>();
			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionSnapshot[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to fetch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicSnapshot WithPartitionsCollection(params Func<PartitionSnapshot, PartitionSnapshot>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionSnapshot()))
					.ToArray();
				return this;
			}

			internal PartitionSnapshot CreatePartitionSnapshot()
			{
				return new PartitionSnapshot(Version);
			}

			public class PartitionSnapshot : ISerialize
			{
				internal PartitionSnapshot(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Index.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						SnapshotId_.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CurrentLeader.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Size.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Position.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						UnalignedRecords.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionSnapshot> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionSnapshot(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Index = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.SnapshotId_ = await SnapshotId.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Size = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Position = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.UnalignedRecords = await RecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								case 0:
									if (instance.Version.InRange(0, 2147483647)) 
									{
										instance.CurrentLeader = await LeaderIdAndEpoch.FromReaderAsync(instance.Version, reader, cancellationToken).ConfigureAwait(false);
									}
									else
										throw new InvalidOperationException($"Field CurrentLeader is not supported for version {instance.Version}");
									break;
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionSnapshot is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Index.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await SnapshotId_.WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CurrentLeader.WriteToAsync(writer, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Size.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Position.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await UnalignedRecords.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _index = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Index 
				{
					get => _index;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Index does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_index = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithIndex(Int32 index)
				{
					Index = index;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no fetch error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private SnapshotId _snapshotId = default!;
				/// <summary>
				/// <para>The snapshot endOffset and epoch fetched</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public SnapshotId SnapshotId_ 
				{
					get => _snapshotId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"SnapshotId_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_snapshotId = value;
					}
				}

				/// <summary>
				/// <para>The snapshot endOffset and epoch fetched</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithSnapshotId_s(Func<SnapshotId, SnapshotId> createField)
				{
					SnapshotId_ = createField(CreateSnapshotId());
					return this;
				}

				internal SnapshotId CreateSnapshotId()
				{
					return new SnapshotId(Version);
				}

				public class SnapshotId : ISerialize
				{
					internal SnapshotId(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(0, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							EndOffset.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							Epoch.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<SnapshotId> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new SnapshotId(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.Epoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotId is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await EndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await Epoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int64 _endOffset = Int64.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int64 EndOffset 
					{
						get => _endOffset;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"EndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_endOffset = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEndOffset(Int64 endOffset)
					{
						EndOffset = endOffset;
						return this;
					}

					private Int32 _epoch = Int32.Default;
					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 Epoch 
					{
						get => _epoch;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Epoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_epoch = value;
						}
					}

					/// <summary>
					/// <para>Versions: 0+</para>
					/// </summary>
					public SnapshotId WithEpoch(Int32 epoch)
					{
						Epoch = epoch;
						return this;
					}
				}

				private LeaderIdAndEpoch _currentLeader = default!;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public LeaderIdAndEpoch CurrentLeader 
				{
					get => _currentLeader;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CurrentLeader does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_currentLeader = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithCurrentLeaders(Func<LeaderIdAndEpoch, LeaderIdAndEpoch> createField)
				{
					CurrentLeader = createField(CreateLeaderIdAndEpoch());
					return this;
				}

				internal LeaderIdAndEpoch CreateLeaderIdAndEpoch()
				{
					return new LeaderIdAndEpoch(Version);
				}

				public class LeaderIdAndEpoch : ISerialize
				{
					internal LeaderIdAndEpoch(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(0, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							LeaderId.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							LeaderEpoch.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<LeaderIdAndEpoch> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new LeaderIdAndEpoch(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderIdAndEpoch is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _leaderId = Int32.Default;
					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderId 
					{
						get => _leaderId;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_leaderId = value;
						}
					}

					/// <summary>
					/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderId(Int32 leaderId)
					{
						LeaderId = leaderId;
						return this;
					}

					private Int32 _leaderEpoch = Int32.Default;
					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 LeaderEpoch 
					{
						get => _leaderEpoch;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_leaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The latest known leader epoch</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public LeaderIdAndEpoch WithLeaderEpoch(Int32 leaderEpoch)
					{
						LeaderEpoch = leaderEpoch;
						return this;
					}
				}

				private Int64 _size = Int64.Default;
				/// <summary>
				/// <para>The total size of the snapshot.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Size 
				{
					get => _size;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Size does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_size = value;
					}
				}

				/// <summary>
				/// <para>The total size of the snapshot.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithSize(Int64 size)
				{
					Size = size;
					return this;
				}

				private Int64 _position = Int64.Default;
				/// <summary>
				/// <para>The starting byte position within the snapshot included in the Bytes field.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Position 
				{
					get => _position;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Position does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_position = value;
					}
				}

				/// <summary>
				/// <para>The starting byte position within the snapshot included in the Bytes field.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithPosition(Int64 position)
				{
					Position = position;
					return this;
				}

				private Records.RecordBatch _unalignedRecords = default!;
				/// <summary>
				/// <para>Snapshot data in records format which may not be aligned on an offset boundary</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Records.RecordBatch UnalignedRecords 
				{
					get => _unalignedRecords;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"UnalignedRecords does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_unalignedRecords = value;
					}
				}

				/// <summary>
				/// <para>Snapshot data in records format which may not be aligned on an offset boundary</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionSnapshot WithUnalignedRecords(Records.RecordBatch unalignedRecords)
				{
					UnalignedRecords = unalignedRecords;
					return this;
				}
			}
		}
	}

	public class FindCoordinatorRequest : Message, IRespond<FindCoordinatorResponse>
	{
		public FindCoordinatorRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"FindCoordinatorRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(10);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<FindCoordinatorRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FindCoordinatorRequest(version);
			if (instance.Version.InRange(0, 3)) 
			{
				instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.KeyType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(4, 2147483647)) 
			{
				instance.CoordinatorKeysCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FindCoordinatorRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 3)) 
			{
				await Key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await KeyType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(4, 2147483647)) 
			{
				await Array<String>.From(CoordinatorKeysCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _key = String.Default;
		/// <summary>
		/// <para>The coordinator key.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public String Key 
		{
			get => _key;
			set 
			{
				if (Version.InRange(0, 3) == false) 
				{
					throw new UnsupportedVersionException($"Key does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");
				}

				_key = value;
			}
		}

		/// <summary>
		/// <para>The coordinator key.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorRequest WithKey(String key)
		{
			Key = key;
			return this;
		}

		private Int8 _keyType = new Int8(0);
		/// <summary>
		/// <para>The coordinator key type. (Group, transaction, etc.)</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int8 KeyType 
		{
			get => _keyType;
			set 
			{
				if (Version.InRange(1, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"KeyType does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
				}

				_keyType = value;
			}
		}

		/// <summary>
		/// <para>The coordinator key type. (Group, transaction, etc.)</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public FindCoordinatorRequest WithKeyType(Int8 keyType)
		{
			KeyType = keyType;
			return this;
		}

		private String[] _coordinatorKeysCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The coordinator keys.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public String[] CoordinatorKeysCollection 
		{
			get => _coordinatorKeysCollection;
			set 
			{
				if (Version.InRange(4, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"CoordinatorKeysCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
				}

				_coordinatorKeysCollection = value;
			}
		}

		/// <summary>
		/// <para>The coordinator keys.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public FindCoordinatorRequest WithCoordinatorKeysCollection(String[] coordinatorKeysCollection)
		{
			CoordinatorKeysCollection = coordinatorKeysCollection;
			return this;
		}

		public FindCoordinatorResponse Respond()
			=> new FindCoordinatorResponse(Version);
	}

	public class FindCoordinatorResponse : Message
	{
		public FindCoordinatorResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"FindCoordinatorResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(10);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<FindCoordinatorResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new FindCoordinatorResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 3)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 3)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 3)) 
			{
				instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 3)) 
			{
				instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 3)) 
			{
				instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(4, 2147483647)) 
			{
				instance.CoordinatorsCollection = await Array<Coordinator>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Coordinator.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for FindCoordinatorResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 3)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 3)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 3)) 
			{
				await NodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 3)) 
			{
				await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 3)) 
			{
				await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(4, 2147483647)) 
			{
				await Array<Coordinator>.From(CoordinatorsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public FindCoordinatorResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 3) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 1-3</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(1, 3) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 1-3");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 1-3</para>
		/// </summary>
		public FindCoordinatorResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Int32 _nodeId = Int32.Default;
		/// <summary>
		/// <para>The node id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int32 NodeId 
		{
			get => _nodeId;
			set 
			{
				if (Version.InRange(0, 3) == false) 
				{
					throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");
				}

				_nodeId = value;
			}
		}

		/// <summary>
		/// <para>The node id.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithNodeId(Int32 nodeId)
		{
			NodeId = nodeId;
			return this;
		}

		private String _host = String.Default;
		/// <summary>
		/// <para>The host name.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public String Host 
		{
			get => _host;
			set 
			{
				if (Version.InRange(0, 3) == false) 
				{
					throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");
				}

				_host = value;
			}
		}

		/// <summary>
		/// <para>The host name.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithHost(String host)
		{
			Host = host;
			return this;
		}

		private Int32 _port = Int32.Default;
		/// <summary>
		/// <para>The port.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public Int32 Port 
		{
			get => _port;
			set 
			{
				if (Version.InRange(0, 3) == false) 
				{
					throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 0-3");
				}

				_port = value;
			}
		}

		/// <summary>
		/// <para>The port.</para>
		/// <para>Versions: 0-3</para>
		/// </summary>
		public FindCoordinatorResponse WithPort(Int32 port)
		{
			Port = port;
			return this;
		}

		private Coordinator[] _coordinatorsCollection = Array.Empty<Coordinator>();
		/// <summary>
		/// <para>Each coordinator result in the response</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public Coordinator[] CoordinatorsCollection 
		{
			get => _coordinatorsCollection;
			set 
			{
				if (Version.InRange(4, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"CoordinatorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
				}

				_coordinatorsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each coordinator result in the response</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public FindCoordinatorResponse WithCoordinatorsCollection(params Func<Coordinator, Coordinator>[] createFields)
		{
			CoordinatorsCollection = createFields
				.Select(createField => createField(CreateCoordinator()))
				.ToArray();
			return this;
		}

		internal Coordinator CreateCoordinator()
		{
			return new Coordinator(Version);
		}

		public class Coordinator : ISerialize
		{
			internal Coordinator(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(4, 2147483647) ? 
					Key.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					NodeId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					Host.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					Port.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<Coordinator> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Coordinator(version);
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.Key = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Coordinator is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(4, 2147483647)) 
				{
					await Key.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await NodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _key = String.Default;
			/// <summary>
			/// <para>The coordinator key.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String Key 
			{
				get => _key;
				set 
				{
					if (Version.InRange(4, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Key does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
					}

					_key = value;
				}
			}

			/// <summary>
			/// <para>The coordinator key.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithKey(String key)
			{
				Key = key;
				return this;
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The node id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				set 
				{
					if (Version.InRange(4, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
					}

					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The node id.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The host name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				set 
				{
					if (Version.InRange(4, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
					}

					_host = value;
				}
			}

			/// <summary>
			/// <para>The host name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				set 
				{
					if (Version.InRange(4, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
					}

					_port = value;
				}
			}

			/// <summary>
			/// <para>The port.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(4, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(4, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 4+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The error message, or null if there was no error.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Coordinator WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class HeartbeatRequest : Message, IRespond<HeartbeatResponse>
	{
		public HeartbeatRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"HeartbeatRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(12);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<HeartbeatRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new HeartbeatRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for HeartbeatRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await GenerationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _generationId = Int32.Default;
		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GenerationId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private String? _groupInstanceId;
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				if (Version.InRange(3, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");
				}

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public HeartbeatRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		public HeartbeatResponse Respond()
			=> new HeartbeatResponse(Version);
	}

	public class HeartbeatResponse : Message
	{
		public HeartbeatResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"HeartbeatResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(12);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<HeartbeatResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new HeartbeatResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for HeartbeatResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public HeartbeatResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public HeartbeatResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class IncrementalAlterConfigsRequest : Message, IRespond<IncrementalAlterConfigsResponse>
	{
		public IncrementalAlterConfigsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"IncrementalAlterConfigsRequest does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(44);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<IncrementalAlterConfigsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new IncrementalAlterConfigsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResourcesCollection = (await Array<AlterConfigsResource>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResource.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.ResourceType);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ValidateOnly = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for IncrementalAlterConfigsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterConfigsResource>.From(ResourcesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ValidateOnly.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<Int8, AlterConfigsResource> _resourcesCollection = new Dictionary<Int8, AlterConfigsResource>();
		/// <summary>
		/// <para>The incremental updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<Int8, AlterConfigsResource> ResourcesCollection 
		{
			get => _resourcesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResourcesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resourcesCollection = value;
			}
		}

		/// <summary>
		/// <para>The incremental updates for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsRequest WithResourcesCollection(params Func<AlterConfigsResource, AlterConfigsResource>[] createFields)
		{
			ResourcesCollection = createFields
				.Select(createField => createField(CreateAlterConfigsResource()))
				.ToDictionary(field => field.ResourceType);
			return this;
		}

		internal AlterConfigsResource CreateAlterConfigsResource()
		{
			return new AlterConfigsResource(Version);
		}

		public class AlterConfigsResource : ISerialize
		{
			internal AlterConfigsResource(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<AlterableConfig>.From(ConfigsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterConfigsResource> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResource(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ConfigsCollection = (await Array<AlterableConfig>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterableConfig.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResource is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<AlterableConfig>.From(ConfigsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}

			private Dictionary<String, AlterableConfig> _configsCollection = new Dictionary<String, AlterableConfig>();
			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<String, AlterableConfig> ConfigsCollection 
			{
				get => _configsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ConfigsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_configsCollection = value;
				}
			}

			/// <summary>
			/// <para>The configurations.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResource WithConfigsCollection(params Func<AlterableConfig, AlterableConfig>[] createFields)
			{
				ConfigsCollection = createFields
					.Select(createField => createField(CreateAlterableConfig()))
					.ToDictionary(field => field.Name);
				return this;
			}

			internal AlterableConfig CreateAlterableConfig()
			{
				return new AlterableConfig(Version);
			}

			public class AlterableConfig : ISerialize
			{
				internal AlterableConfig(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ConfigOperation.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Value.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<AlterableConfig> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new AlterableConfig(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ConfigOperation = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Value = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterableConfig is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ConfigOperation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Value.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The configuration key name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithName(String name)
				{
					Name = name;
					return this;
				}

				private Int8 _configOperation = Int8.Default;
				/// <summary>
				/// <para>The type (Set, Delete, Append, Subtract) of operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int8 ConfigOperation 
				{
					get => _configOperation;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ConfigOperation does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_configOperation = value;
					}
				}

				/// <summary>
				/// <para>The type (Set, Delete, Append, Subtract) of operation.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithConfigOperation(Int8 configOperation)
				{
					ConfigOperation = configOperation;
					return this;
				}

				private String? _value;
				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? Value 
				{
					get => _value;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Value does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Value does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_value = value;
					}
				}

				/// <summary>
				/// <para>The value to set for the configuration key.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public AlterableConfig WithValue(String? value)
				{
					Value = value;
					return this;
				}
			}
		}

		private Boolean _validateOnly = Boolean.Default;
		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Boolean ValidateOnly 
		{
			get => _validateOnly;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ValidateOnly does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_validateOnly = value;
			}
		}

		/// <summary>
		/// <para>True if we should validate the request, but not change the configurations.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsRequest WithValidateOnly(Boolean validateOnly)
		{
			ValidateOnly = validateOnly;
			return this;
		}

		public IncrementalAlterConfigsResponse Respond()
			=> new IncrementalAlterConfigsResponse(Version);
	}

	public class IncrementalAlterConfigsResponse : Message
	{
		public IncrementalAlterConfigsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"IncrementalAlterConfigsResponse does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(44);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<IncrementalAlterConfigsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new IncrementalAlterConfigsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponsesCollection = await Array<AlterConfigsResourceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => AlterConfigsResourceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for IncrementalAlterConfigsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<AlterConfigsResourceResponse>.From(ResponsesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private AlterConfigsResourceResponse[] _responsesCollection = Array.Empty<AlterConfigsResourceResponse>();
		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public AlterConfigsResourceResponse[] ResponsesCollection 
		{
			get => _responsesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each resource.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public IncrementalAlterConfigsResponse WithResponsesCollection(params Func<AlterConfigsResourceResponse, AlterConfigsResourceResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(CreateAlterConfigsResourceResponse()))
				.ToArray();
			return this;
		}

		internal AlterConfigsResourceResponse CreateAlterConfigsResourceResponse()
		{
			return new AlterConfigsResourceResponse(Version);
		}

		public class AlterConfigsResourceResponse : ISerialize
		{
			internal AlterConfigsResourceResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ResourceName.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<AlterConfigsResourceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new AlterConfigsResourceResponse(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceType = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ResourceName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for AlterConfigsResourceResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ResourceName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The resource error code.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The resource error message, or null if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}

			private Int8 _resourceType = Int8.Default;
			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int8 ResourceType 
			{
				get => _resourceType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceType = value;
				}
			}

			/// <summary>
			/// <para>The resource type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceType(Int8 resourceType)
			{
				ResourceType = resourceType;
				return this;
			}

			private String _resourceName = String.Default;
			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ResourceName 
			{
				get => _resourceName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ResourceName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_resourceName = value;
				}
			}

			/// <summary>
			/// <para>The resource name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public AlterConfigsResourceResponse WithResourceName(String resourceName)
			{
				ResourceName = resourceName;
				return this;
			}
		}
	}

	public class InitProducerIdRequest : Message, IRespond<InitProducerIdResponse>
	{
		public InitProducerIdRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"InitProducerIdRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(22);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<InitProducerIdRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new InitProducerIdRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionalId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for InitProducerIdRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TransactionTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _transactionalId;
		/// <summary>
		/// <para>The transactional id, or null if the producer is not transactional.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? TransactionalId 
		{
			get => _transactionalId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional id, or null if the producer is not transactional.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdRequest WithTransactionalId(String? transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int32 _transactionTimeoutMs = Int32.Default;
		/// <summary>
		/// <para>The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TransactionTimeoutMs 
		{
			get => _transactionTimeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionTimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait before aborting idle transactions sent by this producer. This is only relevant if a TransactionalId has been defined.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdRequest WithTransactionTimeoutMs(Int32 transactionTimeoutMs)
		{
			TransactionTimeoutMs = transactionTimeoutMs;
			return this;
		}

		private Int64 _producerId = new Int64(-1);
		/// <summary>
		/// <para>The producer id. This is used to disambiguate requests if a transactional id is reused following its expiration.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The producer id. This is used to disambiguate requests if a transactional id is reused following its expiration.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public InitProducerIdRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = new Int16(-1);
		/// <summary>
		/// <para>The producer's current epoch. This will be checked against the producer epoch on the broker, and the request will return an error if they do not match.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The producer's current epoch. This will be checked against the producer epoch on the broker, and the request will return an error if they do not match.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public InitProducerIdRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		public InitProducerIdResponse Respond()
			=> new InitProducerIdResponse(Version);
	}

	public class InitProducerIdResponse : Message
	{
		public InitProducerIdResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"InitProducerIdResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(22);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<InitProducerIdResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new InitProducerIdResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for InitProducerIdResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _producerId = new Int64(-1);
		/// <summary>
		/// <para>The current producer id.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The current producer id.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public InitProducerIdResponse WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>The current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current epoch associated with the producer id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public InitProducerIdResponse WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}
	}

	public class JoinGroupRequest : Message, IRespond<JoinGroupResponse>
	{
		public JoinGroupRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"JoinGroupRequest does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(11);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<JoinGroupRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new JoinGroupRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.SessionTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.RebalanceTimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProtocolType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProtocolsCollection = (await Array<JoinGroupRequestProtocol>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => JoinGroupRequestProtocol.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await SessionTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await RebalanceTimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProtocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<JoinGroupRequestProtocol>.From(ProtocolsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _sessionTimeoutMs = Int32.Default;
		/// <summary>
		/// <para>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 SessionTimeoutMs 
		{
			get => _sessionTimeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"SessionTimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_sessionTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithSessionTimeoutMs(Int32 sessionTimeoutMs)
		{
			SessionTimeoutMs = sessionTimeoutMs;
			return this;
		}

		private Int32 _rebalanceTimeoutMs = new Int32(-1);
		/// <summary>
		/// <para>The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 RebalanceTimeoutMs 
		{
			get => _rebalanceTimeoutMs;
			set 
			{
				_rebalanceTimeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The maximum time in milliseconds that the coordinator will wait for each member to rejoin when rebalancing the group.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public JoinGroupRequest WithRebalanceTimeoutMs(Int32 rebalanceTimeoutMs)
		{
			RebalanceTimeoutMs = rebalanceTimeoutMs;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member id assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member id assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private String? _groupInstanceId;
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			set 
			{
				if (Version.InRange(5, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
				}

				if (Version.InRange(5, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 5+");
				}

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public JoinGroupRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private String _protocolType = String.Default;
		/// <summary>
		/// <para>The unique name the for class of protocols implemented by the group we want to join.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String ProtocolType 
		{
			get => _protocolType;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProtocolType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The unique name the for class of protocols implemented by the group we want to join.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithProtocolType(String protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private Dictionary<String, JoinGroupRequestProtocol> _protocolsCollection = new Dictionary<String, JoinGroupRequestProtocol>();
		/// <summary>
		/// <para>The list of protocols that the member supports.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, JoinGroupRequestProtocol> ProtocolsCollection 
		{
			get => _protocolsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProtocolsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_protocolsCollection = value;
			}
		}

		/// <summary>
		/// <para>The list of protocols that the member supports.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupRequest WithProtocolsCollection(params Func<JoinGroupRequestProtocol, JoinGroupRequestProtocol>[] createFields)
		{
			ProtocolsCollection = createFields
				.Select(createField => createField(CreateJoinGroupRequestProtocol()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal JoinGroupRequestProtocol CreateJoinGroupRequestProtocol()
		{
			return new JoinGroupRequestProtocol(Version);
		}

		public class JoinGroupRequestProtocol : ISerialize
		{
			internal JoinGroupRequestProtocol(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Metadata.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<JoinGroupRequestProtocol> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new JoinGroupRequestProtocol(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Metadata = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupRequestProtocol is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The protocol name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The protocol name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupRequestProtocol WithName(String name)
			{
				Name = name;
				return this;
			}

			private Bytes _metadata = Bytes.Default;
			/// <summary>
			/// <para>The protocol metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Metadata 
			{
				get => _metadata;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Metadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_metadata = value;
				}
			}

			/// <summary>
			/// <para>The protocol metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupRequestProtocol WithMetadata(Bytes metadata)
			{
				Metadata = metadata;
				return this;
			}
		}

		public JoinGroupResponse Respond()
			=> new JoinGroupResponse(Version);
	}

	public class JoinGroupResponse : Message
	{
		public JoinGroupResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"JoinGroupResponse does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(11);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<JoinGroupResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new JoinGroupResponse(version);
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.ProtocolType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProtocolName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Leader = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MembersCollection = await Array<JoinGroupResponseMember>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => JoinGroupResponseMember.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(2, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await GenerationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await ProtocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProtocolName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Leader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<JoinGroupResponseMember>.From(MembersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public JoinGroupResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int32 _generationId = new Int32(-1);
		/// <summary>
		/// <para>The generation ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GenerationId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public JoinGroupResponse WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String? _protocolType;
		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolType 
		{
			get => _protocolType;
			set 
			{
				if (Version.InRange(7, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ProtocolType does not support null for version {Version}. Supported versions for null value: 7+");
				}

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public JoinGroupResponse WithProtocolType(String? protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private String? _protocolName;
		/// <summary>
		/// <para>The group protocol selected by the coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ProtocolName 
		{
			get => _protocolName;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProtocolName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(7, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ProtocolName does not support null for version {Version}. Supported versions for null value: 7+");
				}

				_protocolName = value;
			}
		}

		/// <summary>
		/// <para>The group protocol selected by the coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithProtocolName(String? protocolName)
		{
			ProtocolName = protocolName;
			return this;
		}

		private String _leader = String.Default;
		/// <summary>
		/// <para>The leader of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Leader 
		{
			get => _leader;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Leader does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_leader = value;
			}
		}

		/// <summary>
		/// <para>The leader of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithLeader(String leader)
		{
			Leader = leader;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private JoinGroupResponseMember[] _membersCollection = Array.Empty<JoinGroupResponseMember>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponseMember[] MembersCollection 
		{
			get => _membersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MembersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_membersCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public JoinGroupResponse WithMembersCollection(params Func<JoinGroupResponseMember, JoinGroupResponseMember>[] createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(CreateJoinGroupResponseMember()))
				.ToArray();
			return this;
		}

		internal JoinGroupResponseMember CreateJoinGroupResponseMember()
		{
			return new JoinGroupResponseMember(Version);
		}

		public class JoinGroupResponseMember : ISerialize
		{
			internal JoinGroupResponseMember(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					MemberId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					GroupInstanceId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Metadata.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<JoinGroupResponseMember> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new JoinGroupResponseMember(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Metadata = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for JoinGroupResponseMember is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The group member ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The group member ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupResponseMember WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private String? _groupInstanceId;
			/// <summary>
			/// <para>The unique identifier of the consumer instance provided by end user.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? GroupInstanceId 
			{
				get => _groupInstanceId;
				set 
				{
					if (Version.InRange(5, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
					}

					if (Version.InRange(5, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 5+");
					}

					_groupInstanceId = value;
				}
			}

			/// <summary>
			/// <para>The unique identifier of the consumer instance provided by end user.</para>
			/// <para>Versions: 5+</para>
			/// <para>Default: null</para>
			/// </summary>
			public JoinGroupResponseMember WithGroupInstanceId(String? groupInstanceId)
			{
				GroupInstanceId = groupInstanceId;
				return this;
			}

			private Bytes _metadata = Bytes.Default;
			/// <summary>
			/// <para>The group member metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Metadata 
			{
				get => _metadata;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Metadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_metadata = value;
				}
			}

			/// <summary>
			/// <para>The group member metadata.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public JoinGroupResponseMember WithMetadata(Bytes metadata)
			{
				Metadata = metadata;
				return this;
			}
		}
	}

	public class LeaderAndIsrRequest : Message, IRespond<LeaderAndIsrResponse>
	{
		public LeaderAndIsrRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"LeaderAndIsrRequest does not support version {version}. Valid versions are: 0-5");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(4);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<LeaderAndIsrRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaderAndIsrRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.Type = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 1)) 
			{
				instance.UngroupedPartitionStatesCollection = await Array<LeaderAndIsrPartitionState>.FromReaderAsync(() => LeaderAndIsrPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.TopicStatesCollection = await Array<LeaderAndIsrTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.LiveLeadersCollection = await Array<LeaderAndIsrLiveLeader>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrLiveLeader.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await Type.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 1)) 
			{
				await Array<LeaderAndIsrPartitionState>.From(UngroupedPartitionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 2147483647)) 
			{
				await Array<LeaderAndIsrTopicState>.From(TopicStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<LeaderAndIsrLiveLeader>.From(LiveLeadersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The current controller ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The current controller ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Int32 _controllerEpoch = Int32.Default;
		/// <summary>
		/// <para>The current controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerEpoch 
		{
			get => _controllerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithControllerEpoch(Int32 controllerEpoch)
		{
			ControllerEpoch = controllerEpoch;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The current broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current broker epoch.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public LeaderAndIsrRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Int8 _type = Int8.Default;
		/// <summary>
		/// <para>The type that indicates whether all topics are included in the request</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public Int8 Type 
		{
			get => _type;
			set 
			{
				if (Version.InRange(5, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Type does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
				}

				_type = value;
			}
		}

		/// <summary>
		/// <para>The type that indicates whether all topics are included in the request</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public LeaderAndIsrRequest WithType(Int8 type)
		{
			Type = type;
			return this;
		}

		private LeaderAndIsrPartitionState[] _ungroupedPartitionStatesCollection = Array.Empty<LeaderAndIsrPartitionState>();
		/// <summary>
		/// <para>The state of each partition, in a v0 or v1 message.</para>
		/// <para>Versions: 0-1</para>
		/// </summary>
		public LeaderAndIsrPartitionState[] UngroupedPartitionStatesCollection 
		{
			get => _ungroupedPartitionStatesCollection;
			set 
			{
				if (Version.InRange(0, 1) == false) 
				{
					throw new UnsupportedVersionException($"UngroupedPartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-1");
				}

				_ungroupedPartitionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>The state of each partition, in a v0 or v1 message.</para>
		/// <para>Versions: 0-1</para>
		/// </summary>
		public LeaderAndIsrRequest WithUngroupedPartitionStatesCollection(LeaderAndIsrPartitionState[] ungroupedPartitionStatesCollection)
		{
			UngroupedPartitionStatesCollection = ungroupedPartitionStatesCollection;
			return this;
		}

		private LeaderAndIsrTopicState[] _topicStatesCollection = Array.Empty<LeaderAndIsrTopicState>();
		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public LeaderAndIsrTopicState[] TopicStatesCollection 
		{
			get => _topicStatesCollection;
			set 
			{
				if (Version.InRange(2, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");
				}

				_topicStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public LeaderAndIsrRequest WithTopicStatesCollection(params Func<LeaderAndIsrTopicState, LeaderAndIsrTopicState>[] createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(CreateLeaderAndIsrTopicState()))
				.ToArray();
			return this;
		}

		internal LeaderAndIsrTopicState CreateLeaderAndIsrTopicState()
		{
			return new LeaderAndIsrTopicState(Version);
		}

		public class LeaderAndIsrTopicState : ISerialize
		{
			internal LeaderAndIsrTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(2, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(2, 2147483647) ? 
					Array<LeaderAndIsrPartitionState>.From(PartitionStatesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<LeaderAndIsrTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrTopicState(version);
				if (instance.Version.InRange(2, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(2, 2147483647)) 
				{
					instance.PartitionStatesCollection = await Array<LeaderAndIsrPartitionState>.FromReaderAsync(() => LeaderAndIsrPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrTopicState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(2, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(2, 2147483647)) 
				{
					await Array<LeaderAndIsrPartitionState>.From(PartitionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(2, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public LeaderAndIsrTopicState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrTopicState WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private LeaderAndIsrPartitionState[] _partitionStatesCollection = Array.Empty<LeaderAndIsrPartitionState>();
			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public LeaderAndIsrPartitionState[] PartitionStatesCollection 
			{
				get => _partitionStatesCollection;
				set 
				{
					if (Version.InRange(2, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");
					}

					_partitionStatesCollection = value;
				}
			}

			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public LeaderAndIsrTopicState WithPartitionStatesCollection(LeaderAndIsrPartitionState[] partitionStatesCollection)
			{
				PartitionStatesCollection = partitionStatesCollection;
				return this;
			}
		}

		private LeaderAndIsrLiveLeader[] _liveLeadersCollection = Array.Empty<LeaderAndIsrLiveLeader>();
		/// <summary>
		/// <para>The current live leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrLiveLeader[] LiveLeadersCollection 
		{
			get => _liveLeadersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"LiveLeadersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_liveLeadersCollection = value;
			}
		}

		/// <summary>
		/// <para>The current live leaders.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrRequest WithLiveLeadersCollection(params Func<LeaderAndIsrLiveLeader, LeaderAndIsrLiveLeader>[] createFields)
		{
			LiveLeadersCollection = createFields
				.Select(createField => createField(CreateLeaderAndIsrLiveLeader()))
				.ToArray();
			return this;
		}

		internal LeaderAndIsrLiveLeader CreateLeaderAndIsrLiveLeader()
		{
			return new LeaderAndIsrLiveLeader(Version);
		}

		public class LeaderAndIsrLiveLeader : ISerialize
		{
			internal LeaderAndIsrLiveLeader(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					BrokerId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					HostName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Port.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<LeaderAndIsrLiveLeader> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrLiveLeader(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.HostName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrLiveLeader is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await HostName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int32 _brokerId = Int32.Default;
			/// <summary>
			/// <para>The leader's broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 BrokerId 
			{
				get => _brokerId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_brokerId = value;
				}
			}

			/// <summary>
			/// <para>The leader's broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrLiveLeader WithBrokerId(Int32 brokerId)
			{
				BrokerId = brokerId;
				return this;
			}

			private String _hostName = String.Default;
			/// <summary>
			/// <para>The leader's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String HostName 
			{
				get => _hostName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"HostName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_hostName = value;
				}
			}

			/// <summary>
			/// <para>The leader's hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrLiveLeader WithHostName(String hostName)
			{
				HostName = hostName;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The leader's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_port = value;
				}
			}

			/// <summary>
			/// <para>The leader's port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrLiveLeader WithPort(Int32 port)
			{
				Port = port;
				return this;
			}
		}

		public class LeaderAndIsrPartitionState : ISerialize
		{
			internal LeaderAndIsrPartitionState(Int16 version)
			{
				if (version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"LeaderAndIsrPartitionState does not support version {version}. Valid versions are: 0+");
				}

				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 1) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PartitionIndex.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ControllerEpoch.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Leader.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					LeaderEpoch.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(IsrCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ZkVersion.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(ReplicasCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					Array<Int32>.From(AddingReplicasCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					Array<Int32>.From(RemovingReplicasCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					IsNew.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<LeaderAndIsrPartitionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrPartitionState(version);
				if (instance.Version.InRange(0, 1)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Leader = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.IsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ZkVersion = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.AddingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.RemovingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.IsNew = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrPartitionState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 1)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ControllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Leader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(IsrCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ZkVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(ReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await Array<Int32>.From(AddingReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await Array<Int32>.From(RemovingReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await IsNew.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.  This is only present in v0 or v1.</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.  This is only present in v0 or v1.</para>
			/// <para>Versions: 0-1</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int32 _controllerEpoch = Int32.Default;
			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ControllerEpoch 
			{
				get => _controllerEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ControllerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_controllerEpoch = value;
				}
			}

			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithControllerEpoch(Int32 controllerEpoch)
			{
				ControllerEpoch = controllerEpoch;
				return this;
			}

			private Int32 _leader = Int32.Default;
			/// <summary>
			/// <para>The broker ID of the leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Leader 
			{
				get => _leader;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Leader does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_leader = value;
				}
			}

			/// <summary>
			/// <para>The broker ID of the leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithLeader(Int32 leader)
			{
				Leader = leader;
				return this;
			}

			private Int32 _leaderEpoch = Int32.Default;
			/// <summary>
			/// <para>The leader epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 LeaderEpoch 
			{
				get => _leaderEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_leaderEpoch = value;
				}
			}

			/// <summary>
			/// <para>The leader epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithLeaderEpoch(Int32 leaderEpoch)
			{
				LeaderEpoch = leaderEpoch;
				return this;
			}

			private Int32[] _isrCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The in-sync replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] IsrCollection 
			{
				get => _isrCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"IsrCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_isrCollection = value;
				}
			}

			/// <summary>
			/// <para>The in-sync replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithIsrCollection(Int32[] isrCollection)
			{
				IsrCollection = isrCollection;
				return this;
			}

			private Int32 _zkVersion = Int32.Default;
			/// <summary>
			/// <para>The ZooKeeper version.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ZkVersion 
			{
				get => _zkVersion;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ZkVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_zkVersion = value;
				}
			}

			/// <summary>
			/// <para>The ZooKeeper version.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithZkVersion(Int32 zkVersion)
			{
				ZkVersion = zkVersion;
				return this;
			}

			private Int32[] _replicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] ReplicasCollection 
			{
				get => _replicasCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ReplicasCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_replicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replica IDs.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithReplicasCollection(Int32[] replicasCollection)
			{
				ReplicasCollection = replicasCollection;
				return this;
			}

			private Int32[] _addingReplicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replica IDs that we are adding this partition to, or null if no replicas are being added.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int32[] AddingReplicasCollection 
			{
				get => _addingReplicasCollection;
				set 
				{
					_addingReplicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replica IDs that we are adding this partition to, or null if no replicas are being added.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithAddingReplicasCollection(Int32[] addingReplicasCollection)
			{
				AddingReplicasCollection = addingReplicasCollection;
				return this;
			}

			private Int32[] _removingReplicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replica IDs that we are removing this partition from, or null if no replicas are being removed.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int32[] RemovingReplicasCollection 
			{
				get => _removingReplicasCollection;
				set 
				{
					_removingReplicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replica IDs that we are removing this partition from, or null if no replicas are being removed.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithRemovingReplicasCollection(Int32[] removingReplicasCollection)
			{
				RemovingReplicasCollection = removingReplicasCollection;
				return this;
			}

			private Boolean _isNew = new Boolean(false);
			/// <summary>
			/// <para>Whether the replica should have existed on the broker or not.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public Boolean IsNew 
			{
				get => _isNew;
				set 
				{
					_isNew = value;
				}
			}

			/// <summary>
			/// <para>Whether the replica should have existed on the broker or not.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public LeaderAndIsrPartitionState WithIsNew(Boolean isNew)
			{
				IsNew = isNew;
				return this;
			}
		}

		public LeaderAndIsrResponse Respond()
			=> new LeaderAndIsrResponse(Version);
	}

	public class LeaderAndIsrResponse : Message
	{
		public LeaderAndIsrResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"LeaderAndIsrResponse does not support version {version}. Valid versions are: 0-5");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(4);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<LeaderAndIsrResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaderAndIsrResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 4)) 
			{
				instance.PartitionErrorsCollection = await Array<LeaderAndIsrPartitionError>.FromReaderAsync(() => LeaderAndIsrPartitionError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<LeaderAndIsrTopicError>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => LeaderAndIsrTopicError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.TopicId);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 4)) 
			{
				await Array<LeaderAndIsrPartitionError>.From(PartitionErrorsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await Array<LeaderAndIsrTopicError>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderAndIsrResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private LeaderAndIsrPartitionError[] _partitionErrorsCollection = Array.Empty<LeaderAndIsrPartitionError>();
		/// <summary>
		/// <para>Each partition in v0 to v4 message.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public LeaderAndIsrPartitionError[] PartitionErrorsCollection 
		{
			get => _partitionErrorsCollection;
			set 
			{
				if (Version.InRange(0, 4) == false) 
				{
					throw new UnsupportedVersionException($"PartitionErrorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-4");
				}

				_partitionErrorsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each partition in v0 to v4 message.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public LeaderAndIsrResponse WithPartitionErrorsCollection(LeaderAndIsrPartitionError[] partitionErrorsCollection)
		{
			PartitionErrorsCollection = partitionErrorsCollection;
			return this;
		}

		private Dictionary<Uuid, LeaderAndIsrTopicError> _topicsCollection = new Dictionary<Uuid, LeaderAndIsrTopicError>();
		/// <summary>
		/// <para>Each topic</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public Dictionary<Uuid, LeaderAndIsrTopicError> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(5, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public LeaderAndIsrResponse WithTopicsCollection(params Func<LeaderAndIsrTopicError, LeaderAndIsrTopicError>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateLeaderAndIsrTopicError()))
				.ToDictionary(field => field.TopicId);
			return this;
		}

		internal LeaderAndIsrTopicError CreateLeaderAndIsrTopicError()
		{
			return new LeaderAndIsrTopicError(Version);
		}

		public class LeaderAndIsrTopicError : ISerialize
		{
			internal LeaderAndIsrTopicError(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(5, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					Array<LeaderAndIsrPartitionError>.From(PartitionErrorsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<LeaderAndIsrTopicError> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrTopicError(version);
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.PartitionErrorsCollection = await Array<LeaderAndIsrPartitionError>.FromReaderAsync(() => LeaderAndIsrPartitionError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrTopicError is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(5, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await Array<LeaderAndIsrPartitionError>.From(PartitionErrorsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					if (Version.InRange(5, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicId does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
					}

					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The unique topic ID</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrTopicError WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private LeaderAndIsrPartitionError[] _partitionErrorsCollection = Array.Empty<LeaderAndIsrPartitionError>();
			/// <summary>
			/// <para>Each partition.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrPartitionError[] PartitionErrorsCollection 
			{
				get => _partitionErrorsCollection;
				set 
				{
					if (Version.InRange(5, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionErrorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
					}

					_partitionErrorsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public LeaderAndIsrTopicError WithPartitionErrorsCollection(LeaderAndIsrPartitionError[] partitionErrorsCollection)
			{
				PartitionErrorsCollection = partitionErrorsCollection;
				return this;
			}
		}

		public class LeaderAndIsrPartitionError : ISerialize
		{
			internal LeaderAndIsrPartitionError(Int16 version)
			{
				if (version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"LeaderAndIsrPartitionError does not support version {version}. Valid versions are: 0+");
				}

				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 4) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PartitionIndex.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<LeaderAndIsrPartitionError> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new LeaderAndIsrPartitionError(version);
				if (instance.Version.InRange(0, 4)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderAndIsrPartitionError is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 4)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public LeaderAndIsrPartitionError WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionError WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The partition error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The partition error code, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public LeaderAndIsrPartitionError WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class LeaderChangeMessage : Message, IRespond<ProduceResponse>
	{
		public LeaderChangeMessage(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"LeaderChangeMessage does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<LeaderChangeMessage> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaderChangeMessage(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.VotersCollection = await Array<Voter>.FromReaderAsync(() => Voter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GrantingVotersCollection = await Array<Voter>.FromReaderAsync(() => Voter.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaderChangeMessage is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Version_.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<Voter>.From(VotersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<Voter>.From(GrantingVotersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the leader change message</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Version_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the leader change message</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		private Int32 _leaderId = Int32.Default;
		/// <summary>
		/// <para>The ID of the newly elected leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 LeaderId 
		{
			get => _leaderId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_leaderId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the newly elected leader</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithLeaderId(Int32 leaderId)
		{
			LeaderId = leaderId;
			return this;
		}

		private Voter[] _votersCollection = Array.Empty<Voter>();
		/// <summary>
		/// <para>The set of voters in the quorum for this epoch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Voter[] VotersCollection 
		{
			get => _votersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"VotersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_votersCollection = value;
			}
		}

		/// <summary>
		/// <para>The set of voters in the quorum for this epoch</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithVotersCollection(Voter[] votersCollection)
		{
			VotersCollection = votersCollection;
			return this;
		}

		private Voter[] _grantingVotersCollection = Array.Empty<Voter>();
		/// <summary>
		/// <para>The voters who voted for the leader at the time of election</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Voter[] GrantingVotersCollection 
		{
			get => _grantingVotersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GrantingVotersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_grantingVotersCollection = value;
			}
		}

		/// <summary>
		/// <para>The voters who voted for the leader at the time of election</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaderChangeMessage WithGrantingVotersCollection(Voter[] grantingVotersCollection)
		{
			GrantingVotersCollection = grantingVotersCollection;
			return this;
		}

		public class Voter : ISerialize
		{
			internal Voter(Int16 version)
			{
				if (version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Voter does not support version {version}. Valid versions are: 0+");
				}

				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					VoterId.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<Voter> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new Voter(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.VoterId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for Voter is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await VoterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int32 _voterId = Int32.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 VoterId 
			{
				get => _voterId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"VoterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_voterId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Voter WithVoterId(Int32 voterId)
			{
				VoterId = voterId;
				return this;
			}
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class LeaveGroupRequest : Message, IRespond<LeaveGroupResponse>
	{
		public LeaveGroupRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"LeaveGroupRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(13);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<LeaveGroupRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaveGroupRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.MembersCollection = await Array<MemberIdentity>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MemberIdentity.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaveGroupRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await Array<MemberIdentity>.From(MembersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The ID of the group to leave.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the group to leave.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaveGroupRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID to remove from the group.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				if (Version.InRange(0, 2) == false) 
				{
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-2");
				}

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID to remove from the group.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public LeaveGroupRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private MemberIdentity[] _membersCollection = Array.Empty<MemberIdentity>();
		/// <summary>
		/// <para>List of leaving member identities.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public MemberIdentity[] MembersCollection 
		{
			get => _membersCollection;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MembersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_membersCollection = value;
			}
		}

		/// <summary>
		/// <para>List of leaving member identities.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public LeaveGroupRequest WithMembersCollection(params Func<MemberIdentity, MemberIdentity>[] createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(CreateMemberIdentity()))
				.ToArray();
			return this;
		}

		internal MemberIdentity CreateMemberIdentity()
		{
			return new MemberIdentity(Version);
		}

		public class MemberIdentity : ISerialize
		{
			internal MemberIdentity(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(3, 2147483647) ? 
					MemberId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					GroupInstanceId.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<MemberIdentity> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MemberIdentity(version);
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MemberIdentity is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(3, 2147483647)) 
				{
					await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberIdentity WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private String? _groupInstanceId;
			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? GroupInstanceId 
			{
				get => _groupInstanceId;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					if (Version.InRange(3, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");
					}

					_groupInstanceId = value;
				}
			}

			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// <para>Default: null</para>
			/// </summary>
			public MemberIdentity WithGroupInstanceId(String? groupInstanceId)
			{
				GroupInstanceId = groupInstanceId;
				return this;
			}
		}

		public LeaveGroupResponse Respond()
			=> new LeaveGroupResponse(Version);
	}

	public class LeaveGroupResponse : Message
	{
		public LeaveGroupResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"LeaveGroupResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(13);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<LeaveGroupResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new LeaveGroupResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.MembersCollection = await Array<MemberResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MemberResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for LeaveGroupResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await Array<MemberResponse>.From(MembersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public LeaveGroupResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public LeaveGroupResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private MemberResponse[] _membersCollection = Array.Empty<MemberResponse>();
		/// <summary>
		/// <para>List of leaving member responses.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public MemberResponse[] MembersCollection 
		{
			get => _membersCollection;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MembersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_membersCollection = value;
			}
		}

		/// <summary>
		/// <para>List of leaving member responses.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public LeaveGroupResponse WithMembersCollection(params Func<MemberResponse, MemberResponse>[] createFields)
		{
			MembersCollection = createFields
				.Select(createField => createField(CreateMemberResponse()))
				.ToArray();
			return this;
		}

		internal MemberResponse CreateMemberResponse()
		{
			return new MemberResponse(Version);
		}

		public class MemberResponse : ISerialize
		{
			internal MemberResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(3, 2147483647) ? 
					MemberId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					GroupInstanceId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<MemberResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MemberResponse(version);
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MemberResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(3, 2147483647)) 
				{
					await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The member ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberResponse WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private String? _groupInstanceId;
			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String? GroupInstanceId 
			{
				get => _groupInstanceId;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					if (Version.InRange(3, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");
					}

					_groupInstanceId = value;
				}
			}

			/// <summary>
			/// <para>The group instance ID to remove from the group.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberResponse WithGroupInstanceId(String? groupInstanceId)
			{
				GroupInstanceId = groupInstanceId;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The error code, or 0 if there was no error.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public MemberResponse WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class ListGroupsRequest : Message, IRespond<ListGroupsResponse>
	{
		public ListGroupsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListGroupsRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(16);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListGroupsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListGroupsRequest(version);
			if (instance.Version.InRange(4, 2147483647)) 
			{
				instance.StatesFilterCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListGroupsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(4, 2147483647)) 
			{
				await Array<String>.From(StatesFilterCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String[] _statesFilterCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The states of the groups we want to list. If empty all groups are returned with their state.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public String[] StatesFilterCollection 
		{
			get => _statesFilterCollection;
			set 
			{
				if (Version.InRange(4, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"StatesFilterCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
				}

				_statesFilterCollection = value;
			}
		}

		/// <summary>
		/// <para>The states of the groups we want to list. If empty all groups are returned with their state.</para>
		/// <para>Versions: 4+</para>
		/// </summary>
		public ListGroupsRequest WithStatesFilterCollection(String[] statesFilterCollection)
		{
			StatesFilterCollection = statesFilterCollection;
			return this;
		}

		public ListGroupsResponse Respond()
			=> new ListGroupsResponse(Version);
	}

	public class ListGroupsResponse : Message
	{
		public ListGroupsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListGroupsResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(16);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListGroupsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListGroupsResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupsCollection = await Array<ListedGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListedGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListGroupsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ListedGroup>.From(GroupsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public ListGroupsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListGroupsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private ListedGroup[] _groupsCollection = Array.Empty<ListedGroup>();
		/// <summary>
		/// <para>Each group in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListedGroup[] GroupsCollection 
		{
			get => _groupsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each group in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListGroupsResponse WithGroupsCollection(params Func<ListedGroup, ListedGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(CreateListedGroup()))
				.ToArray();
			return this;
		}

		internal ListedGroup CreateListedGroup()
		{
			return new ListedGroup(Version);
		}

		public class ListedGroup : ISerialize
		{
			internal ListedGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					GroupId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProtocolType.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					GroupState.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ListedGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListedGroup(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProtocolType = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.GroupState = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListedGroup is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProtocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await GroupState.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListedGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private String _protocolType = String.Default;
			/// <summary>
			/// <para>The group protocol type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String ProtocolType 
			{
				get => _protocolType;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProtocolType does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_protocolType = value;
				}
			}

			/// <summary>
			/// <para>The group protocol type.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListedGroup WithProtocolType(String protocolType)
			{
				ProtocolType = protocolType;
				return this;
			}

			private String _groupState = String.Default;
			/// <summary>
			/// <para>The group state name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public String GroupState 
			{
				get => _groupState;
				set 
				{
					_groupState = value;
				}
			}

			/// <summary>
			/// <para>The group state name.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public ListedGroup WithGroupState(String groupState)
			{
				GroupState = groupState;
				return this;
			}
		}
	}

	public class ListOffsetsRequest : Message, IRespond<ListOffsetsResponse>
	{
		public ListOffsetsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListOffsetsRequest does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(2);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListOffsetsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListOffsetsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.IsolationLevel = await Int8.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<ListOffsetsTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ReplicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 2147483647)) 
			{
				await IsolationLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ListOffsetsTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _replicaId = Int32.Default;
		/// <summary>
		/// <para>The broker ID of the requestor, or -1 if this request is being made by a normal consumer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ReplicaId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the requestor, or -1 if this request is being made by a normal consumer.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Int8 _isolationLevel = Int8.Default;
		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int8 IsolationLevel 
		{
			get => _isolationLevel;
			set 
			{
				if (Version.InRange(2, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IsolationLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 2+");
				}

				_isolationLevel = value;
			}
		}

		/// <summary>
		/// <para>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public ListOffsetsRequest WithIsolationLevel(Int8 isolationLevel)
		{
			IsolationLevel = isolationLevel;
			return this;
		}

		private ListOffsetsTopic[] _topicsCollection = Array.Empty<ListOffsetsTopic>();
		/// <summary>
		/// <para>Each topic in the request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsRequest WithTopicsCollection(params Func<ListOffsetsTopic, ListOffsetsTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateListOffsetsTopic()))
				.ToArray();
			return this;
		}

		internal ListOffsetsTopic CreateListOffsetsTopic()
		{
			return new ListOffsetsTopic(Version);
		}

		public class ListOffsetsTopic : ISerialize
		{
			internal ListOffsetsTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<ListOffsetsPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ListOffsetsTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListOffsetsTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<ListOffsetsPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<ListOffsetsPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private ListOffsetsPartition[] _partitionsCollection = Array.Empty<ListOffsetsPartition>();
			/// <summary>
			/// <para>Each partition in the request.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the request.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopic WithPartitionsCollection(params Func<ListOffsetsPartition, ListOffsetsPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateListOffsetsPartition()))
					.ToArray();
				return this;
			}

			internal ListOffsetsPartition CreateListOffsetsPartition()
			{
				return new ListOffsetsPartition(Version);
			}

			public class ListOffsetsPartition : ISerialize
			{
				internal ListOffsetsPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(6, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(4, 2147483647) ? 
						CurrentLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Timestamp.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 0) ? 
						MaxNumOffsets.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<ListOffsetsPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ListOffsetsPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(4, 2147483647)) 
					{
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Timestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 0)) 
					{
						instance.MaxNumOffsets = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(4, 2147483647)) 
					{
						await CurrentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Timestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 0)) 
					{
						await MaxNumOffsets.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _currentLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The current leader epoch.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The current leader epoch.</para>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartition WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private Int64 _timestamp = Int64.Default;
				/// <summary>
				/// <para>The current timestamp.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 Timestamp 
				{
					get => _timestamp;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Timestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_timestamp = value;
					}
				}

				/// <summary>
				/// <para>The current timestamp.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartition WithTimestamp(Int64 timestamp)
				{
					Timestamp = timestamp;
					return this;
				}

				private Int32 _maxNumOffsets = new Int32(1);
				/// <summary>
				/// <para>The maximum number of offsets to report.</para>
				/// <para>Versions: 0</para>
				/// <para>Default: 1</para>
				/// </summary>
				public Int32 MaxNumOffsets 
				{
					get => _maxNumOffsets;
					set 
					{
						if (Version.InRange(0, 0) == false) 
						{
							throw new UnsupportedVersionException($"MaxNumOffsets does not support version {Version} and has been defined as not ignorable. Supported versions: 0");
						}

						_maxNumOffsets = value;
					}
				}

				/// <summary>
				/// <para>The maximum number of offsets to report.</para>
				/// <para>Versions: 0</para>
				/// <para>Default: 1</para>
				/// </summary>
				public ListOffsetsPartition WithMaxNumOffsets(Int32 maxNumOffsets)
				{
					MaxNumOffsets = maxNumOffsets;
					return this;
				}
			}
		}

		public ListOffsetsResponse Respond()
			=> new ListOffsetsResponse(Version);
	}

	public class ListOffsetsResponse : Message
	{
		public ListOffsetsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListOffsetsResponse does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(2);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListOffsetsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListOffsetsResponse(version);
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<ListOffsetsTopicResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsTopicResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(2, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<ListOffsetsTopicResponse>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public ListOffsetsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private ListOffsetsTopicResponse[] _topicsCollection = Array.Empty<ListOffsetsTopicResponse>();
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsTopicResponse[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListOffsetsResponse WithTopicsCollection(params Func<ListOffsetsTopicResponse, ListOffsetsTopicResponse>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateListOffsetsTopicResponse()))
				.ToArray();
			return this;
		}

		internal ListOffsetsTopicResponse CreateListOffsetsTopicResponse()
		{
			return new ListOffsetsTopicResponse(Version);
		}

		public class ListOffsetsTopicResponse : ISerialize
		{
			internal ListOffsetsTopicResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<ListOffsetsPartitionResponse>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ListOffsetsTopicResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListOffsetsTopicResponse(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<ListOffsetsPartitionResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListOffsetsPartitionResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsTopicResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<ListOffsetsPartitionResponse>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopicResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private ListOffsetsPartitionResponse[] _partitionsCollection = Array.Empty<ListOffsetsPartitionResponse>();
			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsPartitionResponse[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the response.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListOffsetsTopicResponse WithPartitionsCollection(params Func<ListOffsetsPartitionResponse, ListOffsetsPartitionResponse>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateListOffsetsPartitionResponse()))
					.ToArray();
				return this;
			}

			internal ListOffsetsPartitionResponse CreateListOffsetsPartitionResponse()
			{
				return new ListOffsetsPartitionResponse(Version);
			}

			public class ListOffsetsPartitionResponse : ISerialize
			{
				internal ListOffsetsPartitionResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(6, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 0) ? 
						Array<Int64>.From(OldStyleOffsetsCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						Timestamp.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						Offset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(4, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<ListOffsetsPartitionResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new ListOffsetsPartitionResponse(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 0)) 
					{
						instance.OldStyleOffsetsCollection = await Array<Int64>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.Timestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.Offset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(4, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for ListOffsetsPartitionResponse is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 0)) 
					{
						await Array<Int64>.From(OldStyleOffsetsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await Timestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await Offset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(4, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int64[] _oldStyleOffsetsCollection = Array.Empty<Int64>();
				/// <summary>
				/// <para>The result offsets.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public Int64[] OldStyleOffsetsCollection 
				{
					get => _oldStyleOffsetsCollection;
					set 
					{
						if (Version.InRange(0, 0) == false) 
						{
							throw new UnsupportedVersionException($"OldStyleOffsetsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0");
						}

						_oldStyleOffsetsCollection = value;
					}
				}

				/// <summary>
				/// <para>The result offsets.</para>
				/// <para>Versions: 0</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithOldStyleOffsetsCollection(Int64[] oldStyleOffsetsCollection)
				{
					OldStyleOffsetsCollection = oldStyleOffsetsCollection;
					return this;
				}

				private Int64 _timestamp = new Int64(-1);
				/// <summary>
				/// <para>The timestamp associated with the returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 Timestamp 
				{
					get => _timestamp;
					set 
					{
						if (Version.InRange(1, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Timestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
						}

						_timestamp = value;
					}
				}

				/// <summary>
				/// <para>The timestamp associated with the returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithTimestamp(Int64 timestamp)
				{
					Timestamp = timestamp;
					return this;
				}

				private Int64 _offset = new Int64(-1);
				/// <summary>
				/// <para>The returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 Offset 
				{
					get => _offset;
					set 
					{
						if (Version.InRange(1, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Offset does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
						}

						_offset = value;
					}
				}

				/// <summary>
				/// <para>The returned offset.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithOffset(Int64 offset)
				{
					Offset = offset;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(4, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>Versions: 4+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public ListOffsetsPartitionResponse WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}
	}

	public class ListPartitionReassignmentsRequest : Message, IRespond<ListPartitionReassignmentsResponse>
	{
		public ListPartitionReassignmentsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListPartitionReassignmentsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(46);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListPartitionReassignmentsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListPartitionReassignmentsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await NullableArray<ListPartitionReassignmentsTopics>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => ListPartitionReassignmentsTopics.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListPartitionReassignmentsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<ListPartitionReassignmentsTopics>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The time in ms to wait for the request to complete.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public ListPartitionReassignmentsRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private ListPartitionReassignmentsTopics[]? _topicsCollection;
		/// <summary>
		/// <para>The topics to list partition reassignments for, or null to list everything.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ListPartitionReassignmentsTopics[]? TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to list partition reassignments for, or null to list everything.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ListPartitionReassignmentsRequest WithTopicsCollection(params Func<ListPartitionReassignmentsTopics, ListPartitionReassignmentsTopics>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateListPartitionReassignmentsTopics()))
				.ToArray();
			return this;
		}

		internal ListPartitionReassignmentsTopics CreateListPartitionReassignmentsTopics()
		{
			return new ListPartitionReassignmentsTopics(Version);
		}

		public class ListPartitionReassignmentsTopics : ISerialize
		{
			internal ListPartitionReassignmentsTopics(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(PartitionIndexesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<ListPartitionReassignmentsTopics> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new ListPartitionReassignmentsTopics(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for ListPartitionReassignmentsTopics is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(PartitionIndexesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListPartitionReassignmentsTopics WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32[] _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partitions to list partition reassignments for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions to list partition reassignments for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public ListPartitionReassignmentsTopics WithPartitionIndexesCollection(Int32[] partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		public ListPartitionReassignmentsResponse Respond()
			=> new ListPartitionReassignmentsResponse(Version);
	}

	public class ListPartitionReassignmentsResponse : Message
	{
		public ListPartitionReassignmentsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListPartitionReassignmentsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(46);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListPartitionReassignmentsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListPartitionReassignmentsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<OngoingTopicReassignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OngoingTopicReassignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListPartitionReassignmentsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OngoingTopicReassignment>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private OngoingTopicReassignment[] _topicsCollection = Array.Empty<OngoingTopicReassignment>();
		/// <summary>
		/// <para>The ongoing reassignments for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OngoingTopicReassignment[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The ongoing reassignments for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListPartitionReassignmentsResponse WithTopicsCollection(params Func<OngoingTopicReassignment, OngoingTopicReassignment>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOngoingTopicReassignment()))
				.ToArray();
			return this;
		}

		internal OngoingTopicReassignment CreateOngoingTopicReassignment()
		{
			return new OngoingTopicReassignment(Version);
		}

		public class OngoingTopicReassignment : ISerialize
		{
			internal OngoingTopicReassignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OngoingPartitionReassignment>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OngoingTopicReassignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OngoingTopicReassignment(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<OngoingPartitionReassignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OngoingPartitionReassignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OngoingTopicReassignment is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OngoingPartitionReassignment>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OngoingTopicReassignment WithName(String name)
			{
				Name = name;
				return this;
			}

			private OngoingPartitionReassignment[] _partitionsCollection = Array.Empty<OngoingPartitionReassignment>();
			/// <summary>
			/// <para>The ongoing reassignments for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OngoingPartitionReassignment[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The ongoing reassignments for each partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OngoingTopicReassignment WithPartitionsCollection(params Func<OngoingPartitionReassignment, OngoingPartitionReassignment>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOngoingPartitionReassignment()))
					.ToArray();
				return this;
			}

			internal OngoingPartitionReassignment CreateOngoingPartitionReassignment()
			{
				return new OngoingPartitionReassignment(Version);
			}

			public class OngoingPartitionReassignment : ISerialize
			{
				internal OngoingPartitionReassignment(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(ReplicasCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(AddingReplicasCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(RemovingReplicasCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OngoingPartitionReassignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OngoingPartitionReassignment(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.AddingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.RemovingReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OngoingPartitionReassignment is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(ReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(AddingReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(RemovingReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The index of the partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The index of the partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32[] _replicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The current replica set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] ReplicasCollection 
				{
					get => _replicasCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ReplicasCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_replicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The current replica set.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithReplicasCollection(Int32[] replicasCollection)
				{
					ReplicasCollection = replicasCollection;
					return this;
				}

				private Int32[] _addingReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of replicas we are currently adding.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] AddingReplicasCollection 
				{
					get => _addingReplicasCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"AddingReplicasCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_addingReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of replicas we are currently adding.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithAddingReplicasCollection(Int32[] addingReplicasCollection)
				{
					AddingReplicasCollection = addingReplicasCollection;
					return this;
				}

				private Int32[] _removingReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of replicas we are currently removing.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] RemovingReplicasCollection 
				{
					get => _removingReplicasCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"RemovingReplicasCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_removingReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of replicas we are currently removing.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OngoingPartitionReassignment WithRemovingReplicasCollection(Int32[] removingReplicasCollection)
				{
					RemovingReplicasCollection = removingReplicasCollection;
					return this;
				}
			}
		}
	}

	public class ListTransactionsRequest : Message, IRespond<ListTransactionsResponse>
	{
		public ListTransactionsRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListTransactionsRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(66);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListTransactionsRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListTransactionsRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.StateFiltersCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerIdFiltersCollection = await Array<Int64>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListTransactionsRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(StateFiltersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<Int64>.From(ProducerIdFiltersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String[] _stateFiltersCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The transaction states to filter by: if empty, all transactions are returned; if non-empty, then only transactions matching one of the filtered states will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] StateFiltersCollection 
		{
			get => _stateFiltersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"StateFiltersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_stateFiltersCollection = value;
			}
		}

		/// <summary>
		/// <para>The transaction states to filter by: if empty, all transactions are returned; if non-empty, then only transactions matching one of the filtered states will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsRequest WithStateFiltersCollection(String[] stateFiltersCollection)
		{
			StateFiltersCollection = stateFiltersCollection;
			return this;
		}

		private Int64[] _producerIdFiltersCollection = Array.Empty<Int64>();
		/// <summary>
		/// <para>The producerIds to filter by: if empty, all transactions will be returned; if non-empty, only transactions which match one of the filtered producerIds will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64[] ProducerIdFiltersCollection 
		{
			get => _producerIdFiltersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerIdFiltersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerIdFiltersCollection = value;
			}
		}

		/// <summary>
		/// <para>The producerIds to filter by: if empty, all transactions will be returned; if non-empty, only transactions which match one of the filtered producerIds will be returned</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsRequest WithProducerIdFiltersCollection(Int64[] producerIdFiltersCollection)
		{
			ProducerIdFiltersCollection = producerIdFiltersCollection;
			return this;
		}

		public ListTransactionsResponse Respond()
			=> new ListTransactionsResponse(Version);
	}

	public class ListTransactionsResponse : Message
	{
		public ListTransactionsResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ListTransactionsResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(66);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ListTransactionsResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ListTransactionsResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.UnknownStateFiltersCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionStatesCollection = await Array<TransactionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TransactionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ListTransactionsResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(UnknownStateFiltersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TransactionState>.From(TransactionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String[] _unknownStateFiltersCollection = Array.Empty<String>();
		/// <summary>
		/// <para>Set of state filters provided in the request which were unknown to the transaction coordinator</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] UnknownStateFiltersCollection 
		{
			get => _unknownStateFiltersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"UnknownStateFiltersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_unknownStateFiltersCollection = value;
			}
		}

		/// <summary>
		/// <para>Set of state filters provided in the request which were unknown to the transaction coordinator</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithUnknownStateFiltersCollection(String[] unknownStateFiltersCollection)
		{
			UnknownStateFiltersCollection = unknownStateFiltersCollection;
			return this;
		}

		private TransactionState[] _transactionStatesCollection = Array.Empty<TransactionState>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TransactionState[] TransactionStatesCollection 
		{
			get => _transactionStatesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ListTransactionsResponse WithTransactionStatesCollection(params Func<TransactionState, TransactionState>[] createFields)
		{
			TransactionStatesCollection = createFields
				.Select(createField => createField(CreateTransactionState()))
				.ToArray();
			return this;
		}

		internal TransactionState CreateTransactionState()
		{
			return new TransactionState(Version);
		}

		public class TransactionState : ISerialize
		{
			internal TransactionState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TransactionalId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProducerId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TransactionState_.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TransactionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TransactionState(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionState_ = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TransactionState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionState_.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _transactionalId = String.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionalId 
			{
				get => _transactionalId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionalId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionalId(String transactionalId)
			{
				TransactionalId = transactionalId;
				return this;
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_producerId = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private String _transactionState = String.Default;
			/// <summary>
			/// <para>The current transaction state of the producer</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TransactionState_ 
			{
				get => _transactionState;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionState_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionState = value;
				}
			}

			/// <summary>
			/// <para>The current transaction state of the producer</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TransactionState WithTransactionState_(String transactionState)
			{
				TransactionState_ = transactionState;
				return this;
			}
		}
	}

	public class MetadataRequest : Message, IRespond<MetadataResponse>
	{
		public MetadataRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"MetadataRequest does not support version {version}. Valid versions are: 0-12");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(9, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(3);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(12);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<MetadataRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new MetadataRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await NullableArray<MetadataRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(4, 2147483647)) 
			{
				instance.AllowAutoTopicCreation = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(8, 10)) 
			{
				instance.IncludeClusterAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(8, 2147483647)) 
			{
				instance.IncludeTopicAuthorizedOperations = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await NullableArray<MetadataRequestTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(4, 2147483647)) 
			{
				await AllowAutoTopicCreation.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(8, 10)) 
			{
				await IncludeClusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(8, 2147483647)) 
			{
				await IncludeTopicAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private MetadataRequestTopic[]? _topicsCollection = Array.Empty<MetadataRequestTopic>();
		/// <summary>
		/// <para>The topics to fetch metadata for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataRequestTopic[]? TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(1, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 1+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to fetch metadata for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataRequest WithTopicsCollection(params Func<MetadataRequestTopic, MetadataRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateMetadataRequestTopic()))
				.ToArray();
			return this;
		}

		internal MetadataRequestTopic CreateMetadataRequestTopic()
		{
			return new MetadataRequestTopic(Version);
		}

		public class MetadataRequestTopic : ISerialize
		{
			internal MetadataRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(9, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(10, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<MetadataRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MetadataRequestTopic(version);
				if (instance.Version.InRange(10, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(10, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public MetadataRequestTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private String? _name;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(10, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 10+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataRequestTopic WithName(String? name)
			{
				Name = name;
				return this;
			}
		}

		private Boolean _allowAutoTopicCreation = new Boolean(true);
		/// <summary>
		/// <para>If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: true</para>
		/// </summary>
		public Boolean AllowAutoTopicCreation 
		{
			get => _allowAutoTopicCreation;
			set 
			{
				if (Version.InRange(4, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"AllowAutoTopicCreation does not support version {Version} and has been defined as not ignorable. Supported versions: 4+");
				}

				_allowAutoTopicCreation = value;
			}
		}

		/// <summary>
		/// <para>If this is true, the broker may auto-create topics that we requested which do not already exist, if it is configured to do so.</para>
		/// <para>Versions: 4+</para>
		/// <para>Default: true</para>
		/// </summary>
		public MetadataRequest WithAllowAutoTopicCreation(Boolean allowAutoTopicCreation)
		{
			AllowAutoTopicCreation = allowAutoTopicCreation;
			return this;
		}

		private Boolean _includeClusterAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 8-10</para>
		/// </summary>
		public Boolean IncludeClusterAuthorizedOperations 
		{
			get => _includeClusterAuthorizedOperations;
			set 
			{
				if (Version.InRange(8, 10) == false) 
				{
					throw new UnsupportedVersionException($"IncludeClusterAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8-10");
				}

				_includeClusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include cluster authorized operations.</para>
		/// <para>Versions: 8-10</para>
		/// </summary>
		public MetadataRequest WithIncludeClusterAuthorizedOperations(Boolean includeClusterAuthorizedOperations)
		{
			IncludeClusterAuthorizedOperations = includeClusterAuthorizedOperations;
			return this;
		}

		private Boolean _includeTopicAuthorizedOperations = Boolean.Default;
		/// <summary>
		/// <para>Whether to include topic authorized operations.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public Boolean IncludeTopicAuthorizedOperations 
		{
			get => _includeTopicAuthorizedOperations;
			set 
			{
				if (Version.InRange(8, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"IncludeTopicAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
				}

				_includeTopicAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>Whether to include topic authorized operations.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public MetadataRequest WithIncludeTopicAuthorizedOperations(Boolean includeTopicAuthorizedOperations)
		{
			IncludeTopicAuthorizedOperations = includeTopicAuthorizedOperations;
			return this;
		}

		public MetadataResponse Respond()
			=> new MetadataResponse(Version);
	}

	public class MetadataResponse : Message
	{
		public MetadataResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"MetadataResponse does not support version {version}. Valid versions are: 0-12");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(9, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(3);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(12);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<MetadataResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new MetadataResponse(version);
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokersCollection = (await Array<MetadataResponseBroker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataResponseBroker.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.NodeId);
			}
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<MetadataResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}
			if (instance.Version.InRange(8, 10)) 
			{
				instance.ClusterAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(3, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<MetadataResponseBroker>.From(BrokersCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await ControllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<MetadataResponseTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(8, 10)) 
			{
				await ClusterAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public MetadataResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<Int32, MetadataResponseBroker> _brokersCollection = new Dictionary<Int32, MetadataResponseBroker>();
		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<Int32, MetadataResponseBroker> BrokersCollection 
		{
			get => _brokersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokersCollection = value;
			}
		}

		/// <summary>
		/// <para>Each broker in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataResponse WithBrokersCollection(params Func<MetadataResponseBroker, MetadataResponseBroker>[] createFields)
		{
			BrokersCollection = createFields
				.Select(createField => createField(CreateMetadataResponseBroker()))
				.ToDictionary(field => field.NodeId);
			return this;
		}

		internal MetadataResponseBroker CreateMetadataResponseBroker()
		{
			return new MetadataResponseBroker(Version);
		}

		public class MetadataResponseBroker : ISerialize
		{
			internal MetadataResponseBroker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(9, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					NodeId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Host.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Port.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					Rack.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<MetadataResponseBroker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MetadataResponseBroker(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.NodeId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponseBroker is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await NodeId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await Rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int32 _nodeId = Int32.Default;
			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 NodeId 
			{
				get => _nodeId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"NodeId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_nodeId = value;
				}
			}

			/// <summary>
			/// <para>The broker ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseBroker WithNodeId(Int32 nodeId)
			{
				NodeId = nodeId;
				return this;
			}

			private String _host = String.Default;
			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Host 
			{
				get => _host;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_host = value;
				}
			}

			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseBroker WithHost(String host)
			{
				Host = host;
				return this;
			}

			private Int32 _port = Int32.Default;
			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Port 
			{
				get => _port;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_port = value;
				}
			}

			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseBroker WithPort(Int32 port)
			{
				Port = port;
				return this;
			}

			private String? _rack;
			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: null</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				set 
				{
					if (Version.InRange(1, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 1+");
					}

					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack of the broker, or null if it has not been assigned to a rack.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: null</para>
			/// </summary>
			public MetadataResponseBroker WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}

		private String? _clusterId;
		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(2, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 2+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>The cluster ID that responding broker belongs to.</para>
		/// <para>Versions: 2+</para>
		/// <para>Default: null</para>
		/// </summary>
		public MetadataResponse WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private Int32 _controllerId = new Int32(-1);
		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			set 
			{
				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the controller broker.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public MetadataResponse WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Dictionary<String?, MetadataResponseTopic> _topicsCollection = new Dictionary<String?, MetadataResponseTopic>();
		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String?, MetadataResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic in the response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public MetadataResponse WithTopicsCollection(params Func<MetadataResponseTopic, MetadataResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateMetadataResponseTopic()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal MetadataResponseTopic CreateMetadataResponseTopic()
		{
			return new MetadataResponseTopic(Version);
		}

		public class MetadataResponseTopic : ISerialize
		{
			internal MetadataResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(9, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(10, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					IsInternal.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<MetadataResponsePartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(8, 2147483647) ? 
					TopicAuthorizedOperations.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<MetadataResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new MetadataResponseTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(10, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.IsInternal = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<MetadataResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => MetadataResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(8, 2147483647)) 
				{
					instance.TopicAuthorizedOperations = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(10, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await IsInternal.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<MetadataResponsePartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(8, 2147483647)) 
				{
					await TopicAuthorizedOperations.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The topic error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The topic error, or 0 if there was no error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _name;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(12, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Name does not support null for version {Version}. Supported versions for null value: 12+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithName(String? name)
			{
				Name = name;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 10+</para>
			/// </summary>
			public MetadataResponseTopic WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private Boolean _isInternal = new Boolean(false);
			/// <summary>
			/// <para>True if the topic is internal.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public Boolean IsInternal 
			{
				get => _isInternal;
				set 
				{
					_isInternal = value;
				}
			}

			/// <summary>
			/// <para>True if the topic is internal.</para>
			/// <para>Versions: 1+</para>
			/// <para>Default: false</para>
			/// </summary>
			public MetadataResponseTopic WithIsInternal(Boolean isInternal)
			{
				IsInternal = isInternal;
				return this;
			}

			private MetadataResponsePartition[] _partitionsCollection = Array.Empty<MetadataResponsePartition>();
			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponsePartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public MetadataResponseTopic WithPartitionsCollection(params Func<MetadataResponsePartition, MetadataResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateMetadataResponsePartition()))
					.ToArray();
				return this;
			}

			internal MetadataResponsePartition CreateMetadataResponsePartition()
			{
				return new MetadataResponsePartition(Version);
			}

			public class MetadataResponsePartition : ISerialize
			{
				internal MetadataResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(9, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(7, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(ReplicaNodesCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(IsrNodesCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						Array<Int32>.From(OfflineReplicasCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<MetadataResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new MetadataResponsePartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(7, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ReplicaNodesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.IsrNodesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.OfflineReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for MetadataResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(7, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(ReplicaNodesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(IsrNodesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await Array<Int32>.From(OfflineReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The partition error, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The partition error, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the leader broker.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the leader broker.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 7+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 7+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public MetadataResponsePartition WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int32[] _replicaNodesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of all nodes that host this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] ReplicaNodesCollection 
				{
					get => _replicaNodesCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ReplicaNodesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_replicaNodesCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of all nodes that host this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithReplicaNodesCollection(Int32[] replicaNodesCollection)
				{
					ReplicaNodesCollection = replicaNodesCollection;
					return this;
				}

				private Int32[] _isrNodesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of nodes that are in sync with the leader for this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] IsrNodesCollection 
				{
					get => _isrNodesCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"IsrNodesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_isrNodesCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of nodes that are in sync with the leader for this partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public MetadataResponsePartition WithIsrNodesCollection(Int32[] isrNodesCollection)
				{
					IsrNodesCollection = isrNodesCollection;
					return this;
				}

				private Int32[] _offlineReplicasCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The set of offline replicas of this partition.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public Int32[] OfflineReplicasCollection 
				{
					get => _offlineReplicasCollection;
					set 
					{
						_offlineReplicasCollection = value;
					}
				}

				/// <summary>
				/// <para>The set of offline replicas of this partition.</para>
				/// <para>Versions: 5+</para>
				/// </summary>
				public MetadataResponsePartition WithOfflineReplicasCollection(Int32[] offlineReplicasCollection)
				{
					OfflineReplicasCollection = offlineReplicasCollection;
					return this;
				}
			}

			private Int32 _topicAuthorizedOperations = new Int32(-2147483648);
			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this topic.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public Int32 TopicAuthorizedOperations 
			{
				get => _topicAuthorizedOperations;
				set 
				{
					if (Version.InRange(8, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
					}

					_topicAuthorizedOperations = value;
				}
			}

			/// <summary>
			/// <para>32-bit bitfield to represent authorized operations for this topic.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: -2147483648</para>
			/// </summary>
			public MetadataResponseTopic WithTopicAuthorizedOperations(Int32 topicAuthorizedOperations)
			{
				TopicAuthorizedOperations = topicAuthorizedOperations;
				return this;
			}
		}

		private Int32 _clusterAuthorizedOperations = new Int32(-2147483648);
		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 8-10</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public Int32 ClusterAuthorizedOperations 
		{
			get => _clusterAuthorizedOperations;
			set 
			{
				if (Version.InRange(8, 10) == false) 
				{
					throw new UnsupportedVersionException($"ClusterAuthorizedOperations does not support version {Version} and has been defined as not ignorable. Supported versions: 8-10");
				}

				_clusterAuthorizedOperations = value;
			}
		}

		/// <summary>
		/// <para>32-bit bitfield to represent authorized operations for this cluster.</para>
		/// <para>Versions: 8-10</para>
		/// <para>Default: -2147483648</para>
		/// </summary>
		public MetadataResponse WithClusterAuthorizedOperations(Int32 clusterAuthorizedOperations)
		{
			ClusterAuthorizedOperations = clusterAuthorizedOperations;
			return this;
		}
	}

	public class OffsetCommitRequest : Message, IRespond<OffsetCommitResponse>
	{
		public OffsetCommitRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetCommitRequest does not support version {version}. Valid versions are: 0-8");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(8, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(8);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetCommitRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetCommitRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(2, 4)) 
			{
				instance.RetentionTimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<OffsetCommitRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await GenerationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 4)) 
			{
				await RetentionTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OffsetCommitRequestTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _generationId = new Int32(-1);
		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			set 
			{
				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public OffsetCommitRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public OffsetCommitRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private String? _groupInstanceId;
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			set 
			{
				if (Version.InRange(7, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");
				}

				if (Version.InRange(7, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 7+");
				}

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: null</para>
		/// </summary>
		public OffsetCommitRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private Int64 _retentionTimeMs = new Int64(-1);
		/// <summary>
		/// <para>The time period in ms to retain the offset.</para>
		/// <para>Versions: 2-4</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 RetentionTimeMs 
		{
			get => _retentionTimeMs;
			set 
			{
				_retentionTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The time period in ms to retain the offset.</para>
		/// <para>Versions: 2-4</para>
		/// <para>Default: -1</para>
		/// </summary>
		public OffsetCommitRequest WithRetentionTimeMs(Int64 retentionTimeMs)
		{
			RetentionTimeMs = retentionTimeMs;
			return this;
		}

		private OffsetCommitRequestTopic[] _topicsCollection = Array.Empty<OffsetCommitRequestTopic>();
		/// <summary>
		/// <para>The topics to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitRequestTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitRequest WithTopicsCollection(params Func<OffsetCommitRequestTopic, OffsetCommitRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetCommitRequestTopic()))
				.ToArray();
			return this;
		}

		internal OffsetCommitRequestTopic CreateOffsetCommitRequestTopic()
		{
			return new OffsetCommitRequestTopic(Version);
		}

		public class OffsetCommitRequestTopic : ISerialize
		{
			internal OffsetCommitRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(8, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OffsetCommitRequestPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetCommitRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetCommitRequestTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<OffsetCommitRequestPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitRequestPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OffsetCommitRequestPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private OffsetCommitRequestPartition[] _partitionsCollection = Array.Empty<OffsetCommitRequestPartition>();
			/// <summary>
			/// <para>Each partition to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitRequestPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to commit offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitRequestTopic WithPartitionsCollection(params Func<OffsetCommitRequestPartition, OffsetCommitRequestPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOffsetCommitRequestPartition()))
					.ToArray();
				return this;
			}

			internal OffsetCommitRequestPartition CreateOffsetCommitRequestPartition()
			{
				return new OffsetCommitRequestPartition(Version);
			}

			public class OffsetCommitRequestPartition : ISerialize
			{
				internal OffsetCommitRequestPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(8, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CommittedOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(6, 2147483647) ? 
						CommittedLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 1) ? 
						CommitTimestamp.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CommittedMetadata.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetCommitRequestPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetCommitRequestPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(6, 2147483647)) 
					{
						instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 1)) 
					{
						instance.CommitTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CommittedMetadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitRequestPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CommittedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(6, 2147483647)) 
					{
						await CommittedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 1)) 
					{
						await CommitTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CommittedMetadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitRequestPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _committedOffset = Int64.Default;
				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 CommittedOffset 
				{
					get => _committedOffset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CommittedOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_committedOffset = value;
					}
				}

				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommittedOffset(Int64 committedOffset)
				{
					CommittedOffset = committedOffset;
					return this;
				}

				private Int32 _committedLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 6+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CommittedLeaderEpoch 
				{
					get => _committedLeaderEpoch;
					set 
					{
						_committedLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of this partition.</para>
				/// <para>Versions: 6+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
				{
					CommittedLeaderEpoch = committedLeaderEpoch;
					return this;
				}

				private Int64 _commitTimestamp = new Int64(-1);
				/// <summary>
				/// <para>The timestamp of the commit.</para>
				/// <para>Versions: 1</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 CommitTimestamp 
				{
					get => _commitTimestamp;
					set 
					{
						if (Version.InRange(1, 1) == false) 
						{
							throw new UnsupportedVersionException($"CommitTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 1");
						}

						_commitTimestamp = value;
					}
				}

				/// <summary>
				/// <para>The timestamp of the commit.</para>
				/// <para>Versions: 1</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommitTimestamp(Int64 commitTimestamp)
				{
					CommitTimestamp = commitTimestamp;
					return this;
				}

				private String? _committedMetadata;
				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? CommittedMetadata 
				{
					get => _committedMetadata;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CommittedMetadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"CommittedMetadata does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_committedMetadata = value;
					}
				}

				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitRequestPartition WithCommittedMetadata(String? committedMetadata)
				{
					CommittedMetadata = committedMetadata;
					return this;
				}
			}
		}

		public OffsetCommitResponse Respond()
			=> new OffsetCommitResponse(Version);
	}

	public class OffsetCommitResponse : Message
	{
		public OffsetCommitResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetCommitResponse does not support version {version}. Valid versions are: 0-8");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(8, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(8);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetCommitResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetCommitResponse(version);
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<OffsetCommitResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(3, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OffsetCommitResponseTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public OffsetCommitResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private OffsetCommitResponseTopic[] _topicsCollection = Array.Empty<OffsetCommitResponseTopic>();
		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitResponseTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetCommitResponse WithTopicsCollection(params Func<OffsetCommitResponseTopic, OffsetCommitResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetCommitResponseTopic()))
				.ToArray();
			return this;
		}

		internal OffsetCommitResponseTopic CreateOffsetCommitResponseTopic()
		{
			return new OffsetCommitResponseTopic(Version);
		}

		public class OffsetCommitResponseTopic : ISerialize
		{
			internal OffsetCommitResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(8, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OffsetCommitResponsePartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetCommitResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetCommitResponseTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<OffsetCommitResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetCommitResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OffsetCommitResponsePartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private OffsetCommitResponsePartition[] _partitionsCollection = Array.Empty<OffsetCommitResponsePartition>();
			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitResponsePartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetCommitResponseTopic WithPartitionsCollection(params Func<OffsetCommitResponsePartition, OffsetCommitResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOffsetCommitResponsePartition()))
					.ToArray();
				return this;
			}

			internal OffsetCommitResponsePartition CreateOffsetCommitResponsePartition()
			{
				return new OffsetCommitResponsePartition(Version);
			}

			public class OffsetCommitResponsePartition : ISerialize
			{
				internal OffsetCommitResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(8, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetCommitResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetCommitResponsePartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetCommitResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetCommitResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class OffsetDeleteRequest : Message, IRespond<OffsetDeleteResponse>
	{
		public OffsetDeleteRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetDeleteRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(47);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetDeleteRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetDeleteRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<OffsetDeleteRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OffsetDeleteRequestTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Dictionary<String, OffsetDeleteRequestTopic> _topicsCollection = new Dictionary<String, OffsetDeleteRequestTopic>();
		/// <summary>
		/// <para>The topics to delete offsets for</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, OffsetDeleteRequestTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to delete offsets for</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteRequest WithTopicsCollection(params Func<OffsetDeleteRequestTopic, OffsetDeleteRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetDeleteRequestTopic()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal OffsetDeleteRequestTopic CreateOffsetDeleteRequestTopic()
		{
			return new OffsetDeleteRequestTopic(Version);
		}

		public class OffsetDeleteRequestTopic : ISerialize
		{
			internal OffsetDeleteRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OffsetDeleteRequestPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetDeleteRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetDeleteRequestTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<OffsetDeleteRequestPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteRequestPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OffsetDeleteRequestPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private OffsetDeleteRequestPartition[] _partitionsCollection = Array.Empty<OffsetDeleteRequestPartition>();
			/// <summary>
			/// <para>Each partition to delete offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteRequestPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to delete offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteRequestTopic WithPartitionsCollection(params Func<OffsetDeleteRequestPartition, OffsetDeleteRequestPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOffsetDeleteRequestPartition()))
					.ToArray();
				return this;
			}

			internal OffsetDeleteRequestPartition CreateOffsetDeleteRequestPartition()
			{
				return new OffsetDeleteRequestPartition(Version);
			}

			public class OffsetDeleteRequestPartition : ISerialize
			{
				internal OffsetDeleteRequestPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, -1);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetDeleteRequestPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetDeleteRequestPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteRequestPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetDeleteRequestPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}
			}
		}

		public OffsetDeleteResponse Respond()
			=> new OffsetDeleteResponse(Version);
	}

	public class OffsetDeleteResponse : Message
	{
		public OffsetDeleteResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetDeleteResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(47);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetDeleteResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetDeleteResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<OffsetDeleteResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OffsetDeleteResponseTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, OffsetDeleteResponseTopic> _topicsCollection = new Dictionary<String, OffsetDeleteResponseTopic>();
		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, OffsetDeleteResponseTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetDeleteResponse WithTopicsCollection(params Func<OffsetDeleteResponseTopic, OffsetDeleteResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetDeleteResponseTopic()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal OffsetDeleteResponseTopic CreateOffsetDeleteResponseTopic()
		{
			return new OffsetDeleteResponseTopic(Version);
		}

		public class OffsetDeleteResponseTopic : ISerialize
		{
			internal OffsetDeleteResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, -1);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OffsetDeleteResponsePartition>.From(PartitionsCollection.Values.ToArray()).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetDeleteResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetDeleteResponseTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = (await Array<OffsetDeleteResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetDeleteResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.PartitionIndex);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OffsetDeleteResponsePartition>.From(PartitionsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Dictionary<Int32, OffsetDeleteResponsePartition> _partitionsCollection = new Dictionary<Int32, OffsetDeleteResponsePartition>();
			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Dictionary<Int32, OffsetDeleteResponsePartition> PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetDeleteResponseTopic WithPartitionsCollection(params Func<OffsetDeleteResponsePartition, OffsetDeleteResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOffsetDeleteResponsePartition()))
					.ToDictionary(field => field.PartitionIndex);
				return this;
			}

			internal OffsetDeleteResponsePartition CreateOffsetDeleteResponsePartition()
			{
				return new OffsetDeleteResponsePartition(Version);
			}

			public class OffsetDeleteResponsePartition : ISerialize
			{
				internal OffsetDeleteResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, -1);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetDeleteResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetDeleteResponsePartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetDeleteResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetDeleteResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetDeleteResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class OffsetFetchRequest : Message, IRespond<OffsetFetchResponse>
	{
		public OffsetFetchRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetFetchRequest does not support version {version}. Valid versions are: 0-8");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(9);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetFetchRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetFetchRequest(version);
			if (instance.Version.InRange(0, 7)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 7)) 
			{
				instance.TopicsCollection = await NullableArray<OffsetFetchRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(8, 2147483647)) 
			{
				instance.GroupsCollection = await Array<OffsetFetchRequestGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchRequestGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(7, 2147483647)) 
			{
				instance.RequireStable = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 7)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 7)) 
			{
				await NullableArray<OffsetFetchRequestTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(8, 2147483647)) 
			{
				await Array<OffsetFetchRequestGroup>.From(GroupsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(7, 2147483647)) 
			{
				await RequireStable.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The group to fetch offsets for.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 7) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The group to fetch offsets for.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private OffsetFetchRequestTopic[]? _topicsCollection = Array.Empty<OffsetFetchRequestTopic>();
		/// <summary>
		/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchRequestTopic[]? TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 7) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
				}

				if (Version.InRange(2, 7) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 2-7");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchRequest WithTopicsCollection(params Func<OffsetFetchRequestTopic, OffsetFetchRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetFetchRequestTopic()))
				.ToArray();
			return this;
		}

		internal OffsetFetchRequestTopic CreateOffsetFetchRequestTopic()
		{
			return new OffsetFetchRequestTopic(Version);
		}

		public class OffsetFetchRequestTopic : ISerialize
		{
			internal OffsetFetchRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 7) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 7) ? 
					Array<Int32>.From(PartitionIndexesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetFetchRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchRequestTopic(version);
				if (instance.Version.InRange(0, 7)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 7)) 
				{
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 7)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 7)) 
				{
					await Array<Int32>.From(PartitionIndexesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 7) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32[] _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes we would like to fetch offsets for.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public Int32[] PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				set 
				{
					if (Version.InRange(0, 7) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
					}

					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes we would like to fetch offsets for.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchRequestTopic WithPartitionIndexesCollection(Int32[] partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		private OffsetFetchRequestGroup[] _groupsCollection = Array.Empty<OffsetFetchRequestGroup>();
		/// <summary>
		/// <para>Each group we would like to fetch offsets for</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchRequestGroup[] GroupsCollection 
		{
			get => _groupsCollection;
			set 
			{
				if (Version.InRange(8, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
				}

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each group we would like to fetch offsets for</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchRequest WithGroupsCollection(params Func<OffsetFetchRequestGroup, OffsetFetchRequestGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(CreateOffsetFetchRequestGroup()))
				.ToArray();
			return this;
		}

		internal OffsetFetchRequestGroup CreateOffsetFetchRequestGroup()
		{
			return new OffsetFetchRequestGroup(Version);
		}

		public class OffsetFetchRequestGroup : ISerialize
		{
			internal OffsetFetchRequestGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(8, 2147483647) ? 
					GroupId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(8, 2147483647) ? 
					NullableArray<OffsetFetchRequestTopics>.From(TopicsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetFetchRequestGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchRequestGroup(version);
				if (instance.Version.InRange(8, 2147483647)) 
				{
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(8, 2147483647)) 
				{
					instance.TopicsCollection = await NullableArray<OffsetFetchRequestTopics>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchRequestTopics.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequestGroup is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(8, 2147483647)) 
				{
					await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(8, 2147483647)) 
				{
					await NullableArray<OffsetFetchRequestTopics>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				set 
				{
					if (Version.InRange(8, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
					}

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchRequestGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private OffsetFetchRequestTopics[]? _topicsCollection = Array.Empty<OffsetFetchRequestTopics>();
			/// <summary>
			/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchRequestTopics[]? TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(8, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
					}

					if (Version.InRange(8, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support null for version {Version}. Supported versions for null value: 8+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each topic we would like to fetch offsets for, or null to fetch offsets for all topics.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchRequestGroup WithTopicsCollection(params Func<OffsetFetchRequestTopics, OffsetFetchRequestTopics>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateOffsetFetchRequestTopics()))
					.ToArray();
				return this;
			}

			internal OffsetFetchRequestTopics CreateOffsetFetchRequestTopics()
			{
				return new OffsetFetchRequestTopics(Version);
			}

			public class OffsetFetchRequestTopics : ISerialize
			{
				internal OffsetFetchRequestTopics(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(6, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(8, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(8, 2147483647) ? 
						Array<Int32>.From(PartitionIndexesCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetFetchRequestTopics> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetFetchRequestTopics(version);
					if (instance.Version.InRange(8, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(8, 2147483647)) 
					{
						instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchRequestTopics is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(8, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(8, 2147483647)) 
					{
						await Array<Int32>.From(PartitionIndexesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(8, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchRequestTopics WithName(String name)
				{
					Name = name;
					return this;
				}

				private Int32[] _partitionIndexesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The partition indexes we would like to fetch offsets for.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public Int32[] PartitionIndexesCollection 
				{
					get => _partitionIndexesCollection;
					set 
					{
						if (Version.InRange(8, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
						}

						_partitionIndexesCollection = value;
					}
				}

				/// <summary>
				/// <para>The partition indexes we would like to fetch offsets for.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchRequestTopics WithPartitionIndexesCollection(Int32[] partitionIndexesCollection)
				{
					PartitionIndexesCollection = partitionIndexesCollection;
					return this;
				}
			}
		}

		private Boolean _requireStable = new Boolean(false);
		/// <summary>
		/// <para>Whether broker should hold on returning unstable offsets but set a retriable error code for the partitions.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: false</para>
		/// </summary>
		public Boolean RequireStable 
		{
			get => _requireStable;
			set 
			{
				if (Version.InRange(7, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RequireStable does not support version {Version} and has been defined as not ignorable. Supported versions: 7+");
				}

				_requireStable = value;
			}
		}

		/// <summary>
		/// <para>Whether broker should hold on returning unstable offsets but set a retriable error code for the partitions.</para>
		/// <para>Versions: 7+</para>
		/// <para>Default: false</para>
		/// </summary>
		public OffsetFetchRequest WithRequireStable(Boolean requireStable)
		{
			RequireStable = requireStable;
			return this;
		}

		public OffsetFetchResponse Respond()
			=> new OffsetFetchResponse(Version);
	}

	public class OffsetFetchResponse : Message
	{
		public OffsetFetchResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetFetchResponse does not support version {version}. Valid versions are: 0-8");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(9);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(8);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetFetchResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetFetchResponse(version);
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 7)) 
			{
				instance.TopicsCollection = await Array<OffsetFetchResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(2, 7)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(8, 2147483647)) 
			{
				instance.GroupsCollection = await Array<OffsetFetchResponseGroup>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponseGroup.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(3, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 7)) 
			{
				await Array<OffsetFetchResponseTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(2, 7)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(8, 2147483647)) 
			{
				await Array<OffsetFetchResponseGroup>.From(GroupsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public OffsetFetchResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private OffsetFetchResponseTopic[] _topicsCollection = Array.Empty<OffsetFetchResponseTopic>();
		/// <summary>
		/// <para>The responses per topic.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchResponseTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 7) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses per topic.</para>
		/// <para>Versions: 0-7</para>
		/// </summary>
		public OffsetFetchResponse WithTopicsCollection(params Func<OffsetFetchResponseTopic, OffsetFetchResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetFetchResponseTopic()))
				.ToArray();
			return this;
		}

		internal OffsetFetchResponseTopic CreateOffsetFetchResponseTopic()
		{
			return new OffsetFetchResponseTopic(Version);
		}

		public class OffsetFetchResponseTopic : ISerialize
		{
			internal OffsetFetchResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 7) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 7) ? 
					Array<OffsetFetchResponsePartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetFetchResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchResponseTopic(version);
				if (instance.Version.InRange(0, 7)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 7)) 
				{
					instance.PartitionsCollection = await Array<OffsetFetchResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 7)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 7)) 
				{
					await Array<OffsetFetchResponsePartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 7) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private OffsetFetchResponsePartition[] _partitionsCollection = Array.Empty<OffsetFetchResponsePartition>();
			/// <summary>
			/// <para>The responses per partition</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchResponsePartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 7) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses per partition</para>
			/// <para>Versions: 0-7</para>
			/// </summary>
			public OffsetFetchResponseTopic WithPartitionsCollection(params Func<OffsetFetchResponsePartition, OffsetFetchResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOffsetFetchResponsePartition()))
					.ToArray();
				return this;
			}

			internal OffsetFetchResponsePartition CreateOffsetFetchResponsePartition()
			{
				return new OffsetFetchResponsePartition(Version);
			}

			public class OffsetFetchResponsePartition : ISerialize
			{
				internal OffsetFetchResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(6, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 7) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 7) ? 
						CommittedOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 7) ? 
						CommittedLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 7) ? 
						Metadata.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 7) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetFetchResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetFetchResponsePartition(version);
					if (instance.Version.InRange(0, 7)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 7)) 
					{
						instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 7)) 
					{
						instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 7)) 
					{
						instance.Metadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 7)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 7)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 7)) 
					{
						await CommittedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 7)) 
					{
						await CommittedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 7)) 
					{
						await Metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 7)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 7) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _committedOffset = Int64.Default;
				/// <summary>
				/// <para>The committed message offset.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public Int64 CommittedOffset 
				{
					get => _committedOffset;
					set 
					{
						if (Version.InRange(0, 7) == false) 
						{
							throw new UnsupportedVersionException($"CommittedOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
						}

						_committedOffset = value;
					}
				}

				/// <summary>
				/// <para>The committed message offset.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithCommittedOffset(Int64 committedOffset)
				{
					CommittedOffset = committedOffset;
					return this;
				}

				private Int32 _committedLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 5-7</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CommittedLeaderEpoch 
				{
					get => _committedLeaderEpoch;
					set 
					{
						_committedLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 5-7</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetFetchResponsePartition WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
				{
					CommittedLeaderEpoch = committedLeaderEpoch;
					return this;
				}

				private String? _metadata;
				/// <summary>
				/// <para>The partition metadata.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public String? Metadata 
				{
					get => _metadata;
					set 
					{
						if (Version.InRange(0, 7) == false) 
						{
							throw new UnsupportedVersionException($"Metadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
						}

						if (Version.InRange(0, 7) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Metadata does not support null for version {Version}. Supported versions for null value: 0-7");
						}

						_metadata = value;
					}
				}

				/// <summary>
				/// <para>The partition metadata.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithMetadata(String? metadata)
				{
					Metadata = metadata;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 7) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0-7");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0-7</para>
				/// </summary>
				public OffsetFetchResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}

		private Int16 _errorCode = new Int16(0);
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 2-7</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no error.</para>
		/// <para>Versions: 2-7</para>
		/// <para>Default: 0</para>
		/// </summary>
		public OffsetFetchResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private OffsetFetchResponseGroup[] _groupsCollection = Array.Empty<OffsetFetchResponseGroup>();
		/// <summary>
		/// <para>The responses per group id.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchResponseGroup[] GroupsCollection 
		{
			get => _groupsCollection;
			set 
			{
				if (Version.InRange(8, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
				}

				_groupsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses per group id.</para>
		/// <para>Versions: 8+</para>
		/// </summary>
		public OffsetFetchResponse WithGroupsCollection(params Func<OffsetFetchResponseGroup, OffsetFetchResponseGroup>[] createFields)
		{
			GroupsCollection = createFields
				.Select(createField => createField(CreateOffsetFetchResponseGroup()))
				.ToArray();
			return this;
		}

		internal OffsetFetchResponseGroup CreateOffsetFetchResponseGroup()
		{
			return new OffsetFetchResponseGroup(Version);
		}

		public class OffsetFetchResponseGroup : ISerialize
		{
			internal OffsetFetchResponseGroup(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(8, 2147483647) ? 
					GroupId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(8, 2147483647) ? 
					Array<OffsetFetchResponseTopics>.From(TopicsCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(8, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetFetchResponseGroup> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetFetchResponseGroup(version);
				if (instance.Version.InRange(8, 2147483647)) 
				{
					instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(8, 2147483647)) 
				{
					instance.TopicsCollection = await Array<OffsetFetchResponseTopics>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponseTopics.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(8, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponseGroup is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(8, 2147483647)) 
				{
					await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(8, 2147483647)) 
				{
					await Array<OffsetFetchResponseTopics>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(8, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _groupId = String.Default;
			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public String GroupId 
			{
				get => _groupId;
				set 
				{
					if (Version.InRange(8, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
					}

					_groupId = value;
				}
			}

			/// <summary>
			/// <para>The group ID.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchResponseGroup WithGroupId(String groupId)
			{
				GroupId = groupId;
				return this;
			}

			private OffsetFetchResponseTopics[] _topicsCollection = Array.Empty<OffsetFetchResponseTopics>();
			/// <summary>
			/// <para>The responses per topic.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchResponseTopics[] TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(8, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses per topic.</para>
			/// <para>Versions: 8+</para>
			/// </summary>
			public OffsetFetchResponseGroup WithTopicsCollection(params Func<OffsetFetchResponseTopics, OffsetFetchResponseTopics>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateOffsetFetchResponseTopics()))
					.ToArray();
				return this;
			}

			internal OffsetFetchResponseTopics CreateOffsetFetchResponseTopics()
			{
				return new OffsetFetchResponseTopics(Version);
			}

			public class OffsetFetchResponseTopics : ISerialize
			{
				internal OffsetFetchResponseTopics(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(6, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(8, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(8, 2147483647) ? 
						Array<OffsetFetchResponsePartitions>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetFetchResponseTopics> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetFetchResponseTopics(version);
					if (instance.Version.InRange(8, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(8, 2147483647)) 
					{
						instance.PartitionsCollection = await Array<OffsetFetchResponsePartitions>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetFetchResponsePartitions.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponseTopics is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(8, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(8, 2147483647)) 
					{
						await Array<OffsetFetchResponsePartitions>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(8, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchResponseTopics WithName(String name)
				{
					Name = name;
					return this;
				}

				private OffsetFetchResponsePartitions[] _partitionsCollection = Array.Empty<OffsetFetchResponsePartitions>();
				/// <summary>
				/// <para>The responses per partition</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchResponsePartitions[] PartitionsCollection 
				{
					get => _partitionsCollection;
					set 
					{
						if (Version.InRange(8, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
						}

						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The responses per partition</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public OffsetFetchResponseTopics WithPartitionsCollection(params Func<OffsetFetchResponsePartitions, OffsetFetchResponsePartitions>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(CreateOffsetFetchResponsePartitions()))
						.ToArray();
					return this;
				}

				internal OffsetFetchResponsePartitions CreateOffsetFetchResponsePartitions()
				{
					return new OffsetFetchResponsePartitions(Version);
				}

				public class OffsetFetchResponsePartitions : ISerialize
				{
					internal OffsetFetchResponsePartitions(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(6, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(8, 2147483647) ? 
							PartitionIndex.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(8, 2147483647) ? 
							CommittedOffset.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(8, 2147483647) ? 
							CommittedLeaderEpoch.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(8, 2147483647) ? 
							Metadata.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(8, 2147483647) ? 
							ErrorCode.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<OffsetFetchResponsePartitions> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new OffsetFetchResponsePartitions(version);
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.Metadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetFetchResponsePartitions is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(8, 2147483647)) 
						{
							await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(8, 2147483647)) 
						{
							await CommittedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(8, 2147483647)) 
						{
							await CommittedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(8, 2147483647)) 
						{
							await Metadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(8, 2147483647)) 
						{
							await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						set 
						{
							if (Version.InRange(8, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
							}

							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int64 _committedOffset = Int64.Default;
					/// <summary>
					/// <para>The committed message offset.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int64 CommittedOffset 
					{
						get => _committedOffset;
						set 
						{
							if (Version.InRange(8, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"CommittedOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
							}

							_committedOffset = value;
						}
					}

					/// <summary>
					/// <para>The committed message offset.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithCommittedOffset(Int64 committedOffset)
					{
						CommittedOffset = committedOffset;
						return this;
					}

					private Int32 _committedLeaderEpoch = new Int32(-1);
					/// <summary>
					/// <para>The leader epoch.</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public Int32 CommittedLeaderEpoch 
					{
						get => _committedLeaderEpoch;
						set 
						{
							_committedLeaderEpoch = value;
						}
					}

					/// <summary>
					/// <para>The leader epoch.</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: -1</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
					{
						CommittedLeaderEpoch = committedLeaderEpoch;
						return this;
					}

					private String? _metadata;
					/// <summary>
					/// <para>The partition metadata.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public String? Metadata 
					{
						get => _metadata;
						set 
						{
							if (Version.InRange(8, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"Metadata does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
							}

							if (Version.InRange(8, 2147483647) == false &&
								value == null) 
							{
								throw new UnsupportedVersionException($"Metadata does not support null for version {Version}. Supported versions for null value: 8+");
							}

							_metadata = value;
						}
					}

					/// <summary>
					/// <para>The partition metadata.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithMetadata(String? metadata)
					{
						Metadata = metadata;
						return this;
					}

					private Int16 _errorCode = Int16.Default;
					/// <summary>
					/// <para>The partition-level error code, or 0 if there was no error.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int16 ErrorCode 
					{
						get => _errorCode;
						set 
						{
							if (Version.InRange(8, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
							}

							_errorCode = value;
						}
					}

					/// <summary>
					/// <para>The partition-level error code, or 0 if there was no error.</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public OffsetFetchResponsePartitions WithErrorCode(Int16 errorCode)
					{
						ErrorCode = errorCode;
						return this;
					}
				}
			}

			private Int16 _errorCode = new Int16(0);
			/// <summary>
			/// <para>The group-level error code, or 0 if there was no error.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: 0</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(8, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The group-level error code, or 0 if there was no error.</para>
			/// <para>Versions: 8+</para>
			/// <para>Default: 0</para>
			/// </summary>
			public OffsetFetchResponseGroup WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class OffsetForLeaderEpochRequest : Message, IRespond<OffsetForLeaderEpochResponse>
	{
		public OffsetForLeaderEpochRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetForLeaderEpochRequest does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(23);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetForLeaderEpochRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetForLeaderEpochRequest(version);
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.ReplicaId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<OffsetForLeaderTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetForLeaderTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Topic);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderEpochRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(3, 2147483647)) 
			{
				await ReplicaId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OffsetForLeaderTopic>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _replicaId = new Int32(-2);
		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -2</para>
		/// </summary>
		public Int32 ReplicaId 
		{
			get => _replicaId;
			set 
			{
				_replicaId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID of the follower, of -1 if this request is from a consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -2</para>
		/// </summary>
		public OffsetForLeaderEpochRequest WithReplicaId(Int32 replicaId)
		{
			ReplicaId = replicaId;
			return this;
		}

		private Dictionary<String, OffsetForLeaderTopic> _topicsCollection = new Dictionary<String, OffsetForLeaderTopic>();
		/// <summary>
		/// <para>Each topic to get offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, OffsetForLeaderTopic> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic to get offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetForLeaderEpochRequest WithTopicsCollection(params Func<OffsetForLeaderTopic, OffsetForLeaderTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetForLeaderTopic()))
				.ToDictionary(field => field.Topic);
			return this;
		}

		internal OffsetForLeaderTopic CreateOffsetForLeaderTopic()
		{
			return new OffsetForLeaderTopic(Version);
		}

		public class OffsetForLeaderTopic : ISerialize
		{
			internal OffsetForLeaderTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<OffsetForLeaderPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetForLeaderTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetForLeaderTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<OffsetForLeaderPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetForLeaderPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<OffsetForLeaderPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopic WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private OffsetForLeaderPartition[] _partitionsCollection = Array.Empty<OffsetForLeaderPartition>();
			/// <summary>
			/// <para>Each partition to get offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to get offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopic WithPartitionsCollection(params Func<OffsetForLeaderPartition, OffsetForLeaderPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateOffsetForLeaderPartition()))
					.ToArray();
				return this;
			}

			internal OffsetForLeaderPartition CreateOffsetForLeaderPartition()
			{
				return new OffsetForLeaderPartition(Version);
			}

			public class OffsetForLeaderPartition : ISerialize
			{
				internal OffsetForLeaderPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(4, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Partition.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(2, 2147483647) ? 
						CurrentLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<OffsetForLeaderPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new OffsetForLeaderPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(2, 2147483647)) 
					{
						instance.CurrentLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(2, 2147483647)) 
					{
						await CurrentLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Partition does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetForLeaderPartition WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _currentLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CurrentLeaderEpoch 
				{
					get => _currentLeaderEpoch;
					set 
					{
						_currentLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>An epoch used to fence consumers/replicas with old metadata. If the epoch provided by the client is larger than the current epoch known to the broker, then the UNKNOWN_LEADER_EPOCH error code will be returned. If the provided epoch is smaller, then the FENCED_LEADER_EPOCH error code will be returned.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public OffsetForLeaderPartition WithCurrentLeaderEpoch(Int32 currentLeaderEpoch)
				{
					CurrentLeaderEpoch = currentLeaderEpoch;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The epoch to look up an offset for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch to look up an offset for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public OffsetForLeaderPartition WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}
			}
		}

		public OffsetForLeaderEpochResponse Respond()
			=> new OffsetForLeaderEpochResponse(Version);
	}

	public class OffsetForLeaderEpochResponse : Message
	{
		public OffsetForLeaderEpochResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"OffsetForLeaderEpochResponse does not support version {version}. Valid versions are: 0-4");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(23);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(4);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<OffsetForLeaderEpochResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new OffsetForLeaderEpochResponse(version);
			if (instance.Version.InRange(2, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = (await Array<OffsetForLeaderTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => OffsetForLeaderTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Topic);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderEpochResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(2, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<OffsetForLeaderTopicResult>.From(TopicsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 2+</para>
		/// </summary>
		public OffsetForLeaderEpochResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Dictionary<String, OffsetForLeaderTopicResult> _topicsCollection = new Dictionary<String, OffsetForLeaderTopicResult>();
		/// <summary>
		/// <para>Each topic we fetched offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, OffsetForLeaderTopicResult> TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic we fetched offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public OffsetForLeaderEpochResponse WithTopicsCollection(params Func<OffsetForLeaderTopicResult, OffsetForLeaderTopicResult>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateOffsetForLeaderTopicResult()))
				.ToDictionary(field => field.Topic);
			return this;
		}

		internal OffsetForLeaderTopicResult CreateOffsetForLeaderTopicResult()
		{
			return new OffsetForLeaderTopicResult(Version);
		}

		public class OffsetForLeaderTopicResult : ISerialize
		{
			internal OffsetForLeaderTopicResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Topic.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<EpochEndOffset>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<OffsetForLeaderTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new OffsetForLeaderTopicResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Topic = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<EpochEndOffset>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => EpochEndOffset.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for OffsetForLeaderTopicResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Topic.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<EpochEndOffset>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topic = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Topic 
			{
				get => _topic;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Topic does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topic = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopicResult WithTopic(String topic)
			{
				Topic = topic;
				return this;
			}

			private EpochEndOffset[] _partitionsCollection = Array.Empty<EpochEndOffset>();
			/// <summary>
			/// <para>Each partition in the topic we fetched offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public EpochEndOffset[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition in the topic we fetched offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public OffsetForLeaderTopicResult WithPartitionsCollection(params Func<EpochEndOffset, EpochEndOffset>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateEpochEndOffset()))
					.ToArray();
				return this;
			}

			internal EpochEndOffset CreateEpochEndOffset()
			{
				return new EpochEndOffset(Version);
			}

			public class EpochEndOffset : ISerialize
			{
				internal EpochEndOffset(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(4, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Partition.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						EndOffset.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<EpochEndOffset> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new EpochEndOffset(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Partition = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.EndOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for EpochEndOffset is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Partition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await EndOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code 0, or if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code 0, or if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EpochEndOffset WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _partition = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Partition 
				{
					get => _partition;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Partition does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partition = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public EpochEndOffset WithPartition(Int32 partition)
				{
					Partition = partition;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of the partition.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the partition.</para>
				/// <para>Versions: 1+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public EpochEndOffset WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Int64 _endOffset = new Int64(-1);
				/// <summary>
				/// <para>The end offset of the epoch.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 EndOffset 
				{
					get => _endOffset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"EndOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_endOffset = value;
					}
				}

				/// <summary>
				/// <para>The end offset of the epoch.</para>
				/// <para>Versions: 0+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public EpochEndOffset WithEndOffset(Int64 endOffset)
				{
					EndOffset = endOffset;
					return this;
				}
			}
		}
	}

	public class ProduceRequest : Message, IRespond<ProduceResponse>
	{
		public ProduceRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ProduceRequest does not support version {version}. Valid versions are: 0-9");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(9, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ProduceRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ProduceRequest(version);
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.TransactionalId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Acks = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicDataCollection = (await Array<TopicProduceData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicProduceData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ProduceRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(3, 2147483647)) 
			{
				await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Acks.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicProduceData>.From(TopicDataCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _transactionalId;
		/// <summary>
		/// <para>The transactional ID, or null if the producer is not transactional.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? TransactionalId 
		{
			get => _transactionalId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				if (Version.InRange(3, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support null for version {Version}. Supported versions for null value: 3+");
				}

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The transactional ID, or null if the producer is not transactional.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public ProduceRequest WithTransactionalId(String? transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private Int16 _acks = Int16.Default;
		/// <summary>
		/// <para>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Acks 
		{
			get => _acks;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Acks does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_acks = value;
			}
		}

		/// <summary>
		/// <para>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithAcks(Int16 acks)
		{
			Acks = acks;
			return this;
		}

		private Int32 _timeoutMs = Int32.Default;
		/// <summary>
		/// <para>The timeout to await a response in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>The timeout to await a response in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Dictionary<String, TopicProduceData> _topicDataCollection = new Dictionary<String, TopicProduceData>();
		/// <summary>
		/// <para>Each topic to produce to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, TopicProduceData> TopicDataCollection 
		{
			get => _topicDataCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicDataCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicDataCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic to produce to.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceRequest WithTopicDataCollection(params Func<TopicProduceData, TopicProduceData>[] createFields)
		{
			TopicDataCollection = createFields
				.Select(createField => createField(CreateTopicProduceData()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal TopicProduceData CreateTopicProduceData()
		{
			return new TopicProduceData(Version);
		}

		public class TopicProduceData : ISerialize
		{
			internal TopicProduceData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(9, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionProduceData>.From(PartitionDataCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicProduceData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicProduceData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionDataCollection = await Array<PartitionProduceData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionProduceData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicProduceData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionProduceData>.From(PartitionDataCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceData WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionProduceData[] _partitionDataCollection = Array.Empty<PartitionProduceData>();
			/// <summary>
			/// <para>Each partition to produce to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionProduceData[] PartitionDataCollection 
			{
				get => _partitionDataCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionDataCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionDataCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition to produce to.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceData WithPartitionDataCollection(params Func<PartitionProduceData, PartitionProduceData>[] createFields)
			{
				PartitionDataCollection = createFields
					.Select(createField => createField(CreatePartitionProduceData()))
					.ToArray();
				return this;
			}

			internal PartitionProduceData CreatePartitionProduceData()
			{
				return new PartitionProduceData(Version);
			}

			public class PartitionProduceData : ISerialize
			{
				internal PartitionProduceData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(9, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Index.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Records.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionProduceData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionProduceData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Index = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Records = await NullableRecordBatch.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionProduceData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Index.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Records.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _index = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Index 
				{
					get => _index;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Index does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_index = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceData WithIndex(Int32 index)
				{
					Index = index;
					return this;
				}

				private Records.RecordBatch? _records;
				/// <summary>
				/// <para>The record data to be produced.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Records.RecordBatch? Records 
				{
					get => _records;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Records does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"Records does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_records = value;
					}
				}

				/// <summary>
				/// <para>The record data to be produced.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceData WithRecords(Records.RecordBatch? records)
				{
					Records = records;
					return this;
				}
			}
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class ProduceResponse : Message
	{
		public ProduceResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ProduceResponse does not support version {version}. Valid versions are: 0-9");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(9, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(9);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ProduceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ProduceResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResponsesCollection = (await Array<TopicProduceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicProduceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Name);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ProduceResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicProduceResponse>.From(ResponsesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Dictionary<String, TopicProduceResponse> _responsesCollection = new Dictionary<String, TopicProduceResponse>();
		/// <summary>
		/// <para>Each produce response</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, TopicProduceResponse> ResponsesCollection 
		{
			get => _responsesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_responsesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each produce response</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ProduceResponse WithResponsesCollection(params Func<TopicProduceResponse, TopicProduceResponse>[] createFields)
		{
			ResponsesCollection = createFields
				.Select(createField => createField(CreateTopicProduceResponse()))
				.ToDictionary(field => field.Name);
			return this;
		}

		internal TopicProduceResponse CreateTopicProduceResponse()
		{
			return new TopicProduceResponse(Version);
		}

		public class TopicProduceResponse : ISerialize
		{
			internal TopicProduceResponse(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(9, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionProduceResponse>.From(PartitionResponsesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicProduceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicProduceResponse(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionResponsesCollection = await Array<PartitionProduceResponse>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionProduceResponse.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicProduceResponse is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionProduceResponse>.From(PartitionResponsesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceResponse WithName(String name)
			{
				Name = name;
				return this;
			}

			private PartitionProduceResponse[] _partitionResponsesCollection = Array.Empty<PartitionProduceResponse>();
			/// <summary>
			/// <para>Each partition that we produced to within the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionProduceResponse[] PartitionResponsesCollection 
			{
				get => _partitionResponsesCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionResponsesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionResponsesCollection = value;
				}
			}

			/// <summary>
			/// <para>Each partition that we produced to within the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicProduceResponse WithPartitionResponsesCollection(params Func<PartitionProduceResponse, PartitionProduceResponse>[] createFields)
			{
				PartitionResponsesCollection = createFields
					.Select(createField => createField(CreatePartitionProduceResponse()))
					.ToArray();
				return this;
			}

			internal PartitionProduceResponse CreatePartitionProduceResponse()
			{
				return new PartitionProduceResponse(Version);
			}

			public class PartitionProduceResponse : ISerialize
			{
				internal PartitionProduceResponse(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(9, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Index.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						BaseOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(2, 2147483647) ? 
						LogAppendTimeMs.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(5, 2147483647) ? 
						LogStartOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(8, 2147483647) ? 
						Array<BatchIndexAndErrorMessage>.From(RecordErrorsCollection).GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(8, 2147483647) ? 
						ErrorMessage.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionProduceResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionProduceResponse(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Index = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.BaseOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(2, 2147483647)) 
					{
						instance.LogAppendTimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(5, 2147483647)) 
					{
						instance.LogStartOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(8, 2147483647)) 
					{
						instance.RecordErrorsCollection = await Array<BatchIndexAndErrorMessage>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => BatchIndexAndErrorMessage.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(8, 2147483647)) 
					{
						instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionProduceResponse is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Index.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await BaseOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(2, 2147483647)) 
					{
						await LogAppendTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(5, 2147483647)) 
					{
						await LogStartOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(8, 2147483647)) 
					{
						await Array<BatchIndexAndErrorMessage>.From(RecordErrorsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(8, 2147483647)) 
					{
						await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _index = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 Index 
				{
					get => _index;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Index does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_index = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceResponse WithIndex(Int32 index)
				{
					Index = index;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceResponse WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int64 _baseOffset = Int64.Default;
				/// <summary>
				/// <para>The base offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 BaseOffset 
				{
					get => _baseOffset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"BaseOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_baseOffset = value;
					}
				}

				/// <summary>
				/// <para>The base offset.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionProduceResponse WithBaseOffset(Int64 baseOffset)
				{
					BaseOffset = baseOffset;
					return this;
				}

				private Int64 _logAppendTimeMs = new Int64(-1);
				/// <summary>
				/// <para>The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1.  If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogAppendTimeMs 
				{
					get => _logAppendTimeMs;
					set 
					{
						_logAppendTimeMs = value;
					}
				}

				/// <summary>
				/// <para>The timestamp returned by broker after appending the messages. If CreateTime is used for the topic, the timestamp will be -1.  If LogAppendTime is used for the topic, the timestamp will be the broker local time when the messages are appended.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionProduceResponse WithLogAppendTimeMs(Int64 logAppendTimeMs)
				{
					LogAppendTimeMs = logAppendTimeMs;
					return this;
				}

				private Int64 _logStartOffset = new Int64(-1);
				/// <summary>
				/// <para>The log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int64 LogStartOffset 
				{
					get => _logStartOffset;
					set 
					{
						_logStartOffset = value;
					}
				}

				/// <summary>
				/// <para>The log start offset.</para>
				/// <para>Versions: 5+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public PartitionProduceResponse WithLogStartOffset(Int64 logStartOffset)
				{
					LogStartOffset = logStartOffset;
					return this;
				}

				private BatchIndexAndErrorMessage[] _recordErrorsCollection = Array.Empty<BatchIndexAndErrorMessage>();
				/// <summary>
				/// <para>The batch indices of records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public BatchIndexAndErrorMessage[] RecordErrorsCollection 
				{
					get => _recordErrorsCollection;
					set 
					{
						_recordErrorsCollection = value;
					}
				}

				/// <summary>
				/// <para>The batch indices of records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// </summary>
				public PartitionProduceResponse WithRecordErrorsCollection(params Func<BatchIndexAndErrorMessage, BatchIndexAndErrorMessage>[] createFields)
				{
					RecordErrorsCollection = createFields
						.Select(createField => createField(CreateBatchIndexAndErrorMessage()))
						.ToArray();
					return this;
				}

				internal BatchIndexAndErrorMessage CreateBatchIndexAndErrorMessage()
				{
					return new BatchIndexAndErrorMessage(Version);
				}

				public class BatchIndexAndErrorMessage : ISerialize
				{
					internal BatchIndexAndErrorMessage(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(9, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(8, 2147483647) ? 
							BatchIndex.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(8, 2147483647) ? 
							BatchIndexErrorMessage.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<BatchIndexAndErrorMessage> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new BatchIndexAndErrorMessage(version);
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.BatchIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(8, 2147483647)) 
						{
							instance.BatchIndexErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for BatchIndexAndErrorMessage is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(8, 2147483647)) 
						{
							await BatchIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(8, 2147483647)) 
						{
							await BatchIndexErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _batchIndex = Int32.Default;
					/// <summary>
					/// <para>The batch index of the record that cause the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public Int32 BatchIndex 
					{
						get => _batchIndex;
						set 
						{
							if (Version.InRange(8, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"BatchIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
							}

							_batchIndex = value;
						}
					}

					/// <summary>
					/// <para>The batch index of the record that cause the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// </summary>
					public BatchIndexAndErrorMessage WithBatchIndex(Int32 batchIndex)
					{
						BatchIndex = batchIndex;
						return this;
					}

					private String? _batchIndexErrorMessage;
					/// <summary>
					/// <para>The error message of the record that caused the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: null</para>
					/// </summary>
					public String? BatchIndexErrorMessage 
					{
						get => _batchIndexErrorMessage;
						set 
						{
							if (Version.InRange(8, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"BatchIndexErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 8+");
							}

							if (Version.InRange(8, 2147483647) == false &&
								value == null) 
							{
								throw new UnsupportedVersionException($"BatchIndexErrorMessage does not support null for version {Version}. Supported versions for null value: 8+");
							}

							_batchIndexErrorMessage = value;
						}
					}

					/// <summary>
					/// <para>The error message of the record that caused the batch to be dropped</para>
					/// <para>Versions: 8+</para>
					/// <para>Default: null</para>
					/// </summary>
					public BatchIndexAndErrorMessage WithBatchIndexErrorMessage(String? batchIndexErrorMessage)
					{
						BatchIndexErrorMessage = batchIndexErrorMessage;
						return this;
					}
				}

				private String? _errorMessage;
				/// <summary>
				/// <para>The global error message summarizing the common root cause of the records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// <para>Default: null</para>
				/// </summary>
				public String? ErrorMessage 
				{
					get => _errorMessage;
					set 
					{
						if (Version.InRange(8, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 8+");
						}

						_errorMessage = value;
					}
				}

				/// <summary>
				/// <para>The global error message summarizing the common root cause of the records that caused the batch to be dropped</para>
				/// <para>Versions: 8+</para>
				/// <para>Default: null</para>
				/// </summary>
				public PartitionProduceResponse WithErrorMessage(String? errorMessage)
				{
					ErrorMessage = errorMessage;
					return this;
				}
			}
		}

		private Int32 _throttleTimeMs = new Int32(0);
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public ProduceResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class RenewDelegationTokenRequest : Message, IRespond<RenewDelegationTokenResponse>
	{
		public RenewDelegationTokenRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"RenewDelegationTokenRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(39);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<RenewDelegationTokenRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RenewDelegationTokenRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Hmac = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RenewPeriodMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RenewDelegationTokenRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Hmac.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await RenewPeriodMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Bytes _hmac = Bytes.Default;
		/// <summary>
		/// <para>The HMAC of the delegation token to be renewed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Hmac 
		{
			get => _hmac;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Hmac does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_hmac = value;
			}
		}

		/// <summary>
		/// <para>The HMAC of the delegation token to be renewed.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenRequest WithHmac(Bytes hmac)
		{
			Hmac = hmac;
			return this;
		}

		private Int64 _renewPeriodMs = Int64.Default;
		/// <summary>
		/// <para>The renewal time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 RenewPeriodMs 
		{
			get => _renewPeriodMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RenewPeriodMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_renewPeriodMs = value;
			}
		}

		/// <summary>
		/// <para>The renewal time period in milliseconds.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenRequest WithRenewPeriodMs(Int64 renewPeriodMs)
		{
			RenewPeriodMs = renewPeriodMs;
			return this;
		}

		public RenewDelegationTokenResponse Respond()
			=> new RenewDelegationTokenResponse(Version);
	}

	public class RenewDelegationTokenResponse : Message
	{
		public RenewDelegationTokenResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"RenewDelegationTokenResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(39);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<RenewDelegationTokenResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RenewDelegationTokenResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ExpiryTimestampMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RenewDelegationTokenResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ExpiryTimestampMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private Int64 _expiryTimestampMs = Int64.Default;
		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ExpiryTimestampMs 
		{
			get => _expiryTimestampMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ExpiryTimestampMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_expiryTimestampMs = value;
			}
		}

		/// <summary>
		/// <para>The timestamp in milliseconds at which this token expires.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenResponse WithExpiryTimestampMs(Int64 expiryTimestampMs)
		{
			ExpiryTimestampMs = expiryTimestampMs;
			return this;
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RenewDelegationTokenResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}
	}

	public class RequestHeader : Message, IRespond<ProduceResponse>
	{
		public RequestHeader(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"RequestHeader does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<RequestHeader> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new RequestHeader(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RequestApiKey = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.RequestApiVersion = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.CorrelationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ClientId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for RequestHeader is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await RequestApiKey.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await RequestApiVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await CorrelationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await ClientId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _requestApiKey = Int16.Default;
		/// <summary>
		/// <para>The API key of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 RequestApiKey 
		{
			get => _requestApiKey;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RequestApiKey does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_requestApiKey = value;
			}
		}

		/// <summary>
		/// <para>The API key of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RequestHeader WithRequestApiKey(Int16 requestApiKey)
		{
			RequestApiKey = requestApiKey;
			return this;
		}

		private Int16 _requestApiVersion = Int16.Default;
		/// <summary>
		/// <para>The API version of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 RequestApiVersion 
		{
			get => _requestApiVersion;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"RequestApiVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_requestApiVersion = value;
			}
		}

		/// <summary>
		/// <para>The API version of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RequestHeader WithRequestApiVersion(Int16 requestApiVersion)
		{
			RequestApiVersion = requestApiVersion;
			return this;
		}

		private Int32 _correlationId = Int32.Default;
		/// <summary>
		/// <para>The correlation ID of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 CorrelationId 
		{
			get => _correlationId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"CorrelationId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_correlationId = value;
			}
		}

		/// <summary>
		/// <para>The correlation ID of this request.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public RequestHeader WithCorrelationId(Int32 correlationId)
		{
			CorrelationId = correlationId;
			return this;
		}

		private String? _clientId;
		/// <summary>
		/// <para>The client ID string.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public String? ClientId 
		{
			get => _clientId;
			set 
			{
				if (Version.InRange(1, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClientId does not support null for version {Version}. Supported versions for null value: 1+");
				}

				_clientId = value;
			}
		}

		/// <summary>
		/// <para>The client ID string.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public RequestHeader WithClientId(String? clientId)
		{
			ClientId = clientId;
			return this;
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class ResponseHeader : Message, IRespond<ProduceResponse>
	{
		public ResponseHeader(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"ResponseHeader does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<ResponseHeader> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new ResponseHeader(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.CorrelationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for ResponseHeader is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await CorrelationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _correlationId = Int32.Default;
		/// <summary>
		/// <para>The correlation ID of this response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 CorrelationId 
		{
			get => _correlationId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"CorrelationId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_correlationId = value;
			}
		}

		/// <summary>
		/// <para>The correlation ID of this response.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public ResponseHeader WithCorrelationId(Int32 correlationId)
		{
			CorrelationId = correlationId;
			return this;
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class SaslAuthenticateRequest : Message, IRespond<SaslAuthenticateResponse>
	{
		public SaslAuthenticateRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SaslAuthenticateRequest does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(36);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SaslAuthenticateRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslAuthenticateRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.AuthBytes = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslAuthenticateRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await AuthBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Bytes _authBytes = Bytes.Default;
		/// <summary>
		/// <para>The SASL authentication bytes from the client, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes AuthBytes 
		{
			get => _authBytes;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"AuthBytes does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_authBytes = value;
			}
		}

		/// <summary>
		/// <para>The SASL authentication bytes from the client, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateRequest WithAuthBytes(Bytes authBytes)
		{
			AuthBytes = authBytes;
			return this;
		}

		public SaslAuthenticateResponse Respond()
			=> new SaslAuthenticateResponse(Version);
	}

	public class SaslAuthenticateResponse : Message
	{
		public SaslAuthenticateResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SaslAuthenticateResponse does not support version {version}. Valid versions are: 0-2");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(36);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(2);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SaslAuthenticateResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslAuthenticateResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.AuthBytes = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.SessionLifetimeMs = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslAuthenticateResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await AuthBytes.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await SessionLifetimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The error message, or null if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Bytes _authBytes = Bytes.Default;
		/// <summary>
		/// <para>The SASL authentication bytes from the server, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes AuthBytes 
		{
			get => _authBytes;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"AuthBytes does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_authBytes = value;
			}
		}

		/// <summary>
		/// <para>The SASL authentication bytes from the server, as defined by the SASL mechanism.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslAuthenticateResponse WithAuthBytes(Bytes authBytes)
		{
			AuthBytes = authBytes;
			return this;
		}

		private Int64 _sessionLifetimeMs = new Int64(0);
		/// <summary>
		/// <para>The SASL authentication bytes from the server, as defined by the SASL mechanism.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public Int64 SessionLifetimeMs 
		{
			get => _sessionLifetimeMs;
			set 
			{
				_sessionLifetimeMs = value;
			}
		}

		/// <summary>
		/// <para>The SASL authentication bytes from the server, as defined by the SASL mechanism.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: 0</para>
		/// </summary>
		public SaslAuthenticateResponse WithSessionLifetimeMs(Int64 sessionLifetimeMs)
		{
			SessionLifetimeMs = sessionLifetimeMs;
			return this;
		}
	}

	public class SaslHandshakeRequest : Message, IRespond<SaslHandshakeResponse>
	{
		public SaslHandshakeRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SaslHandshakeRequest does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(17);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SaslHandshakeRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslHandshakeRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Mechanism = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslHandshakeRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Mechanism.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _mechanism = String.Default;
		/// <summary>
		/// <para>The SASL mechanism chosen by the client.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String Mechanism 
		{
			get => _mechanism;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Mechanism does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_mechanism = value;
			}
		}

		/// <summary>
		/// <para>The SASL mechanism chosen by the client.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslHandshakeRequest WithMechanism(String mechanism)
		{
			Mechanism = mechanism;
			return this;
		}

		public SaslHandshakeResponse Respond()
			=> new SaslHandshakeResponse(Version);
	}

	public class SaslHandshakeResponse : Message
	{
		public SaslHandshakeResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SaslHandshakeResponse does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, -1);
		}

		public static readonly Int16 ApiKey = Int16.From(17);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SaslHandshakeResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SaslHandshakeResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MechanismsCollection = await Array<String>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SaslHandshakeResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<String>.From(MechanismsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslHandshakeResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String[] _mechanismsCollection = Array.Empty<String>();
		/// <summary>
		/// <para>The mechanisms enabled in the server.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String[] MechanismsCollection 
		{
			get => _mechanismsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MechanismsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_mechanismsCollection = value;
			}
		}

		/// <summary>
		/// <para>The mechanisms enabled in the server.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SaslHandshakeResponse WithMechanismsCollection(String[] mechanismsCollection)
		{
			MechanismsCollection = mechanismsCollection;
			return this;
		}
	}

	public class SnapshotFooterRecord : Message, IRespond<ProduceResponse>
	{
		public SnapshotFooterRecord(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SnapshotFooterRecord does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SnapshotFooterRecord> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SnapshotFooterRecord(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotFooterRecord is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Version_.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the snapshot footer record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Version_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the snapshot footer record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SnapshotFooterRecord WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class SnapshotHeaderRecord : Message, IRespond<ProduceResponse>
	{
		public SnapshotHeaderRecord(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SnapshotHeaderRecord does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(0);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SnapshotHeaderRecord> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SnapshotHeaderRecord(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Version_ = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.LastContainedLogTimestamp = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SnapshotHeaderRecord is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Version_.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await LastContainedLogTimestamp.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _version = Int16.Default;
		/// <summary>
		/// <para>The version of the snapshot header record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 Version_ 
		{
			get => _version;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Version_ does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_version = value;
			}
		}

		/// <summary>
		/// <para>The version of the snapshot header record</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SnapshotHeaderRecord WithVersion_(Int16 version)
		{
			Version_ = version;
			return this;
		}

		private Int64 _lastContainedLogTimestamp = Int64.Default;
		/// <summary>
		/// <para>The append time of the last record from the log contained in this snapshot</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 LastContainedLogTimestamp 
		{
			get => _lastContainedLogTimestamp;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"LastContainedLogTimestamp does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_lastContainedLogTimestamp = value;
			}
		}

		/// <summary>
		/// <para>The append time of the last record from the log contained in this snapshot</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SnapshotHeaderRecord WithLastContainedLogTimestamp(Int64 lastContainedLogTimestamp)
		{
			LastContainedLogTimestamp = lastContainedLogTimestamp;
			return this;
		}

		public ProduceResponse Respond()
			=> new ProduceResponse(Version);
	}

	public class StopReplicaRequest : Message, IRespond<StopReplicaResponse>
	{
		public StopReplicaRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"StopReplicaRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(5);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<StopReplicaRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new StopReplicaRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2)) 
			{
				instance.DeletePartitions = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 0)) 
			{
				instance.UngroupedPartitionsCollection = await Array<StopReplicaPartitionV0>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaPartitionV0.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(1, 2)) 
			{
				instance.TopicsCollection = await Array<StopReplicaTopicV1>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaTopicV1.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.TopicStatesCollection = await Array<StopReplicaTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2)) 
			{
				await DeletePartitions.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 0)) 
			{
				await Array<StopReplicaPartitionV0>.From(UngroupedPartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(1, 2)) 
			{
				await Array<StopReplicaTopicV1>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await Array<StopReplicaTopicState>.From(TopicStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Int32 _controllerEpoch = Int32.Default;
		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerEpoch 
		{
			get => _controllerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaRequest WithControllerEpoch(Int32 controllerEpoch)
		{
			ControllerEpoch = controllerEpoch;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 1+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public StopReplicaRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private Boolean _deletePartitions = Boolean.Default;
		/// <summary>
		/// <para>Whether these partitions should be deleted.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public Boolean DeletePartitions 
		{
			get => _deletePartitions;
			set 
			{
				if (Version.InRange(0, 2) == false) 
				{
					throw new UnsupportedVersionException($"DeletePartitions does not support version {Version} and has been defined as not ignorable. Supported versions: 0-2");
				}

				_deletePartitions = value;
			}
		}

		/// <summary>
		/// <para>Whether these partitions should be deleted.</para>
		/// <para>Versions: 0-2</para>
		/// </summary>
		public StopReplicaRequest WithDeletePartitions(Boolean deletePartitions)
		{
			DeletePartitions = deletePartitions;
			return this;
		}

		private StopReplicaPartitionV0[] _ungroupedPartitionsCollection = Array.Empty<StopReplicaPartitionV0>();
		/// <summary>
		/// <para>The partitions to stop.</para>
		/// <para>Versions: 0</para>
		/// </summary>
		public StopReplicaPartitionV0[] UngroupedPartitionsCollection 
		{
			get => _ungroupedPartitionsCollection;
			set 
			{
				if (Version.InRange(0, 0) == false) 
				{
					throw new UnsupportedVersionException($"UngroupedPartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0");
				}

				_ungroupedPartitionsCollection = value;
			}
		}

		/// <summary>
		/// <para>The partitions to stop.</para>
		/// <para>Versions: 0</para>
		/// </summary>
		public StopReplicaRequest WithUngroupedPartitionsCollection(params Func<StopReplicaPartitionV0, StopReplicaPartitionV0>[] createFields)
		{
			UngroupedPartitionsCollection = createFields
				.Select(createField => createField(CreateStopReplicaPartitionV0()))
				.ToArray();
			return this;
		}

		internal StopReplicaPartitionV0 CreateStopReplicaPartitionV0()
		{
			return new StopReplicaPartitionV0(Version);
		}

		public class StopReplicaPartitionV0 : ISerialize
		{
			internal StopReplicaPartitionV0(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 0) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 0) ? 
					PartitionIndex.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<StopReplicaPartitionV0> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaPartitionV0(version);
				if (instance.Version.InRange(0, 0)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 0)) 
				{
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaPartitionV0 is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 0)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 0)) 
				{
					await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 0) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public StopReplicaPartitionV0 WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				set 
				{
					if (Version.InRange(0, 0) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0");
					}

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public StopReplicaPartitionV0 WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}
		}

		private StopReplicaTopicV1[] _topicsCollection = Array.Empty<StopReplicaTopicV1>();
		/// <summary>
		/// <para>The topics to stop.</para>
		/// <para>Versions: 1-2</para>
		/// </summary>
		public StopReplicaTopicV1[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(1, 2) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1-2");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The topics to stop.</para>
		/// <para>Versions: 1-2</para>
		/// </summary>
		public StopReplicaRequest WithTopicsCollection(params Func<StopReplicaTopicV1, StopReplicaTopicV1>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateStopReplicaTopicV1()))
				.ToArray();
			return this;
		}

		internal StopReplicaTopicV1 CreateStopReplicaTopicV1()
		{
			return new StopReplicaTopicV1(Version);
		}

		public class StopReplicaTopicV1 : ISerialize
		{
			internal StopReplicaTopicV1(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(1, 2) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2) ? 
					Array<Int32>.From(PartitionIndexesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<StopReplicaTopicV1> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaTopicV1(version);
				if (instance.Version.InRange(1, 2)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2)) 
				{
					instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaTopicV1 is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(1, 2)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2)) 
				{
					await Array<Int32>.From(PartitionIndexesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(1, 2) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 1-2");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public StopReplicaTopicV1 WithName(String name)
			{
				Name = name;
				return this;
			}

			private Int32[] _partitionIndexesCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public Int32[] PartitionIndexesCollection 
			{
				get => _partitionIndexesCollection;
				set 
				{
					if (Version.InRange(1, 2) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 1-2");
					}

					_partitionIndexesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition indexes.</para>
			/// <para>Versions: 1-2</para>
			/// </summary>
			public StopReplicaTopicV1 WithPartitionIndexesCollection(Int32[] partitionIndexesCollection)
			{
				PartitionIndexesCollection = partitionIndexesCollection;
				return this;
			}
		}

		private StopReplicaTopicState[] _topicStatesCollection = Array.Empty<StopReplicaTopicState>();
		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public StopReplicaTopicState[] TopicStatesCollection 
		{
			get => _topicStatesCollection;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_topicStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic.</para>
		/// <para>Versions: 3+</para>
		/// </summary>
		public StopReplicaRequest WithTopicStatesCollection(params Func<StopReplicaTopicState, StopReplicaTopicState>[] createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(CreateStopReplicaTopicState()))
				.ToArray();
			return this;
		}

		internal StopReplicaTopicState CreateStopReplicaTopicState()
		{
			return new StopReplicaTopicState(Version);
		}

		public class StopReplicaTopicState : ISerialize
		{
			internal StopReplicaTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(3, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(3, 2147483647) ? 
					Array<StopReplicaPartitionState>.From(PartitionStatesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<StopReplicaTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaTopicState(version);
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(3, 2147483647)) 
				{
					instance.PartitionStatesCollection = await Array<StopReplicaPartitionState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaTopicState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(3, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(3, 2147483647)) 
				{
					await Array<StopReplicaPartitionState>.From(PartitionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public StopReplicaTopicState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private StopReplicaPartitionState[] _partitionStatesCollection = Array.Empty<StopReplicaPartitionState>();
			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public StopReplicaPartitionState[] PartitionStatesCollection 
			{
				get => _partitionStatesCollection;
				set 
				{
					if (Version.InRange(3, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
					}

					_partitionStatesCollection = value;
				}
			}

			/// <summary>
			/// <para>The state of each partition</para>
			/// <para>Versions: 3+</para>
			/// </summary>
			public StopReplicaTopicState WithPartitionStatesCollection(params Func<StopReplicaPartitionState, StopReplicaPartitionState>[] createFields)
			{
				PartitionStatesCollection = createFields
					.Select(createField => createField(CreateStopReplicaPartitionState()))
					.ToArray();
				return this;
			}

			internal StopReplicaPartitionState CreateStopReplicaPartitionState()
			{
				return new StopReplicaPartitionState(Version);
			}

			public class StopReplicaPartitionState : ISerialize
			{
				internal StopReplicaPartitionState(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(2, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(3, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(3, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(3, 2147483647) ? 
						DeletePartition.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<StopReplicaPartitionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new StopReplicaPartitionState(version);
					if (instance.Version.InRange(3, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(3, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(3, 2147483647)) 
					{
						instance.DeletePartition = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaPartitionState is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(3, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(3, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(3, 2147483647)) 
					{
						await DeletePartition.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(3, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public StopReplicaPartitionState WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _leaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(3, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch.</para>
				/// <para>Versions: 3+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public StopReplicaPartitionState WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Boolean _deletePartition = Boolean.Default;
				/// <summary>
				/// <para>Whether this partition should be deleted.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public Boolean DeletePartition 
				{
					get => _deletePartition;
					set 
					{
						if (Version.InRange(3, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"DeletePartition does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
						}

						_deletePartition = value;
					}
				}

				/// <summary>
				/// <para>Whether this partition should be deleted.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public StopReplicaPartitionState WithDeletePartition(Boolean deletePartition)
				{
					DeletePartition = deletePartition;
					return this;
				}
			}
		}

		public StopReplicaResponse Respond()
			=> new StopReplicaResponse(Version);
	}

	public class StopReplicaResponse : Message
	{
		public StopReplicaResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"StopReplicaResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(2, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(5);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<StopReplicaResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new StopReplicaResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.PartitionErrorsCollection = await Array<StopReplicaPartitionError>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => StopReplicaPartitionError.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<StopReplicaPartitionError>.From(PartitionErrorsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or 0 if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or 0 if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private StopReplicaPartitionError[] _partitionErrorsCollection = Array.Empty<StopReplicaPartitionError>();
		/// <summary>
		/// <para>The responses for each partition.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaPartitionError[] PartitionErrorsCollection 
		{
			get => _partitionErrorsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"PartitionErrorsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_partitionErrorsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each partition.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public StopReplicaResponse WithPartitionErrorsCollection(params Func<StopReplicaPartitionError, StopReplicaPartitionError>[] createFields)
		{
			PartitionErrorsCollection = createFields
				.Select(createField => createField(CreateStopReplicaPartitionError()))
				.ToArray();
			return this;
		}

		internal StopReplicaPartitionError CreateStopReplicaPartitionError()
		{
			return new StopReplicaPartitionError(Version);
		}

		public class StopReplicaPartitionError : ISerialize
		{
			internal StopReplicaPartitionError(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(2, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PartitionIndex.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<StopReplicaPartitionError> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new StopReplicaPartitionError(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for StopReplicaPartitionError is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public StopReplicaPartitionError WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public StopReplicaPartitionError WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The partition error code, or 0 if there was no partition error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The partition error code, or 0 if there was no partition error.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public StopReplicaPartitionError WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}
		}
	}

	public class SyncGroupRequest : Message, IRespond<SyncGroupResponse>
	{
		public SyncGroupRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SyncGroupRequest does not support version {version}. Valid versions are: 0-5");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(14);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SyncGroupRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SyncGroupRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.ProtocolType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.ProtocolName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.AssignmentsCollection = await Array<SyncGroupRequestAssignment>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => SyncGroupRequestAssignment.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SyncGroupRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await GenerationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await ProtocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await ProtocolName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<SyncGroupRequestAssignment>.From(AssignmentsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The unique group identifier.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int32 _generationId = Int32.Default;
		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GenerationId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = String.Default;
		/// <summary>
		/// <para>The member ID assigned by the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private String? _groupInstanceId;
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				if (Version.InRange(3, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");
				}

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private String? _protocolType;
		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolType 
		{
			get => _protocolType;
			set 
			{
				if (Version.InRange(5, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ProtocolType does not support null for version {Version}. Supported versions for null value: 5+");
				}

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupRequest WithProtocolType(String? protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private String? _protocolName;
		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolName 
		{
			get => _protocolName;
			set 
			{
				if (Version.InRange(5, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ProtocolName does not support null for version {Version}. Supported versions for null value: 5+");
				}

				_protocolName = value;
			}
		}

		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupRequest WithProtocolName(String? protocolName)
		{
			ProtocolName = protocolName;
			return this;
		}

		private SyncGroupRequestAssignment[] _assignmentsCollection = Array.Empty<SyncGroupRequestAssignment>();
		/// <summary>
		/// <para>Each assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequestAssignment[] AssignmentsCollection 
		{
			get => _assignmentsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"AssignmentsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_assignmentsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupRequest WithAssignmentsCollection(params Func<SyncGroupRequestAssignment, SyncGroupRequestAssignment>[] createFields)
		{
			AssignmentsCollection = createFields
				.Select(createField => createField(CreateSyncGroupRequestAssignment()))
				.ToArray();
			return this;
		}

		internal SyncGroupRequestAssignment CreateSyncGroupRequestAssignment()
		{
			return new SyncGroupRequestAssignment(Version);
		}

		public class SyncGroupRequestAssignment : ISerialize
		{
			internal SyncGroupRequestAssignment(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(4, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					MemberId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Assignment.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<SyncGroupRequestAssignment> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new SyncGroupRequestAssignment(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Assignment = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for SyncGroupRequestAssignment is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _memberId = String.Default;
			/// <summary>
			/// <para>The ID of the member to assign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String MemberId 
			{
				get => _memberId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_memberId = value;
				}
			}

			/// <summary>
			/// <para>The ID of the member to assign.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public SyncGroupRequestAssignment WithMemberId(String memberId)
			{
				MemberId = memberId;
				return this;
			}

			private Bytes _assignment = Bytes.Default;
			/// <summary>
			/// <para>The member assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Bytes Assignment 
			{
				get => _assignment;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Assignment does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_assignment = value;
				}
			}

			/// <summary>
			/// <para>The member assignment.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public SyncGroupRequestAssignment WithAssignment(Bytes assignment)
			{
				Assignment = assignment;
				return this;
			}
		}

		public SyncGroupResponse Respond()
			=> new SyncGroupResponse(Version);
	}

	public class SyncGroupResponse : Message
	{
		public SyncGroupResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"SyncGroupResponse does not support version {version}. Valid versions are: 0-5");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(4, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(14);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(5);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<SyncGroupResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new SyncGroupResponse(version);
			if (instance.Version.InRange(1, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.ProtocolType = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.ProtocolName = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.Assignment = await Bytes.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for SyncGroupResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(1, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await ProtocolType.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await ProtocolName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Assignment.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 1+</para>
		/// </summary>
		public SyncGroupResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _protocolType;
		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolType 
		{
			get => _protocolType;
			set 
			{
				if (Version.InRange(5, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ProtocolType does not support null for version {Version}. Supported versions for null value: 5+");
				}

				_protocolType = value;
			}
		}

		/// <summary>
		/// <para>The group protocol type.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupResponse WithProtocolType(String? protocolType)
		{
			ProtocolType = protocolType;
			return this;
		}

		private String? _protocolName;
		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ProtocolName 
		{
			get => _protocolName;
			set 
			{
				if (Version.InRange(5, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ProtocolName does not support null for version {Version}. Supported versions for null value: 5+");
				}

				_protocolName = value;
			}
		}

		/// <summary>
		/// <para>The group protocol name.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: null</para>
		/// </summary>
		public SyncGroupResponse WithProtocolName(String? protocolName)
		{
			ProtocolName = protocolName;
			return this;
		}

		private Bytes _assignment = Bytes.Default;
		/// <summary>
		/// <para>The member assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Bytes Assignment 
		{
			get => _assignment;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"Assignment does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_assignment = value;
			}
		}

		/// <summary>
		/// <para>The member assignment.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public SyncGroupResponse WithAssignment(Bytes assignment)
		{
			Assignment = assignment;
			return this;
		}
	}

	public class TxnOffsetCommitRequest : Message, IRespond<TxnOffsetCommitResponse>
	{
		public TxnOffsetCommitRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"TxnOffsetCommitRequest does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(28);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<TxnOffsetCommitRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new TxnOffsetCommitRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TransactionalId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.GroupId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.GenerationId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.MemberId = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(3, 2147483647)) 
			{
				instance.GroupInstanceId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TxnOffsetCommitRequestTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitRequestTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TransactionalId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await GroupId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await GenerationId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await MemberId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(3, 2147483647)) 
			{
				await GroupInstanceId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TxnOffsetCommitRequestTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String _transactionalId = String.Default;
		/// <summary>
		/// <para>The ID of the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String TransactionalId 
		{
			get => _transactionalId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TransactionalId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_transactionalId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the transaction.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithTransactionalId(String transactionalId)
		{
			TransactionalId = transactionalId;
			return this;
		}

		private String _groupId = String.Default;
		/// <summary>
		/// <para>The ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String GroupId 
		{
			get => _groupId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_groupId = value;
			}
		}

		/// <summary>
		/// <para>The ID of the group.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithGroupId(String groupId)
		{
			GroupId = groupId;
			return this;
		}

		private Int64 _producerId = Int64.Default;
		/// <summary>
		/// <para>The current producer ID in use by the transactional ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int64 ProducerId 
		{
			get => _producerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerId = value;
			}
		}

		/// <summary>
		/// <para>The current producer ID in use by the transactional ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithProducerId(Int64 producerId)
		{
			ProducerId = producerId;
			return this;
		}

		private Int16 _producerEpoch = Int16.Default;
		/// <summary>
		/// <para>The current epoch associated with the producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ProducerEpoch 
		{
			get => _producerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_producerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The current epoch associated with the producer ID.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithProducerEpoch(Int16 producerEpoch)
		{
			ProducerEpoch = producerEpoch;
			return this;
		}

		private Int32 _generationId = new Int32(-1);
		/// <summary>
		/// <para>The generation of the consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int32 GenerationId 
		{
			get => _generationId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GenerationId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_generationId = value;
			}
		}

		/// <summary>
		/// <para>The generation of the consumer.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public TxnOffsetCommitRequest WithGenerationId(Int32 generationId)
		{
			GenerationId = generationId;
			return this;
		}

		private String _memberId = new String();
		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public String MemberId 
		{
			get => _memberId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MemberId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				_memberId = value;
			}
		}

		/// <summary>
		/// <para>The member ID assigned by the group coordinator.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: Empty string</para>
		/// </summary>
		public TxnOffsetCommitRequest WithMemberId(String memberId)
		{
			MemberId = memberId;
			return this;
		}

		private String? _groupInstanceId;
		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? GroupInstanceId 
		{
			get => _groupInstanceId;
			set 
			{
				if (Version.InRange(3, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support version {Version} and has been defined as not ignorable. Supported versions: 3+");
				}

				if (Version.InRange(3, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"GroupInstanceId does not support null for version {Version}. Supported versions for null value: 3+");
				}

				_groupInstanceId = value;
			}
		}

		/// <summary>
		/// <para>The unique identifier of the consumer instance provided by end user.</para>
		/// <para>Versions: 3+</para>
		/// <para>Default: null</para>
		/// </summary>
		public TxnOffsetCommitRequest WithGroupInstanceId(String? groupInstanceId)
		{
			GroupInstanceId = groupInstanceId;
			return this;
		}

		private TxnOffsetCommitRequestTopic[] _topicsCollection = Array.Empty<TxnOffsetCommitRequestTopic>();
		/// <summary>
		/// <para>Each topic that we want to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequestTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Each topic that we want to commit offsets for.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitRequest WithTopicsCollection(params Func<TxnOffsetCommitRequestTopic, TxnOffsetCommitRequestTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTxnOffsetCommitRequestTopic()))
				.ToArray();
			return this;
		}

		internal TxnOffsetCommitRequestTopic CreateTxnOffsetCommitRequestTopic()
		{
			return new TxnOffsetCommitRequestTopic(Version);
		}

		public class TxnOffsetCommitRequestTopic : ISerialize
		{
			internal TxnOffsetCommitRequestTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<TxnOffsetCommitRequestPartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TxnOffsetCommitRequestTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TxnOffsetCommitRequestTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<TxnOffsetCommitRequestPartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitRequestPartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitRequestTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<TxnOffsetCommitRequestPartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitRequestTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private TxnOffsetCommitRequestPartition[] _partitionsCollection = Array.Empty<TxnOffsetCommitRequestPartition>();
			/// <summary>
			/// <para>The partitions inside the topic that we want to committ offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitRequestPartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The partitions inside the topic that we want to committ offsets for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitRequestTopic WithPartitionsCollection(params Func<TxnOffsetCommitRequestPartition, TxnOffsetCommitRequestPartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateTxnOffsetCommitRequestPartition()))
					.ToArray();
				return this;
			}

			internal TxnOffsetCommitRequestPartition CreateTxnOffsetCommitRequestPartition()
			{
				return new TxnOffsetCommitRequestPartition(Version);
			}

			public class TxnOffsetCommitRequestPartition : ISerialize
			{
				internal TxnOffsetCommitRequestPartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(3, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CommittedOffset.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(2, 2147483647) ? 
						CommittedLeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CommittedMetadata.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<TxnOffsetCommitRequestPartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TxnOffsetCommitRequestPartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CommittedOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(2, 2147483647)) 
					{
						instance.CommittedLeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CommittedMetadata = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitRequestPartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CommittedOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(2, 2147483647)) 
					{
						await CommittedLeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CommittedMetadata.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The index of the partition within the topic.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The index of the partition within the topic.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int64 _committedOffset = Int64.Default;
				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 CommittedOffset 
				{
					get => _committedOffset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CommittedOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_committedOffset = value;
					}
				}

				/// <summary>
				/// <para>The message offset to be committed.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithCommittedOffset(Int64 committedOffset)
				{
					CommittedOffset = committedOffset;
					return this;
				}

				private Int32 _committedLeaderEpoch = new Int32(-1);
				/// <summary>
				/// <para>The leader epoch of the last consumed record.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public Int32 CommittedLeaderEpoch 
				{
					get => _committedLeaderEpoch;
					set 
					{
						_committedLeaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The leader epoch of the last consumed record.</para>
				/// <para>Versions: 2+</para>
				/// <para>Default: -1</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithCommittedLeaderEpoch(Int32 committedLeaderEpoch)
				{
					CommittedLeaderEpoch = committedLeaderEpoch;
					return this;
				}

				private String? _committedMetadata;
				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String? CommittedMetadata 
				{
					get => _committedMetadata;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CommittedMetadata does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						if (Version.InRange(0, 2147483647) == false &&
							value == null) 
						{
							throw new UnsupportedVersionException($"CommittedMetadata does not support null for version {Version}. Supported versions for null value: 0+");
						}

						_committedMetadata = value;
					}
				}

				/// <summary>
				/// <para>Any associated metadata the client wants to keep.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitRequestPartition WithCommittedMetadata(String? committedMetadata)
				{
					CommittedMetadata = committedMetadata;
					return this;
				}
			}
		}

		public TxnOffsetCommitResponse Respond()
			=> new TxnOffsetCommitResponse(Version);
	}

	public class TxnOffsetCommitResponse : Message
	{
		public TxnOffsetCommitResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"TxnOffsetCommitResponse does not support version {version}. Valid versions are: 0-3");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(3, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(28);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(3);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<TxnOffsetCommitResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new TxnOffsetCommitResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TxnOffsetCommitResponseTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitResponseTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TxnOffsetCommitResponseTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private TxnOffsetCommitResponseTopic[] _topicsCollection = Array.Empty<TxnOffsetCommitResponseTopic>();
		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitResponseTopic[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>The responses for each topic.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TxnOffsetCommitResponse WithTopicsCollection(params Func<TxnOffsetCommitResponseTopic, TxnOffsetCommitResponseTopic>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTxnOffsetCommitResponseTopic()))
				.ToArray();
			return this;
		}

		internal TxnOffsetCommitResponseTopic CreateTxnOffsetCommitResponseTopic()
		{
			return new TxnOffsetCommitResponseTopic(Version);
		}

		public class TxnOffsetCommitResponseTopic : ISerialize
		{
			internal TxnOffsetCommitResponseTopic(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(3, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Name.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<TxnOffsetCommitResponsePartition>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TxnOffsetCommitResponseTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TxnOffsetCommitResponseTopic(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<TxnOffsetCommitResponsePartition>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TxnOffsetCommitResponsePartition.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitResponseTopic is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<TxnOffsetCommitResponsePartition>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _name = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Name 
			{
				get => _name;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_name = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitResponseTopic WithName(String name)
			{
				Name = name;
				return this;
			}

			private TxnOffsetCommitResponsePartition[] _partitionsCollection = Array.Empty<TxnOffsetCommitResponsePartition>();
			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitResponsePartition[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>The responses for each partition in the topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TxnOffsetCommitResponseTopic WithPartitionsCollection(params Func<TxnOffsetCommitResponsePartition, TxnOffsetCommitResponsePartition>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreateTxnOffsetCommitResponsePartition()))
					.ToArray();
				return this;
			}

			internal TxnOffsetCommitResponsePartition CreateTxnOffsetCommitResponsePartition()
			{
				return new TxnOffsetCommitResponsePartition(Version);
			}

			public class TxnOffsetCommitResponsePartition : ISerialize
			{
				internal TxnOffsetCommitResponsePartition(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(3, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<TxnOffsetCommitResponsePartition> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new TxnOffsetCommitResponsePartition(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for TxnOffsetCommitResponsePartition is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitResponsePartition WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>The error code, or 0 if there was no error.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public TxnOffsetCommitResponsePartition WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}
			}
		}
	}

	public class UnregisterBrokerRequest : Message, IRespond<UnregisterBrokerResponse>
	{
		public UnregisterBrokerRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"UnregisterBrokerRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(64);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<UnregisterBrokerRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UnregisterBrokerRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.BrokerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UnregisterBrokerRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await BrokerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _brokerId = Int32.Default;
		/// <summary>
		/// <para>The broker ID to unregister.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 BrokerId 
		{
			get => _brokerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"BrokerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_brokerId = value;
			}
		}

		/// <summary>
		/// <para>The broker ID to unregister.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerRequest WithBrokerId(Int32 brokerId)
		{
			BrokerId = brokerId;
			return this;
		}

		public UnregisterBrokerResponse Respond()
			=> new UnregisterBrokerResponse(Version);
	}

	public class UnregisterBrokerResponse : Message
	{
		public UnregisterBrokerResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"UnregisterBrokerResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(64);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<UnregisterBrokerResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UnregisterBrokerResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UnregisterBrokerResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>Duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UnregisterBrokerResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}
	}

	public class UpdateFeaturesRequest : Message, IRespond<UpdateFeaturesResponse>
	{
		public UpdateFeaturesRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"UpdateFeaturesRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(57);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<UpdateFeaturesRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateFeaturesRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TimeoutMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.FeatureUpdatesCollection = (await Array<FeatureUpdateKey>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => FeatureUpdateKey.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Feature);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateFeaturesRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await TimeoutMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<FeatureUpdateKey>.From(FeatureUpdatesCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _timeoutMs = new Int32(60000);
		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public Int32 TimeoutMs 
		{
			get => _timeoutMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TimeoutMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_timeoutMs = value;
			}
		}

		/// <summary>
		/// <para>How long to wait in milliseconds before timing out the request.</para>
		/// <para>Versions: 0+</para>
		/// <para>Default: 60000</para>
		/// </summary>
		public UpdateFeaturesRequest WithTimeoutMs(Int32 timeoutMs)
		{
			TimeoutMs = timeoutMs;
			return this;
		}

		private Dictionary<String, FeatureUpdateKey> _featureUpdatesCollection = new Dictionary<String, FeatureUpdateKey>();
		/// <summary>
		/// <para>The list of updates to finalized features.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, FeatureUpdateKey> FeatureUpdatesCollection 
		{
			get => _featureUpdatesCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"FeatureUpdatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_featureUpdatesCollection = value;
			}
		}

		/// <summary>
		/// <para>The list of updates to finalized features.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesRequest WithFeatureUpdatesCollection(params Func<FeatureUpdateKey, FeatureUpdateKey>[] createFields)
		{
			FeatureUpdatesCollection = createFields
				.Select(createField => createField(CreateFeatureUpdateKey()))
				.ToDictionary(field => field.Feature);
			return this;
		}

		internal FeatureUpdateKey CreateFeatureUpdateKey()
		{
			return new FeatureUpdateKey(Version);
		}

		public class FeatureUpdateKey : ISerialize
		{
			internal FeatureUpdateKey(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Feature.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					MaxVersionLevel.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					AllowDowngrade.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<FeatureUpdateKey> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new FeatureUpdateKey(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Feature = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.MaxVersionLevel = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.AllowDowngrade = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for FeatureUpdateKey is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Feature.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await MaxVersionLevel.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await AllowDowngrade.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _feature = String.Default;
			/// <summary>
			/// <para>The name of the finalized feature to be updated.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Feature 
			{
				get => _feature;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Feature does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_feature = value;
				}
			}

			/// <summary>
			/// <para>The name of the finalized feature to be updated.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FeatureUpdateKey WithFeature(String feature)
			{
				Feature = feature;
				return this;
			}

			private Int16 _maxVersionLevel = Int16.Default;
			/// <summary>
			/// <para>The new maximum version level for the finalized feature. A value >= 1 is valid. A value < 1, is special, and can be used to request the deletion of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 MaxVersionLevel 
			{
				get => _maxVersionLevel;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"MaxVersionLevel does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_maxVersionLevel = value;
				}
			}

			/// <summary>
			/// <para>The new maximum version level for the finalized feature. A value >= 1 is valid. A value < 1, is special, and can be used to request the deletion of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FeatureUpdateKey WithMaxVersionLevel(Int16 maxVersionLevel)
			{
				MaxVersionLevel = maxVersionLevel;
				return this;
			}

			private Boolean _allowDowngrade = Boolean.Default;
			/// <summary>
			/// <para>When set to true, the finalized feature version level is allowed to be downgraded/deleted. The downgrade request will fail if the new maximum version level is a value that's not lower than the existing maximum finalized version level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Boolean AllowDowngrade 
			{
				get => _allowDowngrade;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"AllowDowngrade does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_allowDowngrade = value;
				}
			}

			/// <summary>
			/// <para>When set to true, the finalized feature version level is allowed to be downgraded/deleted. The downgrade request will fail if the new maximum version level is a value that's not lower than the existing maximum finalized version level.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public FeatureUpdateKey WithAllowDowngrade(Boolean allowDowngrade)
			{
				AllowDowngrade = allowDowngrade;
				return this;
			}
		}

		public UpdateFeaturesResponse Respond()
			=> new UpdateFeaturesResponse(Version);
	}

	public class UpdateFeaturesResponse : Message
	{
		public UpdateFeaturesResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"UpdateFeaturesResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(57);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<UpdateFeaturesResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateFeaturesResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ThrottleTimeMs = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ResultsCollection = (await Array<UpdatableFeatureResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdatableFeatureResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false)).Value.ToDictionary(field => field.Feature);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateFeaturesResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ThrottleTimeMs.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<UpdatableFeatureResult>.From(ResultsCollection.Values.ToArray()).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _throttleTimeMs = Int32.Default;
		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ThrottleTimeMs 
		{
			get => _throttleTimeMs;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ThrottleTimeMs does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_throttleTimeMs = value;
			}
		}

		/// <summary>
		/// <para>The duration in milliseconds for which the request was throttled due to a quota violation, or zero if the request did not violate any quota.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithThrottleTimeMs(Int32 throttleTimeMs)
		{
			ThrottleTimeMs = throttleTimeMs;
			return this;
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top-level error code, or `0` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top-level error code, or `0` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private String? _errorMessage;
		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public String? ErrorMessage 
		{
			get => _errorMessage;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_errorMessage = value;
			}
		}

		/// <summary>
		/// <para>The top-level error message, or `null` if there was no top-level error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithErrorMessage(String? errorMessage)
		{
			ErrorMessage = errorMessage;
			return this;
		}

		private Dictionary<String, UpdatableFeatureResult> _resultsCollection = new Dictionary<String, UpdatableFeatureResult>();
		/// <summary>
		/// <para>Results for each feature update.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Dictionary<String, UpdatableFeatureResult> ResultsCollection 
		{
			get => _resultsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ResultsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_resultsCollection = value;
			}
		}

		/// <summary>
		/// <para>Results for each feature update.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateFeaturesResponse WithResultsCollection(params Func<UpdatableFeatureResult, UpdatableFeatureResult>[] createFields)
		{
			ResultsCollection = createFields
				.Select(createField => createField(CreateUpdatableFeatureResult()))
				.ToDictionary(field => field.Feature);
			return this;
		}

		internal UpdatableFeatureResult CreateUpdatableFeatureResult()
		{
			return new UpdatableFeatureResult(Version);
		}

		public class UpdatableFeatureResult : ISerialize
		{
			internal UpdatableFeatureResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Feature.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorCode.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ErrorMessage.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<UpdatableFeatureResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdatableFeatureResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Feature = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ErrorMessage = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdatableFeatureResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Feature.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ErrorMessage.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _feature = String.Default;
			/// <summary>
			/// <para>The name of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String Feature 
			{
				get => _feature;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Feature does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_feature = value;
				}
			}

			/// <summary>
			/// <para>The name of the finalized feature.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdatableFeatureResult WithFeature(String feature)
			{
				Feature = feature;
				return this;
			}

			private Int16 _errorCode = Int16.Default;
			/// <summary>
			/// <para>The feature update error code or `0` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ErrorCode 
			{
				get => _errorCode;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_errorCode = value;
				}
			}

			/// <summary>
			/// <para>The feature update error code or `0` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdatableFeatureResult WithErrorCode(Int16 errorCode)
			{
				ErrorCode = errorCode;
				return this;
			}

			private String? _errorMessage;
			/// <summary>
			/// <para>The feature update error, or `null` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String? ErrorMessage 
			{
				get => _errorMessage;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"ErrorMessage does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_errorMessage = value;
				}
			}

			/// <summary>
			/// <para>The feature update error, or `null` if the feature update succeeded.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdatableFeatureResult WithErrorMessage(String? errorMessage)
			{
				ErrorMessage = errorMessage;
				return this;
			}
		}
	}

	public class UpdateMetadataRequest : Message, IRespond<UpdateMetadataResponse>
	{
		public UpdateMetadataRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"UpdateMetadataRequest does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(6);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<UpdateMetadataRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateMetadataRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.BrokerEpoch = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 4)) 
			{
				instance.UngroupedPartitionStatesCollection = await Array<UpdateMetadataPartitionState>.FromReaderAsync(() => UpdateMetadataPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(5, 2147483647)) 
			{
				instance.TopicStatesCollection = await Array<UpdateMetadataTopicState>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataTopicState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.LiveBrokersCollection = await Array<UpdateMetadataBroker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataBroker.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await ControllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await BrokerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 4)) 
			{
				await Array<UpdateMetadataPartitionState>.From(UngroupedPartitionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(5, 2147483647)) 
			{
				await Array<UpdateMetadataTopicState>.From(TopicStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<UpdateMetadataBroker>.From(LiveBrokersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int32 _controllerId = Int32.Default;
		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerId 
		{
			get => _controllerId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerId = value;
			}
		}

		/// <summary>
		/// <para>The controller id.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithControllerId(Int32 controllerId)
		{
			ControllerId = controllerId;
			return this;
		}

		private Int32 _controllerEpoch = Int32.Default;
		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int32 ControllerEpoch 
		{
			get => _controllerEpoch;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ControllerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_controllerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The controller epoch.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithControllerEpoch(Int32 controllerEpoch)
		{
			ControllerEpoch = controllerEpoch;
			return this;
		}

		private Int64 _brokerEpoch = new Int64(-1);
		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public Int64 BrokerEpoch 
		{
			get => _brokerEpoch;
			set 
			{
				_brokerEpoch = value;
			}
		}

		/// <summary>
		/// <para>The broker epoch.</para>
		/// <para>Versions: 5+</para>
		/// <para>Default: -1</para>
		/// </summary>
		public UpdateMetadataRequest WithBrokerEpoch(Int64 brokerEpoch)
		{
			BrokerEpoch = brokerEpoch;
			return this;
		}

		private UpdateMetadataPartitionState[] _ungroupedPartitionStatesCollection = Array.Empty<UpdateMetadataPartitionState>();
		/// <summary>
		/// <para>In older versions of this RPC, each partition that we would like to update.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public UpdateMetadataPartitionState[] UngroupedPartitionStatesCollection 
		{
			get => _ungroupedPartitionStatesCollection;
			set 
			{
				if (Version.InRange(0, 4) == false) 
				{
					throw new UnsupportedVersionException($"UngroupedPartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0-4");
				}

				_ungroupedPartitionStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>In older versions of this RPC, each partition that we would like to update.</para>
		/// <para>Versions: 0-4</para>
		/// </summary>
		public UpdateMetadataRequest WithUngroupedPartitionStatesCollection(UpdateMetadataPartitionState[] ungroupedPartitionStatesCollection)
		{
			UngroupedPartitionStatesCollection = ungroupedPartitionStatesCollection;
			return this;
		}

		private UpdateMetadataTopicState[] _topicStatesCollection = Array.Empty<UpdateMetadataTopicState>();
		/// <summary>
		/// <para>In newer versions of this RPC, each topic that we would like to update.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public UpdateMetadataTopicState[] TopicStatesCollection 
		{
			get => _topicStatesCollection;
			set 
			{
				if (Version.InRange(5, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
				}

				_topicStatesCollection = value;
			}
		}

		/// <summary>
		/// <para>In newer versions of this RPC, each topic that we would like to update.</para>
		/// <para>Versions: 5+</para>
		/// </summary>
		public UpdateMetadataRequest WithTopicStatesCollection(params Func<UpdateMetadataTopicState, UpdateMetadataTopicState>[] createFields)
		{
			TopicStatesCollection = createFields
				.Select(createField => createField(CreateUpdateMetadataTopicState()))
				.ToArray();
			return this;
		}

		internal UpdateMetadataTopicState CreateUpdateMetadataTopicState()
		{
			return new UpdateMetadataTopicState(Version);
		}

		public class UpdateMetadataTopicState : ISerialize
		{
			internal UpdateMetadataTopicState(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(5, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(7, 2147483647) ? 
					TopicId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(5, 2147483647) ? 
					Array<UpdateMetadataPartitionState>.From(PartitionStatesCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<UpdateMetadataTopicState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdateMetadataTopicState(version);
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(7, 2147483647)) 
				{
					instance.TopicId = await Uuid.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(5, 2147483647)) 
				{
					instance.PartitionStatesCollection = await Array<UpdateMetadataPartitionState>.FromReaderAsync(() => UpdateMetadataPartitionState.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataTopicState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(5, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(7, 2147483647)) 
				{
					await TopicId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(5, 2147483647)) 
				{
					await Array<UpdateMetadataPartitionState>.From(PartitionStatesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(5, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public UpdateMetadataTopicState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Uuid _topicId = Uuid.Default;
			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public Uuid TopicId 
			{
				get => _topicId;
				set 
				{
					_topicId = value;
				}
			}

			/// <summary>
			/// <para>The topic id.</para>
			/// <para>Versions: 7+</para>
			/// </summary>
			public UpdateMetadataTopicState WithTopicId(Uuid topicId)
			{
				TopicId = topicId;
				return this;
			}

			private UpdateMetadataPartitionState[] _partitionStatesCollection = Array.Empty<UpdateMetadataPartitionState>();
			/// <summary>
			/// <para>The partition that we would like to update.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public UpdateMetadataPartitionState[] PartitionStatesCollection 
			{
				get => _partitionStatesCollection;
				set 
				{
					if (Version.InRange(5, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionStatesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 5+");
					}

					_partitionStatesCollection = value;
				}
			}

			/// <summary>
			/// <para>The partition that we would like to update.</para>
			/// <para>Versions: 5+</para>
			/// </summary>
			public UpdateMetadataTopicState WithPartitionStatesCollection(UpdateMetadataPartitionState[] partitionStatesCollection)
			{
				PartitionStatesCollection = partitionStatesCollection;
				return this;
			}
		}

		private UpdateMetadataBroker[] _liveBrokersCollection = Array.Empty<UpdateMetadataBroker>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataBroker[] LiveBrokersCollection 
		{
			get => _liveBrokersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"LiveBrokersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_liveBrokersCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataRequest WithLiveBrokersCollection(params Func<UpdateMetadataBroker, UpdateMetadataBroker>[] createFields)
		{
			LiveBrokersCollection = createFields
				.Select(createField => createField(CreateUpdateMetadataBroker()))
				.ToArray();
			return this;
		}

		internal UpdateMetadataBroker CreateUpdateMetadataBroker()
		{
			return new UpdateMetadataBroker(Version);
		}

		public class UpdateMetadataBroker : ISerialize
		{
			internal UpdateMetadataBroker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					Id.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 0) ? 
					V0Host.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 0) ? 
					V0Port.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(1, 2147483647) ? 
					Array<UpdateMetadataEndpoint>.From(EndpointsCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(2, 2147483647) ? 
					Rack.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<UpdateMetadataBroker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdateMetadataBroker(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Id = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 0)) 
				{
					instance.V0Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 0)) 
				{
					instance.V0Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(1, 2147483647)) 
				{
					instance.EndpointsCollection = await Array<UpdateMetadataEndpoint>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => UpdateMetadataEndpoint.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(2, 2147483647)) 
				{
					instance.Rack = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataBroker is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await Id.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 0)) 
				{
					await V0Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 0)) 
				{
					await V0Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(1, 2147483647)) 
				{
					await Array<UpdateMetadataEndpoint>.From(EndpointsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(2, 2147483647)) 
				{
					await Rack.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int32 _id = Int32.Default;
			/// <summary>
			/// <para>The broker id.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Id 
			{
				get => _id;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Id does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_id = value;
				}
			}

			/// <summary>
			/// <para>The broker id.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataBroker WithId(Int32 id)
			{
				Id = id;
				return this;
			}

			private String _v0Host = String.Default;
			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public String V0Host 
			{
				get => _v0Host;
				set 
				{
					_v0Host = value;
				}
			}

			/// <summary>
			/// <para>The broker hostname.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public UpdateMetadataBroker WithV0Host(String v0Host)
			{
				V0Host = v0Host;
				return this;
			}

			private Int32 _v0Port = Int32.Default;
			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public Int32 V0Port 
			{
				get => _v0Port;
				set 
				{
					_v0Port = value;
				}
			}

			/// <summary>
			/// <para>The broker port.</para>
			/// <para>Versions: 0</para>
			/// </summary>
			public UpdateMetadataBroker WithV0Port(Int32 v0Port)
			{
				V0Port = v0Port;
				return this;
			}

			private UpdateMetadataEndpoint[] _endpointsCollection = Array.Empty<UpdateMetadataEndpoint>();
			/// <summary>
			/// <para>The broker endpoints.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public UpdateMetadataEndpoint[] EndpointsCollection 
			{
				get => _endpointsCollection;
				set 
				{
					_endpointsCollection = value;
				}
			}

			/// <summary>
			/// <para>The broker endpoints.</para>
			/// <para>Versions: 1+</para>
			/// </summary>
			public UpdateMetadataBroker WithEndpointsCollection(params Func<UpdateMetadataEndpoint, UpdateMetadataEndpoint>[] createFields)
			{
				EndpointsCollection = createFields
					.Select(createField => createField(CreateUpdateMetadataEndpoint()))
					.ToArray();
				return this;
			}

			internal UpdateMetadataEndpoint CreateUpdateMetadataEndpoint()
			{
				return new UpdateMetadataEndpoint(Version);
			}

			public class UpdateMetadataEndpoint : ISerialize
			{
				internal UpdateMetadataEndpoint(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(6, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(1, 2147483647) ? 
						Port.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						Host.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(3, 2147483647) ? 
						Listener.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(1, 2147483647) ? 
						SecurityProtocol.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<UpdateMetadataEndpoint> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new UpdateMetadataEndpoint(version);
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.Port = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.Host = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(3, 2147483647)) 
					{
						instance.Listener = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(1, 2147483647)) 
					{
						instance.SecurityProtocol = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataEndpoint is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(1, 2147483647)) 
					{
						await Port.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await Host.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(3, 2147483647)) 
					{
						await Listener.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(1, 2147483647)) 
					{
						await SecurityProtocol.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _port = Int32.Default;
				/// <summary>
				/// <para>The port of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public Int32 Port 
				{
					get => _port;
					set 
					{
						if (Version.InRange(1, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Port does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
						}

						_port = value;
					}
				}

				/// <summary>
				/// <para>The port of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithPort(Int32 port)
				{
					Port = port;
					return this;
				}

				private String _host = String.Default;
				/// <summary>
				/// <para>The hostname of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public String Host 
				{
					get => _host;
					set 
					{
						if (Version.InRange(1, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Host does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
						}

						_host = value;
					}
				}

				/// <summary>
				/// <para>The hostname of this endpoint</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithHost(String host)
				{
					Host = host;
					return this;
				}

				private String _listener = String.Default;
				/// <summary>
				/// <para>The listener name.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public String Listener 
				{
					get => _listener;
					set 
					{
						_listener = value;
					}
				}

				/// <summary>
				/// <para>The listener name.</para>
				/// <para>Versions: 3+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithListener(String listener)
				{
					Listener = listener;
					return this;
				}

				private Int16 _securityProtocol = Int16.Default;
				/// <summary>
				/// <para>The security protocol type.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public Int16 SecurityProtocol 
				{
					get => _securityProtocol;
					set 
					{
						if (Version.InRange(1, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"SecurityProtocol does not support version {Version} and has been defined as not ignorable. Supported versions: 1+");
						}

						_securityProtocol = value;
					}
				}

				/// <summary>
				/// <para>The security protocol type.</para>
				/// <para>Versions: 1+</para>
				/// </summary>
				public UpdateMetadataEndpoint WithSecurityProtocol(Int16 securityProtocol)
				{
					SecurityProtocol = securityProtocol;
					return this;
				}
			}

			private String? _rack;
			/// <summary>
			/// <para>The rack which this broker belongs to.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public String? Rack 
			{
				get => _rack;
				set 
				{
					if (Version.InRange(0, 2147483647) == false &&
						value == null) 
					{
						throw new UnsupportedVersionException($"Rack does not support null for version {Version}. Supported versions for null value: 0+");
					}

					_rack = value;
				}
			}

			/// <summary>
			/// <para>The rack which this broker belongs to.</para>
			/// <para>Versions: 2+</para>
			/// </summary>
			public UpdateMetadataBroker WithRack(String? rack)
			{
				Rack = rack;
				return this;
			}
		}

		public class UpdateMetadataPartitionState : ISerialize
		{
			internal UpdateMetadataPartitionState(Int16 version)
			{
				if (version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"UpdateMetadataPartitionState does not support version {version}. Valid versions are: 0+");
				}

				Version = version;
				IsFlexibleVersion = version.InRange(6, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 4) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					PartitionIndex.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ControllerEpoch.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Leader.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					LeaderEpoch.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(IsrCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ZkVersion.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<Int32>.From(ReplicasCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(4, 2147483647) ? 
					Array<Int32>.From(OfflineReplicasCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<UpdateMetadataPartitionState> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new UpdateMetadataPartitionState(version);
				if (instance.Version.InRange(0, 4)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ControllerEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.Leader = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.IsrCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ZkVersion = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(4, 2147483647)) 
				{
					instance.OfflineReplicasCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataPartitionState is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 4)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ControllerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Leader.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(IsrCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ZkVersion.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<Int32>.From(ReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(4, 2147483647)) 
				{
					await Array<Int32>.From(OfflineReplicasCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>In older versions of this RPC, the topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					_topicName = value;
				}
			}

			/// <summary>
			/// <para>In older versions of this RPC, the topic name.</para>
			/// <para>Versions: 0-4</para>
			/// </summary>
			public UpdateMetadataPartitionState WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private Int32 _partitionIndex = Int32.Default;
			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 PartitionIndex 
			{
				get => _partitionIndex;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionIndex = value;
				}
			}

			/// <summary>
			/// <para>The partition index.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithPartitionIndex(Int32 partitionIndex)
			{
				PartitionIndex = partitionIndex;
				return this;
			}

			private Int32 _controllerEpoch = Int32.Default;
			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ControllerEpoch 
			{
				get => _controllerEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ControllerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_controllerEpoch = value;
				}
			}

			/// <summary>
			/// <para>The controller epoch.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithControllerEpoch(Int32 controllerEpoch)
			{
				ControllerEpoch = controllerEpoch;
				return this;
			}

			private Int32 _leader = Int32.Default;
			/// <summary>
			/// <para>The ID of the broker which is the current partition leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 Leader 
			{
				get => _leader;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"Leader does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_leader = value;
				}
			}

			/// <summary>
			/// <para>The ID of the broker which is the current partition leader.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithLeader(Int32 leader)
			{
				Leader = leader;
				return this;
			}

			private Int32 _leaderEpoch = Int32.Default;
			/// <summary>
			/// <para>The leader epoch of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 LeaderEpoch 
			{
				get => _leaderEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_leaderEpoch = value;
				}
			}

			/// <summary>
			/// <para>The leader epoch of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithLeaderEpoch(Int32 leaderEpoch)
			{
				LeaderEpoch = leaderEpoch;
				return this;
			}

			private Int32[] _isrCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The brokers which are in the ISR for this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] IsrCollection 
			{
				get => _isrCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"IsrCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_isrCollection = value;
				}
			}

			/// <summary>
			/// <para>The brokers which are in the ISR for this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithIsrCollection(Int32[] isrCollection)
			{
				IsrCollection = isrCollection;
				return this;
			}

			private Int32 _zkVersion = Int32.Default;
			/// <summary>
			/// <para>The Zookeeper version.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 ZkVersion 
			{
				get => _zkVersion;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ZkVersion does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_zkVersion = value;
				}
			}

			/// <summary>
			/// <para>The Zookeeper version.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithZkVersion(Int32 zkVersion)
			{
				ZkVersion = zkVersion;
				return this;
			}

			private Int32[] _replicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>All the replicas of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32[] ReplicasCollection 
			{
				get => _replicasCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ReplicasCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_replicasCollection = value;
				}
			}

			/// <summary>
			/// <para>All the replicas of this partition.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithReplicasCollection(Int32[] replicasCollection)
			{
				ReplicasCollection = replicasCollection;
				return this;
			}

			private Int32[] _offlineReplicasCollection = Array.Empty<Int32>();
			/// <summary>
			/// <para>The replicas of this partition which are offline.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public Int32[] OfflineReplicasCollection 
			{
				get => _offlineReplicasCollection;
				set 
				{
					_offlineReplicasCollection = value;
				}
			}

			/// <summary>
			/// <para>The replicas of this partition which are offline.</para>
			/// <para>Versions: 4+</para>
			/// </summary>
			public UpdateMetadataPartitionState WithOfflineReplicasCollection(Int32[] offlineReplicasCollection)
			{
				OfflineReplicasCollection = offlineReplicasCollection;
				return this;
			}
		}

		public UpdateMetadataResponse Respond()
			=> new UpdateMetadataResponse(Version);
	}

	public class UpdateMetadataResponse : Message
	{
		public UpdateMetadataResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"UpdateMetadataResponse does not support version {version}. Valid versions are: 0-7");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(6, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(6);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(7);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<UpdateMetadataResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new UpdateMetadataResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for UpdateMetadataResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The error code, or 0 if there was no error.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public UpdateMetadataResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}
	}

	public class VoteRequest : Message, IRespond<VoteResponse>
	{
		public VoteRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"VoteRequest does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(52);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<VoteRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new VoteRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ClusterId = await NullableString.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for VoteRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ClusterId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private String? _clusterId;
		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public String? ClusterId 
		{
			get => _clusterId;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				if (Version.InRange(0, 2147483647) == false &&
					value == null) 
				{
					throw new UnsupportedVersionException($"ClusterId does not support null for version {Version}. Supported versions for null value: 0+");
				}

				_clusterId = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// <para>Default: null</para>
		/// </summary>
		public VoteRequest WithClusterId(String? clusterId)
		{
			ClusterId = clusterId;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteRequest WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CandidateEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						CandidateId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LastOffsetEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LastOffset.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CandidateEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.CandidateId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LastOffsetEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LastOffset = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CandidateEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await CandidateId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LastOffsetEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LastOffset.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int32 _candidateEpoch = Int32.Default;
				/// <summary>
				/// <para>The bumped epoch of the candidate sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CandidateEpoch 
				{
					get => _candidateEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CandidateEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_candidateEpoch = value;
					}
				}

				/// <summary>
				/// <para>The bumped epoch of the candidate sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCandidateEpoch(Int32 candidateEpoch)
				{
					CandidateEpoch = candidateEpoch;
					return this;
				}

				private Int32 _candidateId = Int32.Default;
				/// <summary>
				/// <para>The ID of the voter sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 CandidateId 
				{
					get => _candidateId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"CandidateId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_candidateId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the voter sending the request</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithCandidateId(Int32 candidateId)
				{
					CandidateId = candidateId;
					return this;
				}

				private Int32 _lastOffsetEpoch = Int32.Default;
				/// <summary>
				/// <para>The epoch of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LastOffsetEpoch 
				{
					get => _lastOffsetEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LastOffsetEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_lastOffsetEpoch = value;
					}
				}

				/// <summary>
				/// <para>The epoch of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLastOffsetEpoch(Int32 lastOffsetEpoch)
				{
					LastOffsetEpoch = lastOffsetEpoch;
					return this;
				}

				private Int64 _lastOffset = Int64.Default;
				/// <summary>
				/// <para>The offset of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int64 LastOffset 
				{
					get => _lastOffset;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LastOffset does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_lastOffset = value;
					}
				}

				/// <summary>
				/// <para>The offset of the last record written to the metadata log</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLastOffset(Int64 lastOffset)
				{
					LastOffset = lastOffset;
					return this;
				}
			}
		}

		public VoteResponse Respond()
			=> new VoteResponse(Version);
	}

	public class VoteResponse : Message
	{
		public VoteResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"VoteResponse does not support version {version}. Valid versions are: 0");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(0, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(52);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(0);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<VoteResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new VoteResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.TopicsCollection = await Array<TopicData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => TopicData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for VoteResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<TopicData>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private Int16 _errorCode = Int16.Default;
		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public Int16 ErrorCode 
		{
			get => _errorCode;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_errorCode = value;
			}
		}

		/// <summary>
		/// <para>The top level error code.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteResponse WithErrorCode(Int16 errorCode)
		{
			ErrorCode = errorCode;
			return this;
		}

		private TopicData[] _topicsCollection = Array.Empty<TopicData>();
		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public TopicData[] TopicsCollection 
		{
			get => _topicsCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_topicsCollection = value;
			}
		}

		/// <summary>
		/// <para>Versions: 0+</para>
		/// </summary>
		public VoteResponse WithTopicsCollection(params Func<TopicData, TopicData>[] createFields)
		{
			TopicsCollection = createFields
				.Select(createField => createField(CreateTopicData()))
				.ToArray();
			return this;
		}

		internal TopicData CreateTopicData()
		{
			return new TopicData(Version);
		}

		public class TopicData : ISerialize
		{
			internal TopicData(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(0, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					TopicName.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<PartitionData>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<TopicData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new TopicData(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicName = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.PartitionsCollection = await Array<PartitionData>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => PartitionData.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for TopicData is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await TopicName.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<PartitionData>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private String _topicName = String.Default;
			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public String TopicName 
			{
				get => _topicName;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicName does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicName = value;
				}
			}

			/// <summary>
			/// <para>The topic name.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithTopicName(String topicName)
			{
				TopicName = topicName;
				return this;
			}

			private PartitionData[] _partitionsCollection = Array.Empty<PartitionData>();
			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public PartitionData[] PartitionsCollection 
			{
				get => _partitionsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_partitionsCollection = value;
				}
			}

			/// <summary>
			/// <para>Versions: 0+</para>
			/// </summary>
			public TopicData WithPartitionsCollection(params Func<PartitionData, PartitionData>[] createFields)
			{
				PartitionsCollection = createFields
					.Select(createField => createField(CreatePartitionData()))
					.ToArray();
				return this;
			}

			internal PartitionData CreatePartitionData()
			{
				return new PartitionData(Version);
			}

			public class PartitionData : ISerialize
			{
				internal PartitionData(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(0, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						PartitionIndex.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						ErrorCode.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderId.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						LeaderEpoch.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						VoteGranted.GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<PartitionData> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new PartitionData(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderId = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.LeaderEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.VoteGranted = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for PartitionData is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await LeaderEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await VoteGranted.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private Int32 _partitionIndex = Int32.Default;
				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 PartitionIndex 
				{
					get => _partitionIndex;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndex = value;
					}
				}

				/// <summary>
				/// <para>The partition index.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithPartitionIndex(Int32 partitionIndex)
				{
					PartitionIndex = partitionIndex;
					return this;
				}

				private Int16 _errorCode = Int16.Default;
				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int16 ErrorCode 
				{
					get => _errorCode;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_errorCode = value;
					}
				}

				/// <summary>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithErrorCode(Int16 errorCode)
				{
					ErrorCode = errorCode;
					return this;
				}

				private Int32 _leaderId = Int32.Default;
				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderId 
				{
					get => _leaderId;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderId = value;
					}
				}

				/// <summary>
				/// <para>The ID of the current leader or -1 if the leader is unknown.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderId(Int32 leaderId)
				{
					LeaderId = leaderId;
					return this;
				}

				private Int32 _leaderEpoch = Int32.Default;
				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32 LeaderEpoch 
				{
					get => _leaderEpoch;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"LeaderEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_leaderEpoch = value;
					}
				}

				/// <summary>
				/// <para>The latest known leader epoch</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithLeaderEpoch(Int32 leaderEpoch)
				{
					LeaderEpoch = leaderEpoch;
					return this;
				}

				private Boolean _voteGranted = Boolean.Default;
				/// <summary>
				/// <para>True if the vote was granted and false otherwise</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Boolean VoteGranted 
				{
					get => _voteGranted;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"VoteGranted does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_voteGranted = value;
					}
				}

				/// <summary>
				/// <para>True if the vote was granted and false otherwise</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public PartitionData WithVoteGranted(Boolean voteGranted)
				{
					VoteGranted = voteGranted;
					return this;
				}
			}
		}
	}

	public class WriteTxnMarkersRequest : Message, IRespond<WriteTxnMarkersResponse>
	{
		public WriteTxnMarkersRequest(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"WriteTxnMarkersRequest does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(27);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<WriteTxnMarkersRequest> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new WriteTxnMarkersRequest(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MarkersCollection = await Array<WritableTxnMarker>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarker.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteTxnMarkersRequest is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<WritableTxnMarker>.From(MarkersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private WritableTxnMarker[] _markersCollection = Array.Empty<WritableTxnMarker>();
		/// <summary>
		/// <para>The transaction markers to be written.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WritableTxnMarker[] MarkersCollection 
		{
			get => _markersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MarkersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_markersCollection = value;
			}
		}

		/// <summary>
		/// <para>The transaction markers to be written.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteTxnMarkersRequest WithMarkersCollection(params Func<WritableTxnMarker, WritableTxnMarker>[] createFields)
		{
			MarkersCollection = createFields
				.Select(createField => createField(CreateWritableTxnMarker()))
				.ToArray();
			return this;
		}

		internal WritableTxnMarker CreateWritableTxnMarker()
		{
			return new WritableTxnMarker(Version);
		}

		public class WritableTxnMarker : ISerialize
		{
			internal WritableTxnMarker(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ProducerId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					ProducerEpoch.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					TransactionResult.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<WritableTxnMarkerTopic>.From(TopicsCollection).GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					CoordinatorEpoch.GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<WritableTxnMarker> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new WritableTxnMarker(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProducerEpoch = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TransactionResult = await Boolean.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicsCollection = await Array<WritableTxnMarkerTopic>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerTopic.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.CoordinatorEpoch = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarker is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await ProducerEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await TransactionResult.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<WritableTxnMarkerTopic>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await CoordinatorEpoch.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>The current producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_producerId = value;
				}
			}

			/// <summary>
			/// <para>The current producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private Int16 _producerEpoch = Int16.Default;
			/// <summary>
			/// <para>The current epoch associated with the producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int16 ProducerEpoch 
			{
				get => _producerEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProducerEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_producerEpoch = value;
				}
			}

			/// <summary>
			/// <para>The current epoch associated with the producer ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithProducerEpoch(Int16 producerEpoch)
			{
				ProducerEpoch = producerEpoch;
				return this;
			}

			private Boolean _transactionResult = Boolean.Default;
			/// <summary>
			/// <para>The result of the transaction to write to the partitions (false = ABORT, true = COMMIT).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Boolean TransactionResult 
			{
				get => _transactionResult;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TransactionResult does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_transactionResult = value;
				}
			}

			/// <summary>
			/// <para>The result of the transaction to write to the partitions (false = ABORT, true = COMMIT).</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithTransactionResult(Boolean transactionResult)
			{
				TransactionResult = transactionResult;
				return this;
			}

			private WritableTxnMarkerTopic[] _topicsCollection = Array.Empty<WritableTxnMarkerTopic>();
			/// <summary>
			/// <para>Each topic that we want to write transaction marker(s) for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerTopic[] TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>Each topic that we want to write transaction marker(s) for.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithTopicsCollection(params Func<WritableTxnMarkerTopic, WritableTxnMarkerTopic>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateWritableTxnMarkerTopic()))
					.ToArray();
				return this;
			}

			internal WritableTxnMarkerTopic CreateWritableTxnMarkerTopic()
			{
				return new WritableTxnMarkerTopic(Version);
			}

			public class WritableTxnMarkerTopic : ISerialize
			{
				internal WritableTxnMarkerTopic(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<Int32>.From(PartitionIndexesCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<WritableTxnMarkerTopic> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new WritableTxnMarkerTopic(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionIndexesCollection = await Array<Int32>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerTopic is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<Int32>.From(PartitionIndexesCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopic WithName(String name)
				{
					Name = name;
					return this;
				}

				private Int32[] _partitionIndexesCollection = Array.Empty<Int32>();
				/// <summary>
				/// <para>The indexes of the partitions to write transaction markers for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public Int32[] PartitionIndexesCollection 
				{
					get => _partitionIndexesCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionIndexesCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionIndexesCollection = value;
					}
				}

				/// <summary>
				/// <para>The indexes of the partitions to write transaction markers for.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopic WithPartitionIndexesCollection(Int32[] partitionIndexesCollection)
				{
					PartitionIndexesCollection = partitionIndexesCollection;
					return this;
				}
			}

			private Int32 _coordinatorEpoch = Int32.Default;
			/// <summary>
			/// <para>Epoch associated with the transaction state partition hosted by this transaction coordinator</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int32 CoordinatorEpoch 
			{
				get => _coordinatorEpoch;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"CoordinatorEpoch does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_coordinatorEpoch = value;
				}
			}

			/// <summary>
			/// <para>Epoch associated with the transaction state partition hosted by this transaction coordinator</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarker WithCoordinatorEpoch(Int32 coordinatorEpoch)
			{
				CoordinatorEpoch = coordinatorEpoch;
				return this;
			}
		}

		public WriteTxnMarkersResponse Respond()
			=> new WriteTxnMarkersResponse(Version);
	}

	public class WriteTxnMarkersResponse : Message
	{
		public WriteTxnMarkersResponse(Int16 version)
		{
			if (version.InRange(MinVersion, MaxVersion) == false) 
			{
				throw new UnsupportedVersionException($"WriteTxnMarkersResponse does not support version {version}. Valid versions are: 0-1");
			}

			Version = version;
			IsFlexibleVersion = version.InRange(1, 2147483647);
		}

		public static readonly Int16 ApiKey = Int16.From(27);

		public static readonly Int16 MinVersion = Int16.From(0);
		public static readonly Int16 MaxVersion = Int16.From(1);

		public override Int16 Version { get; }
		internal bool IsFlexibleVersion { get; }

		public static async ValueTask<WriteTxnMarkersResponse> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
		{
			var instance = new WriteTxnMarkersResponse(version);
			if (instance.Version.InRange(0, 2147483647)) 
			{
				instance.MarkersCollection = await Array<WritableTxnMarkerResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
			}

			if (instance.IsFlexibleVersion)
			{
				var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
				await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
				{
					switch (tag.Tag)
					{
						default:
							throw new InvalidOperationException($"Tag '{tag.Tag}' for WriteTxnMarkersResponse is unknown");
					}
				}
			}

			return instance;
		}

		public override async ValueTask WriteToAsync(Stream writer, CancellationToken cancellationToken = default)
		{
			if (Version.InRange(0, 2147483647)) 
			{
				await Array<WritableTxnMarkerResult>.From(MarkersCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
			}
		}

		private WritableTxnMarkerResult[] _markersCollection = Array.Empty<WritableTxnMarkerResult>();
		/// <summary>
		/// <para>The results for writing makers.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WritableTxnMarkerResult[] MarkersCollection 
		{
			get => _markersCollection;
			set 
			{
				if (Version.InRange(0, 2147483647) == false) 
				{
					throw new UnsupportedVersionException($"MarkersCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
				}

				_markersCollection = value;
			}
		}

		/// <summary>
		/// <para>The results for writing makers.</para>
		/// <para>Versions: 0+</para>
		/// </summary>
		public WriteTxnMarkersResponse WithMarkersCollection(params Func<WritableTxnMarkerResult, WritableTxnMarkerResult>[] createFields)
		{
			MarkersCollection = createFields
				.Select(createField => createField(CreateWritableTxnMarkerResult()))
				.ToArray();
			return this;
		}

		internal WritableTxnMarkerResult CreateWritableTxnMarkerResult()
		{
			return new WritableTxnMarkerResult(Version);
		}

		public class WritableTxnMarkerResult : ISerialize
		{
			internal WritableTxnMarkerResult(Int16 version)
			{
				Version = version;
				IsFlexibleVersion = version.InRange(1, 2147483647);
			}

			internal Int16 Version { get; }
			internal bool IsFlexibleVersion { get; }

			public int GetSize(bool _) =>
				(Version.InRange(0, 2147483647) ? 
					ProducerId.GetSize(IsFlexibleVersion) :
					0) +
				(Version.InRange(0, 2147483647) ? 
					Array<WritableTxnMarkerTopicResult>.From(TopicsCollection).GetSize(IsFlexibleVersion) :
					0);

			public static async ValueTask<WritableTxnMarkerResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
			{
				var instance = new WritableTxnMarkerResult(version);
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.ProducerId = await Int64.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (instance.Version.InRange(0, 2147483647)) 
				{
					instance.TopicsCollection = await Array<WritableTxnMarkerTopicResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerTopicResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
				}

				if (instance.IsFlexibleVersion)
				{
					var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
					await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
					{
						switch (tag.Tag)
						{
							default:
								throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerResult is unknown");
						}
					}
				}

				return instance;
			}

			public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
			{
				if (Version.InRange(0, 2147483647)) 
				{
					await ProducerId.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
				if (Version.InRange(0, 2147483647)) 
				{
					await Array<WritableTxnMarkerTopicResult>.From(TopicsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
				}
			}

			private Int64 _producerId = Int64.Default;
			/// <summary>
			/// <para>The current producer ID in use by the transactional ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public Int64 ProducerId 
			{
				get => _producerId;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"ProducerId does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_producerId = value;
				}
			}

			/// <summary>
			/// <para>The current producer ID in use by the transactional ID.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerResult WithProducerId(Int64 producerId)
			{
				ProducerId = producerId;
				return this;
			}

			private WritableTxnMarkerTopicResult[] _topicsCollection = Array.Empty<WritableTxnMarkerTopicResult>();
			/// <summary>
			/// <para>The results by topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerTopicResult[] TopicsCollection 
			{
				get => _topicsCollection;
				set 
				{
					if (Version.InRange(0, 2147483647) == false) 
					{
						throw new UnsupportedVersionException($"TopicsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
					}

					_topicsCollection = value;
				}
			}

			/// <summary>
			/// <para>The results by topic.</para>
			/// <para>Versions: 0+</para>
			/// </summary>
			public WritableTxnMarkerResult WithTopicsCollection(params Func<WritableTxnMarkerTopicResult, WritableTxnMarkerTopicResult>[] createFields)
			{
				TopicsCollection = createFields
					.Select(createField => createField(CreateWritableTxnMarkerTopicResult()))
					.ToArray();
				return this;
			}

			internal WritableTxnMarkerTopicResult CreateWritableTxnMarkerTopicResult()
			{
				return new WritableTxnMarkerTopicResult(Version);
			}

			public class WritableTxnMarkerTopicResult : ISerialize
			{
				internal WritableTxnMarkerTopicResult(Int16 version)
				{
					Version = version;
					IsFlexibleVersion = version.InRange(1, 2147483647);
				}

				internal Int16 Version { get; }
				internal bool IsFlexibleVersion { get; }

				public int GetSize(bool _) =>
					(Version.InRange(0, 2147483647) ? 
						Name.GetSize(IsFlexibleVersion) :
						0) +
					(Version.InRange(0, 2147483647) ? 
						Array<WritableTxnMarkerPartitionResult>.From(PartitionsCollection).GetSize(IsFlexibleVersion) :
						0);

				public static async ValueTask<WritableTxnMarkerTopicResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
				{
					var instance = new WritableTxnMarkerTopicResult(version);
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.Name = await String.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (instance.Version.InRange(0, 2147483647)) 
					{
						instance.PartitionsCollection = await Array<WritableTxnMarkerPartitionResult>.FromReaderAsync(reader, instance.IsFlexibleVersion, () => WritableTxnMarkerPartitionResult.FromReaderAsync(instance.Version, reader, cancellationToken), cancellationToken).ConfigureAwait(false);
					}

					if (instance.IsFlexibleVersion)
					{
						var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
						await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
						{
							switch (tag.Tag)
							{
								default:
									throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerTopicResult is unknown");
							}
						}
					}

					return instance;
				}

				public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
				{
					if (Version.InRange(0, 2147483647)) 
					{
						await Name.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
					if (Version.InRange(0, 2147483647)) 
					{
						await Array<WritableTxnMarkerPartitionResult>.From(PartitionsCollection).WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
					}
				}

				private String _name = String.Default;
				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public String Name 
				{
					get => _name;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"Name does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_name = value;
					}
				}

				/// <summary>
				/// <para>The topic name.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopicResult WithName(String name)
				{
					Name = name;
					return this;
				}

				private WritableTxnMarkerPartitionResult[] _partitionsCollection = Array.Empty<WritableTxnMarkerPartitionResult>();
				/// <summary>
				/// <para>The results by partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerPartitionResult[] PartitionsCollection 
				{
					get => _partitionsCollection;
					set 
					{
						if (Version.InRange(0, 2147483647) == false) 
						{
							throw new UnsupportedVersionException($"PartitionsCollection does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
						}

						_partitionsCollection = value;
					}
				}

				/// <summary>
				/// <para>The results by partition.</para>
				/// <para>Versions: 0+</para>
				/// </summary>
				public WritableTxnMarkerTopicResult WithPartitionsCollection(params Func<WritableTxnMarkerPartitionResult, WritableTxnMarkerPartitionResult>[] createFields)
				{
					PartitionsCollection = createFields
						.Select(createField => createField(CreateWritableTxnMarkerPartitionResult()))
						.ToArray();
					return this;
				}

				internal WritableTxnMarkerPartitionResult CreateWritableTxnMarkerPartitionResult()
				{
					return new WritableTxnMarkerPartitionResult(Version);
				}

				public class WritableTxnMarkerPartitionResult : ISerialize
				{
					internal WritableTxnMarkerPartitionResult(Int16 version)
					{
						Version = version;
						IsFlexibleVersion = version.InRange(1, 2147483647);
					}

					internal Int16 Version { get; }
					internal bool IsFlexibleVersion { get; }

					public int GetSize(bool _) =>
						(Version.InRange(0, 2147483647) ? 
							PartitionIndex.GetSize(IsFlexibleVersion) :
							0) +
						(Version.InRange(0, 2147483647) ? 
							ErrorCode.GetSize(IsFlexibleVersion) :
							0);

					public static async ValueTask<WritableTxnMarkerPartitionResult> FromReaderAsync(Int16 version, PipeReader reader, CancellationToken cancellationToken = default)
					{
						var instance = new WritableTxnMarkerPartitionResult(version);
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.PartitionIndex = await Int32.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (instance.Version.InRange(0, 2147483647)) 
						{
							instance.ErrorCode = await Int16.FromReaderAsync(reader, instance.IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}

						if (instance.IsFlexibleVersion)
						{
							var tagSection = await Tags.TagSection.FromReaderAsync(reader, cancellationToken).ConfigureAwait(false);
							await foreach (var tag in tagSection.WithCancellation(cancellationToken).ConfigureAwait(false))
							{
								switch (tag.Tag)
								{
									default:
										throw new InvalidOperationException($"Tag '{tag.Tag}' for WritableTxnMarkerPartitionResult is unknown");
								}
							}
						}

						return instance;
					}

					public async ValueTask WriteToAsync(Stream writer, bool _, CancellationToken cancellationToken = default)
					{
						if (Version.InRange(0, 2147483647)) 
						{
							await PartitionIndex.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
						if (Version.InRange(0, 2147483647)) 
						{
							await ErrorCode.WriteToAsync(writer, IsFlexibleVersion, cancellationToken).ConfigureAwait(false);
						}
					}

					private Int32 _partitionIndex = Int32.Default;
					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int32 PartitionIndex 
					{
						get => _partitionIndex;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"PartitionIndex does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_partitionIndex = value;
						}
					}

					/// <summary>
					/// <para>The partition index.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public WritableTxnMarkerPartitionResult WithPartitionIndex(Int32 partitionIndex)
					{
						PartitionIndex = partitionIndex;
						return this;
					}

					private Int16 _errorCode = Int16.Default;
					/// <summary>
					/// <para>The error code, or 0 if there was no error.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public Int16 ErrorCode 
					{
						get => _errorCode;
						set 
						{
							if (Version.InRange(0, 2147483647) == false) 
							{
								throw new UnsupportedVersionException($"ErrorCode does not support version {Version} and has been defined as not ignorable. Supported versions: 0+");
							}

							_errorCode = value;
						}
					}

					/// <summary>
					/// <para>The error code, or 0 if there was no error.</para>
					/// <para>Versions: 0+</para>
					/// </summary>
					public WritableTxnMarkerPartitionResult WithErrorCode(Int16 errorCode)
					{
						ErrorCode = errorCode;
						return this;
					}
				}
			}
		}
	}

	public static class ResponseExtensions
	{
		public static ApiVersionsResponse WithAllApiKeys(this ApiVersionsResponse response)
		{
			return response.WithApiKeysCollection(
				key => key
					.WithApiKey(AddOffsetsToTxnRequest.ApiKey)
					.WithMinVersion(AddOffsetsToTxnRequest.MinVersion)
					.WithMaxVersion(AddOffsetsToTxnRequest.MaxVersion),
				key => key
					.WithApiKey(AddPartitionsToTxnRequest.ApiKey)
					.WithMinVersion(AddPartitionsToTxnRequest.MinVersion)
					.WithMaxVersion(AddPartitionsToTxnRequest.MaxVersion),
				key => key
					.WithApiKey(AllocateProducerIdsRequest.ApiKey)
					.WithMinVersion(AllocateProducerIdsRequest.MinVersion)
					.WithMaxVersion(AllocateProducerIdsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterClientQuotasRequest.ApiKey)
					.WithMinVersion(AlterClientQuotasRequest.MinVersion)
					.WithMaxVersion(AlterClientQuotasRequest.MaxVersion),
				key => key
					.WithApiKey(AlterConfigsRequest.ApiKey)
					.WithMinVersion(AlterConfigsRequest.MinVersion)
					.WithMaxVersion(AlterConfigsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterIsrRequest.ApiKey)
					.WithMinVersion(AlterIsrRequest.MinVersion)
					.WithMaxVersion(AlterIsrRequest.MaxVersion),
				key => key
					.WithApiKey(AlterPartitionReassignmentsRequest.ApiKey)
					.WithMinVersion(AlterPartitionReassignmentsRequest.MinVersion)
					.WithMaxVersion(AlterPartitionReassignmentsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterReplicaLogDirsRequest.ApiKey)
					.WithMinVersion(AlterReplicaLogDirsRequest.MinVersion)
					.WithMaxVersion(AlterReplicaLogDirsRequest.MaxVersion),
				key => key
					.WithApiKey(AlterUserScramCredentialsRequest.ApiKey)
					.WithMinVersion(AlterUserScramCredentialsRequest.MinVersion)
					.WithMaxVersion(AlterUserScramCredentialsRequest.MaxVersion),
				key => key
					.WithApiKey(ApiVersionsRequest.ApiKey)
					.WithMinVersion(ApiVersionsRequest.MinVersion)
					.WithMaxVersion(ApiVersionsRequest.MaxVersion),
				key => key
					.WithApiKey(BeginQuorumEpochRequest.ApiKey)
					.WithMinVersion(BeginQuorumEpochRequest.MinVersion)
					.WithMaxVersion(BeginQuorumEpochRequest.MaxVersion),
				key => key
					.WithApiKey(BrokerHeartbeatRequest.ApiKey)
					.WithMinVersion(BrokerHeartbeatRequest.MinVersion)
					.WithMaxVersion(BrokerHeartbeatRequest.MaxVersion),
				key => key
					.WithApiKey(BrokerRegistrationRequest.ApiKey)
					.WithMinVersion(BrokerRegistrationRequest.MinVersion)
					.WithMaxVersion(BrokerRegistrationRequest.MaxVersion),
				key => key
					.WithApiKey(ControlledShutdownRequest.ApiKey)
					.WithMinVersion(ControlledShutdownRequest.MinVersion)
					.WithMaxVersion(ControlledShutdownRequest.MaxVersion),
				key => key
					.WithApiKey(CreateAclsRequest.ApiKey)
					.WithMinVersion(CreateAclsRequest.MinVersion)
					.WithMaxVersion(CreateAclsRequest.MaxVersion),
				key => key
					.WithApiKey(CreateDelegationTokenRequest.ApiKey)
					.WithMinVersion(CreateDelegationTokenRequest.MinVersion)
					.WithMaxVersion(CreateDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(CreatePartitionsRequest.ApiKey)
					.WithMinVersion(CreatePartitionsRequest.MinVersion)
					.WithMaxVersion(CreatePartitionsRequest.MaxVersion),
				key => key
					.WithApiKey(CreateTopicsRequest.ApiKey)
					.WithMinVersion(CreateTopicsRequest.MinVersion)
					.WithMaxVersion(CreateTopicsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteAclsRequest.ApiKey)
					.WithMinVersion(DeleteAclsRequest.MinVersion)
					.WithMaxVersion(DeleteAclsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteGroupsRequest.ApiKey)
					.WithMinVersion(DeleteGroupsRequest.MinVersion)
					.WithMaxVersion(DeleteGroupsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteRecordsRequest.ApiKey)
					.WithMinVersion(DeleteRecordsRequest.MinVersion)
					.WithMaxVersion(DeleteRecordsRequest.MaxVersion),
				key => key
					.WithApiKey(DeleteTopicsRequest.ApiKey)
					.WithMinVersion(DeleteTopicsRequest.MinVersion)
					.WithMaxVersion(DeleteTopicsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeAclsRequest.ApiKey)
					.WithMinVersion(DescribeAclsRequest.MinVersion)
					.WithMaxVersion(DescribeAclsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeClientQuotasRequest.ApiKey)
					.WithMinVersion(DescribeClientQuotasRequest.MinVersion)
					.WithMaxVersion(DescribeClientQuotasRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeClusterRequest.ApiKey)
					.WithMinVersion(DescribeClusterRequest.MinVersion)
					.WithMaxVersion(DescribeClusterRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeConfigsRequest.ApiKey)
					.WithMinVersion(DescribeConfigsRequest.MinVersion)
					.WithMaxVersion(DescribeConfigsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeDelegationTokenRequest.ApiKey)
					.WithMinVersion(DescribeDelegationTokenRequest.MinVersion)
					.WithMaxVersion(DescribeDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeGroupsRequest.ApiKey)
					.WithMinVersion(DescribeGroupsRequest.MinVersion)
					.WithMaxVersion(DescribeGroupsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeLogDirsRequest.ApiKey)
					.WithMinVersion(DescribeLogDirsRequest.MinVersion)
					.WithMaxVersion(DescribeLogDirsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeProducersRequest.ApiKey)
					.WithMinVersion(DescribeProducersRequest.MinVersion)
					.WithMaxVersion(DescribeProducersRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeQuorumRequest.ApiKey)
					.WithMinVersion(DescribeQuorumRequest.MinVersion)
					.WithMaxVersion(DescribeQuorumRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeTransactionsRequest.ApiKey)
					.WithMinVersion(DescribeTransactionsRequest.MinVersion)
					.WithMaxVersion(DescribeTransactionsRequest.MaxVersion),
				key => key
					.WithApiKey(DescribeUserScramCredentialsRequest.ApiKey)
					.WithMinVersion(DescribeUserScramCredentialsRequest.MinVersion)
					.WithMaxVersion(DescribeUserScramCredentialsRequest.MaxVersion),
				key => key
					.WithApiKey(ElectLeadersRequest.ApiKey)
					.WithMinVersion(ElectLeadersRequest.MinVersion)
					.WithMaxVersion(ElectLeadersRequest.MaxVersion),
				key => key
					.WithApiKey(EndQuorumEpochRequest.ApiKey)
					.WithMinVersion(EndQuorumEpochRequest.MinVersion)
					.WithMaxVersion(EndQuorumEpochRequest.MaxVersion),
				key => key
					.WithApiKey(EndTxnRequest.ApiKey)
					.WithMinVersion(EndTxnRequest.MinVersion)
					.WithMaxVersion(EndTxnRequest.MaxVersion),
				key => key
					.WithApiKey(EnvelopeRequest.ApiKey)
					.WithMinVersion(EnvelopeRequest.MinVersion)
					.WithMaxVersion(EnvelopeRequest.MaxVersion),
				key => key
					.WithApiKey(ExpireDelegationTokenRequest.ApiKey)
					.WithMinVersion(ExpireDelegationTokenRequest.MinVersion)
					.WithMaxVersion(ExpireDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(FetchRequest.ApiKey)
					.WithMinVersion(FetchRequest.MinVersion)
					.WithMaxVersion(FetchRequest.MaxVersion),
				key => key
					.WithApiKey(FetchSnapshotRequest.ApiKey)
					.WithMinVersion(FetchSnapshotRequest.MinVersion)
					.WithMaxVersion(FetchSnapshotRequest.MaxVersion),
				key => key
					.WithApiKey(FindCoordinatorRequest.ApiKey)
					.WithMinVersion(FindCoordinatorRequest.MinVersion)
					.WithMaxVersion(FindCoordinatorRequest.MaxVersion),
				key => key
					.WithApiKey(HeartbeatRequest.ApiKey)
					.WithMinVersion(HeartbeatRequest.MinVersion)
					.WithMaxVersion(HeartbeatRequest.MaxVersion),
				key => key
					.WithApiKey(IncrementalAlterConfigsRequest.ApiKey)
					.WithMinVersion(IncrementalAlterConfigsRequest.MinVersion)
					.WithMaxVersion(IncrementalAlterConfigsRequest.MaxVersion),
				key => key
					.WithApiKey(InitProducerIdRequest.ApiKey)
					.WithMinVersion(InitProducerIdRequest.MinVersion)
					.WithMaxVersion(InitProducerIdRequest.MaxVersion),
				key => key
					.WithApiKey(JoinGroupRequest.ApiKey)
					.WithMinVersion(JoinGroupRequest.MinVersion)
					.WithMaxVersion(JoinGroupRequest.MaxVersion),
				key => key
					.WithApiKey(LeaderAndIsrRequest.ApiKey)
					.WithMinVersion(LeaderAndIsrRequest.MinVersion)
					.WithMaxVersion(LeaderAndIsrRequest.MaxVersion),
				key => key
					.WithApiKey(LeaveGroupRequest.ApiKey)
					.WithMinVersion(LeaveGroupRequest.MinVersion)
					.WithMaxVersion(LeaveGroupRequest.MaxVersion),
				key => key
					.WithApiKey(ListGroupsRequest.ApiKey)
					.WithMinVersion(ListGroupsRequest.MinVersion)
					.WithMaxVersion(ListGroupsRequest.MaxVersion),
				key => key
					.WithApiKey(ListOffsetsRequest.ApiKey)
					.WithMinVersion(ListOffsetsRequest.MinVersion)
					.WithMaxVersion(ListOffsetsRequest.MaxVersion),
				key => key
					.WithApiKey(ListPartitionReassignmentsRequest.ApiKey)
					.WithMinVersion(ListPartitionReassignmentsRequest.MinVersion)
					.WithMaxVersion(ListPartitionReassignmentsRequest.MaxVersion),
				key => key
					.WithApiKey(ListTransactionsRequest.ApiKey)
					.WithMinVersion(ListTransactionsRequest.MinVersion)
					.WithMaxVersion(ListTransactionsRequest.MaxVersion),
				key => key
					.WithApiKey(MetadataRequest.ApiKey)
					.WithMinVersion(MetadataRequest.MinVersion)
					.WithMaxVersion(MetadataRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetCommitRequest.ApiKey)
					.WithMinVersion(OffsetCommitRequest.MinVersion)
					.WithMaxVersion(OffsetCommitRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetDeleteRequest.ApiKey)
					.WithMinVersion(OffsetDeleteRequest.MinVersion)
					.WithMaxVersion(OffsetDeleteRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetFetchRequest.ApiKey)
					.WithMinVersion(OffsetFetchRequest.MinVersion)
					.WithMaxVersion(OffsetFetchRequest.MaxVersion),
				key => key
					.WithApiKey(OffsetForLeaderEpochRequest.ApiKey)
					.WithMinVersion(OffsetForLeaderEpochRequest.MinVersion)
					.WithMaxVersion(OffsetForLeaderEpochRequest.MaxVersion),
				key => key
					.WithApiKey(ProduceRequest.ApiKey)
					.WithMinVersion(ProduceRequest.MinVersion)
					.WithMaxVersion(ProduceRequest.MaxVersion),
				key => key
					.WithApiKey(RenewDelegationTokenRequest.ApiKey)
					.WithMinVersion(RenewDelegationTokenRequest.MinVersion)
					.WithMaxVersion(RenewDelegationTokenRequest.MaxVersion),
				key => key
					.WithApiKey(SaslAuthenticateRequest.ApiKey)
					.WithMinVersion(SaslAuthenticateRequest.MinVersion)
					.WithMaxVersion(SaslAuthenticateRequest.MaxVersion),
				key => key
					.WithApiKey(SaslHandshakeRequest.ApiKey)
					.WithMinVersion(SaslHandshakeRequest.MinVersion)
					.WithMaxVersion(SaslHandshakeRequest.MaxVersion),
				key => key
					.WithApiKey(StopReplicaRequest.ApiKey)
					.WithMinVersion(StopReplicaRequest.MinVersion)
					.WithMaxVersion(StopReplicaRequest.MaxVersion),
				key => key
					.WithApiKey(SyncGroupRequest.ApiKey)
					.WithMinVersion(SyncGroupRequest.MinVersion)
					.WithMaxVersion(SyncGroupRequest.MaxVersion),
				key => key
					.WithApiKey(TxnOffsetCommitRequest.ApiKey)
					.WithMinVersion(TxnOffsetCommitRequest.MinVersion)
					.WithMaxVersion(TxnOffsetCommitRequest.MaxVersion),
				key => key
					.WithApiKey(UnregisterBrokerRequest.ApiKey)
					.WithMinVersion(UnregisterBrokerRequest.MinVersion)
					.WithMaxVersion(UnregisterBrokerRequest.MaxVersion),
				key => key
					.WithApiKey(UpdateFeaturesRequest.ApiKey)
					.WithMinVersion(UpdateFeaturesRequest.MinVersion)
					.WithMaxVersion(UpdateFeaturesRequest.MaxVersion),
				key => key
					.WithApiKey(UpdateMetadataRequest.ApiKey)
					.WithMinVersion(UpdateMetadataRequest.MinVersion)
					.WithMaxVersion(UpdateMetadataRequest.MaxVersion),
				key => key
					.WithApiKey(VoteRequest.ApiKey)
					.WithMinVersion(VoteRequest.MinVersion)
					.WithMaxVersion(VoteRequest.MaxVersion),
				key => key
					.WithApiKey(WriteTxnMarkersRequest.ApiKey)
					.WithMinVersion(WriteTxnMarkersRequest.MinVersion)
					.WithMaxVersion(WriteTxnMarkersRequest.MaxVersion));
		}
	}
}